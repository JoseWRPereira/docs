{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Acredito na tecnologia como o conjunto de ferramentas para explorar compet\u00eancias a partir de conhecimentos te\u00f3ricos e pr\u00e1ticos, englobando os atos de sistematizar, representar, analisar e resolver problemas, parafraseando o conceito de pensamento computacional, bem como a impot\u00e2ncia das rela\u00e7\u00f5es interdisciplinares, contextualizadas e cr\u00edticas.</p> <p>Sendo este assim, um local de publica\u00e7\u00e3o de material de estudo nas diferentes \u00e1reas de interesse do autor, com a finalidade de auxiliar o processo de aquisi\u00e7\u00e3o de conhecimento atrav\u00e9s de sua consolida\u00e7\u00e3o em forma de texto ou imagem, aprimorando a habilidade de escrita e concis\u00e3o, mantendo atitude positiva, curiosa e resiliente.</p> <p>Tamb\u00e9m \u00e9 publicado aqui, material de apoio \u00e0s aulas que desenvolvo, com o objetivo de desbravar alguns caminhos da eletr\u00f4nica e automa\u00e7\u00e3o industrial, e ciente de que s\u00e3o \u00e1reas muito amplas, abordando apenas alguns aspectos, mas esperando que seja de grande valia a todos que tiverem contato com esse material.</p> <p>Espero que goste do conte\u00fado.</p> <p>Se gostar, compartilhe o que aprendeu.</p> <p>Se n\u00e3o gostar, colabore e ajude a melhorar.</p> <p>   Jos\u00e9 W. R. Pereira</p>"},{"location":"cursos/","title":"Linguagem C","text":"<ol> <li>Fundamentos da Linguagem C - debxp</li> <li>Curso B\u00e1sico da Linguagem C - debxp</li> </ol>","tags":["Cursos","MATLAB"]},{"location":"cursos/#sistemas-digitais","title":"Sistemas Digitais","text":"<ol> <li>Sistemas Digitais - debxp</li> </ol>","tags":["Cursos","MATLAB"]},{"location":"cursos/#matlab","title":"MATLAB","text":"<ol> <li>MATLAB Onramp</li> <li>MATLAB Plot Gallery</li> <li></li> </ol>","tags":["Cursos","MATLAB"]},{"location":"cursos/#logica-fuzzy","title":"L\u00f3gica Fuzzy","text":"<p>Aplica\u00e7\u00e3o da L\u00f3gica Fuzzy em sw e hw</p>","tags":["Cursos","MATLAB"]},{"location":"cursos/#python","title":"Python","text":"<p> Fonte: LinkedIn Python</p> <p></p>","tags":["Cursos","MATLAB"]},{"location":"cursos/#fft","title":"FFT","text":"<p>Como fazer Transformada de Fourier no Python? (FFT) | Sinais e Sistemas</p>","tags":["Cursos","MATLAB"]},{"location":"cursos/#banco-de-dados","title":"Banco de Dados","text":"","tags":["Cursos","MATLAB"]},{"location":"cursos/#sqlite","title":"SQLite","text":"<ul> <li>How to install SQLite3 on Windows 10/11 [2024 Update] Create Database, Table in SQL | Complete Guide</li> <li>SQLite Databases With Python - Full Course - freeCodeCamp.org</li> <li></li> </ul>","tags":["Cursos","MATLAB"]},{"location":"cursos/#risc-v","title":"RISC-V","text":"<ul> <li>MC404 - Organiza\u00e7\u00e3o B\u00e1sica de Computadores e Linguagem de Montagem</li> <li>An Introduction to Assembly Programming with RISC-V</li> <li>Guia Pr\u00e1tico RISC-V: Atlas de uma arquitetura aberta</li> <li>RISC-V Simulator, RISC-V Interpreter, Venus, QtRVSim.</li> </ul>","tags":["Cursos","MATLAB"]},{"location":"cursos/#latex","title":"LaTeX","text":"<ul> <li>Lista de S\u00edmbolos Matem\u00e1ticos</li> </ul>","tags":["Cursos","MATLAB"]},{"location":"index_automacao/","title":"Automa\u00e7\u00e3o Industrial","text":"<p>A automa\u00e7\u00e3o industrial \u00e9 o conjunto de implementa\u00e7\u00f5es t\u00e9cnicas, que permitem a execu\u00e7\u00e3o parcial ou total de forma autom\u00e1tica de m\u00e1quinas ou processos industriais.</p> <p>A automa\u00e7\u00e3o industrial usa de tecnologias capazes de operar processos com pouca ou nenhuma interven\u00e7\u00e3o humana, em aplica\u00e7\u00f5es tradicionalmente industriais mas atualmente tamb\u00e9m em residenciais e comerciais.</p> <p>Pode ser atribu\u00edda \u00e0 segunda revolu\u00e7\u00e3o industrial o nascimento da automa\u00e7\u00e3o industrial, como a conhecemos, mas os marcos anteriores foram fundamentais para o seu surgimento e desenvolvimento.</p> <p>A primeira revolu\u00e7\u00e3o industrial, substituiu a produ\u00e7\u00e3o manufatureira por m\u00e1quinas, possibilitando a padroniza\u00e7\u00e3o e aumentando drasticamente a escala de produ\u00e7\u00e3o, reduzindo pre\u00e7os e aumentando a classe consumidora, aumentando assim o lucro dos donos das f\u00e1bricas.</p> <p>As m\u00e1quinas que impulsionaram a produ\u00e7\u00e3o neste momento eram \u00e0 vapor, que no s\u00e9culo XIX foram substitu\u00eddas por m\u00e1quinas el\u00e9tricas gra\u00e7as \u00e0 inven\u00e7\u00e3o do motor el\u00e9trico. Da mesma forma, outros dispositivos el\u00e9tricos puderam ser desenvolvidos, proporcionando um maior controle no acionamentos de m\u00e1quinas, inclusive com temporizadores, sistemas de intertravamento e prote\u00e7\u00e3o.</p> <p>J\u00e1 com a terceira revolu\u00e7\u00e3o industrial, ocorrida em meados do s\u00e9culo XX, a revolu\u00e7\u00e3o digital, ap\u00f3s a inven\u00e7\u00e3o do circuitos integrados e da computa\u00e7\u00e3o, permitiu o desenvolvimento de controladores com alto poder de processamento, sensores e atuadores precisos. A comunica\u00e7\u00e3o entre equipamentos melhorou drasticamente, permitindo ganhos substanciais na gest\u00e3o de processos, atrav\u00e9s de comandos e acompanhamentos precisos e eficientes.</p> <p>Toda a infraestrutura para uma automa\u00e7\u00e3o industrial de alta performance j\u00e1 era poss\u00edvel, mas a quarta revolu\u00e7\u00e3o industrial trouxe um ganho de efici\u00eancia com a utiliza\u00e7\u00e3o de intelig\u00eancia artificial, mudando a perspectiva da tomada de decis\u00e3o, que agora \u00e9 baseada em dados obtidos de forma massiva de todos os elementos dos processos produtivos, trazendo ganhos substanciais com uma integra\u00e7\u00e3o profunda, manufatura modular, opera\u00e7\u00e3o em tempo real e elevado grau de otimiza\u00e7\u00e3o.</p> <p>Atualmente, um profissional da \u00e1rea de automa\u00e7\u00e3o industrial, deve possuir compet\u00eancias multidisciplinares, desde a programa\u00e7\u00e3o de controladores, configura\u00e7\u00e3o de servomecanismos, acoplamentos e transmiss\u00f5es mec\u00e2nicas, rede de comunica\u00e7\u00e3o, dispositivos de acionamento e sensores, bem como o funcionamento espec\u00edfico de m\u00e1quinas ou de processos; Suas responsabilidades perpassam as tarefas de projetar, executar, planejar, instalar, realizar manuten\u00e7\u00f5es e testes nos sistemas de controle e automa\u00e7\u00e3o das m\u00e1quinas e dos processos industriais.</p> <p>A integra\u00e7\u00e3o dessas diversas tecnologias, de forma sincronizada, coerente e l\u00f3gica, permite ganhos de produtividade, agilidade, qualidade, e a redu\u00e7\u00e3o de indicadores como custo, falhas e n\u00e3o conformidades.</p> <p>Frente \u00e0 natureza plural e interdisciplinar, novas disciplinas se utilizam de recortes e colagens de conte\u00fados e compet\u00eancias de diversas disciplinas tradicionais, tais como mec\u00e2nica, pneum\u00e1tica, hidr\u00e1ulica, el\u00e9trica, eletr\u00f4nica, computa\u00e7\u00e3o e gest\u00e3o, necess\u00e1rias para iniciar a forma\u00e7\u00e3o de um profissional com as compet\u00eancias necess\u00e1rias para atua\u00e7\u00e3o em automa\u00e7\u00e3o industrial.</p>","tags":["Automa\u00e7\u00e3o","CLP","RPI"]},{"location":"index_dados/","title":"Ci\u00eancia de Dados e a Ind\u00fastria 4.0","text":"<p>Todas as revolu\u00e7\u00f5es industriais apresentam dr\u00e1sticas mudan\u00e7as no cen\u00e1rio produtivo,  desde a utiliza\u00e7\u00e3o das primeiras m\u00e1quinas \u00e0 vapor, a eletrifica\u00e7\u00e3o,  a automa\u00e7\u00e3o (Figura 1) e n\u00e3o seria diferente na sua quarta vers\u00e3o,  tamb\u00e9m chamada de Ind\u00fastria 4.0, em que alguns novos pilares foram inseridos  transformando o modo intera\u00e7\u00e3o entre a mat\u00e9ria prima, as m\u00e1quinas e a m\u00e3o de obra. </p> <p>Todas as inova\u00e7\u00f5es agregadas aos processos produtivos trazem grandes desafios,  afetando o modo de vida em aspectos econ\u00f4micos, social e cultural de praticamente todo o  mundo globalizado. </p> <p>De acordo com Klaus Schwab, \u201cMoldar a quarta revolu\u00e7\u00e3o industrial para garantir que ela  seja empoderadora e centrada no ser humano \u2013 em vez de divisionista e desumana \u2013  n\u00e3o \u00e9 uma tarefa para um \u00fanico interessado ou setor, nem para uma \u00fanica regi\u00e3o,  ou ind\u00fastria ou cultura. Pela pr\u00f3pria natureza fundamental e global dessa revolu\u00e7\u00e3o,  ela afetar\u00e1 e ser\u00e1 influenciada por todos os pa\u00edses, economias,  setores e pessoas\u201d (A quarta revolu\u00e7\u00e3o industrial. S\u00e3o Paulo. Edipro, 2016).</p> Figura 1: As revolu\u00e7\u00f5es industriais Fonte: 9 PILARES TECNOL\u00d3GICOS DA IND\u00daSTRIA 4.0 - OPENCADD <p>Os pilares que sustentam a quarta revolu\u00e7\u00e3o industrial,  de acordo com o The Boston Consulting Group, est\u00e3o ilustrados na Figura 2,  em que a Integra\u00e7\u00e3o de Sistemas talvez seja um elemento de central import\u00e2ncia na  fus\u00e3o das tecnologias e seu emprego orquestrado na melhoria da efici\u00eancia da produ\u00e7\u00e3o  industrial, possibilitando a comunica\u00e7\u00e3o de forma horizontal entre equipamentos e  vertical entre n\u00edveis de organiza\u00e7\u00e3o e gest\u00e3o. </p> <p>O uso de Simula\u00e7\u00f5es em tempo real,  criando um produto digital ou mesmo uma replica digital de uma m\u00e1quina ou linha de produ\u00e7\u00e3o,  g\u00eameo digital, testando hip\u00f3teses e auxiliando o desenvolvimento e manuten\u00e7\u00e3o dos equipamentos.</p> <p>A customiza\u00e7\u00e3o levada ao n\u00edvel de um elemento de produ\u00e7\u00e3o por lote se faz poss\u00edvel,  principalmente com as t\u00e9cnicas de manufatura aditiva,  trazendo um ganho fenomenal em flexibilidade da produ\u00e7\u00e3o. </p> <p>A Realidade aumentada traz um grande potencial, principalmente nos setores de  manuten\u00e7\u00e3o e treinamento, possibilitando inserir sobre o mundo real,  proje\u00e7\u00f5es que servem de informa\u00e7\u00e3o ou orienta\u00e7\u00e3o para procedimentos, sejam na \u00e1rea m\u00e9dica,  educacional ou industrial.</p> <p>A linha de produ\u00e7\u00e3o, muitas vezes, composta de rob\u00f4s aut\u00f4nomos, trazendo maior uniformidade,  flexibilidade e velocidade para a produ\u00e7\u00e3o, utilizando par\u00e2metros produzidos por  algoritmos de intelig\u00eancia artificial. </p> Figura 2: Pilares do avan\u00e7o tecnol\u00f3gico Fonte: Transforma\u00e7\u00e3o Digital na Ind\u00fastria 4.0 - Fluxo <p>A integra\u00e7\u00e3o horizontal no ch\u00e3o de f\u00e1brica \u00e9 poss\u00edvel, inclusive,  devido ao desenvolvimento do que chamado de Internet das coisas,  em que os diversos dispositivos nos diversos n\u00edveis hier\u00e1rquicos no ch\u00e3o de f\u00e1brica,  conseguem se comunicar, prioritariamente atrav\u00e9s de servidores em Nuvem.  Sendo esses locais centros de armazenamento e processamento do grande volume de dados,  Big Data, em um servidor que n\u00e3o \u00e9 mais associado fisicamente \u00e0 fabrica,  sendo agora um servi\u00e7o oferecido por outras empresas especializadas em servi\u00e7os de  computa\u00e7\u00e3o em nuvem, retirando essa carga de uma equipe de tecnologia de informa\u00e7\u00e3o e  uma central de processamento de dados local, com todos os requisitos de  disponibilidade e seguran\u00e7a (Cyberseguran\u00e7a) sob responsabilidade desses provedores. </p> <p>Todo o conjunto massivo de dados \u00e9 analisado (Analytics) atrav\u00e9s de algoritmos de  intelig\u00eancia artificial e produz par\u00e2metros para tomada de decis\u00e3o de forma a  interferir nos processos locais ou mesmo corporativos. </p> <p>Em todos os processos h\u00e1 produ\u00e7\u00e3o de dados, que podem ser relevantes ao processo,  por isso s\u00e3o armazenados e analisados, gerando descobertas e produ\u00e7\u00e3o de informa\u00e7\u00f5es  relevantes \u00e0 melhoria do processo produtivo. Devido a sua centralidade e import\u00e2ncia,  os dados se tornaram o sin\u00f4nimo de m\u00e1teria-prima desta revolu\u00e7\u00e3o, a era dos dados,  a era da informa\u00e7\u00e3o, sendo o seu volume imposs\u00edvel de ser analisado de forma tradicional,  por cientistas de dados, faz-se necess\u00e1rio desenvolvimento de algoritmos que  consigam analisar um volume t\u00e3o grande de dados, de forma a extrair as informa\u00e7\u00f5es  relevantes de forma autom\u00e1tica, e por isso a grande relev\u00e2ncia e import\u00e2ncia da  intelig\u00eancia artificial e t\u00e9cnicas de aprendizado de m\u00e1quina t\u00e3o presentes nas  tecnologias contempor\u00e2neas. </p> <p>Refer\u00eancias e complementos</p> <ol> <li>Ind4.0 - Manufatura avan\u00e7ada</li> <li>C\u00f3digo Fonte TV - CEO TROCA TODO TIME DE DEVS POR INTELIG\u00caNCIA ARTIFICIAL.</li> <li>9 PILARES TECNOL\u00d3GICOS DA IND\u00daSTRIA 4.0 - OPENCADD</li> <li>Transforma\u00e7\u00e3o Digital na Ind\u00fastria 4.0 - Fluxo</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina","L\u00f3gica Fuzzy","L\u00f3gica Paraconsistente"]},{"location":"index_dados/#aulas-taa","title":"Aulas TAA","text":"Aula T\u00edtulo Conte\u00fado Material complementar 0 Apresenta\u00e7\u00e3o da disciplina - Ementa;  - Objetivos  - Conte\u00fado program\u00e1tico  - Bibliografia  - Avalia\u00e7\u00e3o Engenharia de Controle e Automa\u00e7\u00e3o - PPC 2029 1 Ind\u00fastria 4.0 - Revolu\u00e7\u00f5es Industriais  - Pilares tecnol\u00f3gicos 1. Ind4.0 - Manufatura avan\u00e7ada  2. C\u00f3digo Fonte TV - CEO TROCA TODO TIME DE DEVS POR INTELIG\u00caNCIA ARTIFICIAL.  3. 9 PILARES TECNOL\u00d3GICOS DA IND\u00daSTRIA 4.0 - OPENCADD  4. Transforma\u00e7\u00e3o Digital na Ind\u00fastria 4.0 - Fluxo  5. A hist\u00f3ria da intelig\u00eancia artificial - TecMundo 2 Intelig\u00eancia Artificial - Intelig\u00eancia Artificial  - Machine Learning  - Redes Neurais 1. Artificial Intelligence Coined at Dartmouth  2. Qual \u00e9 a Diferen\u00e7a entre Intelig\u00eancia Artificial, Machine Learning e Deep Learning? 10 de mar\u00e7o de 2021 por Michael Copeland - Blog NVIDIA)  3. A hist\u00f3ria da intelig\u00eancia artificial - TecMundo  4. O que \u00e9 aprendizado de m\u00e1quina (ML)? - IBM  5. A Friendly Introduction to [Deep] Neural Networks - August 23, 2021 - Kathrin Melcher - KNIME 3 Ci\u00eancia de Dados - An\u00e1lise de dados  - Tipos de An\u00e1lise de dados  - An\u00e1lise Descritiva  - An\u00e1lise Diagn\u00f3stica  - An\u00e1lise Preditiva  - An\u00e1lise Prescritiva 1. Kaggle - Forecasting Future Passengers w/ PyCaret  2. Esses s\u00e3o os 5 PASSOS para fazer uma AN\u00c1LISE DE DADOS - Comunidade DS  3. Data Viking - Odemir Depieri Jr","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina","L\u00f3gica Fuzzy","L\u00f3gica Paraconsistente"]},{"location":"index_digitais/","title":"Sistemas Digitais","text":"<p>Os sistemas digitais s\u00e3o circuitos projetados para manipular dados em formato bin\u00e1rio, podendo representar grandezas f\u00edsicas de forma discreta, processar esses dados e produzir um resultado mediante um conjunto de regras de constru\u00e7\u00e3o e/ou instru\u00e7\u00f5es programadas. </p> <p>Sistemas digitais est\u00e3o amplamente presentes no dispositivos eletr\u00f4nicos que s\u00e3o utilizados atualmente, assumindo um papel de grande relev\u00e2ncia em todo avan\u00e7o tecnol\u00f3gico desde que foram criados. </p> <p>S\u00e3o muitas as tecnologias que abrangem o termo <code>Sistemas digitais</code>, em que pode-se citar as simples portas l\u00f3gicas da eletr\u00f4nica digital, at\u00e9 os atuais processadores e microcontroladores de arquitetura ARM ou Risc-V, ou ainda Dispositivos de L\u00f3gica Configur\u00e1vel com CPLDs e FPGAs. </p>","tags":["Sistemas Eletr\u00f4nicos","MCMP","MMR","MCU","AVR"]},{"location":"index_gestao/","title":"Gest\u00e3o de Projetos","text":"","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"index_gestao/#gestao-de-projetos","title":"Gest\u00e3o de Projetos","text":"<p>A gest\u00e3o de projetos no contexto espec\u00edfico tecnol\u00f3gico dos sistemas embarcados \u00e9 definida como o processo de planejamento, organiza\u00e7\u00e3o e controle de recursos para levar um produto desde a concep\u00e7\u00e3o at\u00e9 a manuten\u00e7\u00e3o final. Sua import\u00e2ncia \u00e9 vital devido \u00e0s restri\u00e7\u00f5es severas de custo, desempenho e tempo de coloca\u00e7\u00e3o no mercado (time-to-market), al\u00e9m da necessidade de mitigar riscos t\u00e9cnicos antes do in\u00edcio da produ\u00e7\u00e3o f\u00edsica.</p> <p>As principais t\u00e9cnicas e ferramentas incluem:</p> <ul> <li>Modelos de Ciclo de Vida: Utilizam-se abordagens como o Modelo em V, comum em projetos de TI alem\u00e3es, o modelo Cascata (Waterfall), o modelo Espiral e o \"Big-Bang\". </li> <li>Fases do Projeto: O gerenciamento divide-se tipicamente em an\u00e1lise (defini\u00e7\u00e3o de requisitos e especifica\u00e7\u00f5es), projeto de engenharia (arquitetura), implementa\u00e7\u00e3o e testes de valida\u00e7\u00e3o.</li> <li>Ferramentas de Gerenciamento: Profissionais brasileiros da \u00e1rea utilizam frequentemente softwares como Microsoft Excel (37,2%), Jira (30,85%) e Microsoft Teams (28,01%) para organizar tarefas e equipes e Git/Github como ferramenta de versionamento de c\u00f3digo.</li> </ul> <p>As ferramentas da qualidade, por sua vez, s\u00e3o m\u00e9todos aplicados para garantir que o sistema embarcado funcione conforme o esperado e atenda a requisitos rigorosos de confiabilidade e seguran\u00e7a, especialmente em setores cr\u00edticos como o automotivo e m\u00e9dico.</p> <p>Algumas das principais t\u00e9cnicas:</p> <ul> <li>PDCA (Plan, Do, Check, Act): Ciclo fundamental para a melhoria cont\u00ednua e conformidade com normas como a ISO 9001.</li> <li>FMEA (Failure Mode and Effect Analysis): An\u00e1lise de baixo para cima que estima a confiabilidade do sistema a partir de falhas potenciais em seus componentes individuais.</li> <li>An\u00e1lise de \u00c1rvore de Falhas (Fault Tree Analysis - FTA): T\u00e9cnica l\u00f3gica que deriva a confiabilidade do sistema total atrav\u00e9s da an\u00e1lise combinada de falhas de componentes.</li> <li>Revis\u00f5es de C\u00f3digo e Inspe\u00e7\u00f5es: Pr\u00e1ticas de engenharia para verificar se o desenvolvimento segue padr\u00f5es arquiteturais e normas t\u00e9cnicas, visando identificar bugs prematuramente.</li> <li>Verifica\u00e7\u00e3o Formal: Uso de rigor matem\u00e1tico para provar que o design do sistema est\u00e1 correto e atende a todas as restri\u00e7\u00f5es.</li> <li>M\u00e9tricas de Qualidade: Avalia\u00e7\u00e3o baseada em par\u00e2metros como MTBF (Mean Time Between Failures), acur\u00e1cia, precis\u00e3o e efici\u00eancia din\u00e2mica (velocidade de execu\u00e7\u00e3o).</li> </ul>","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"index_gestao/#referencias","title":"Refer\u00eancias","text":"<ol> <li> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> </li> <li> <p>MARWEDEL, Peter. Embedded System Design: Embedded Systems Foundations of Cyber-Physical Systems, and the Internet of Things. 4. ed. Dortmund: Springer Nature, 2021.</p> </li> <li> <p>NOERGAARD, Tammy. Embedded Systems Architecture: A Comprehensive Guide for Engineers and Programmers. Oxford: Elsevier, 2005.</p> </li> <li> <p>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. Austin: [s. n.], 2014. v. 1.</p> </li> </ol>","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"index_ifsp_slt/","title":"IFSP Salto","text":"<ul> <li>Curso de Gradua\u00e7\u00e3o:<ul> <li>Bacharelado em Engenharia de Controle e Automa\u00e7\u00e3o - PPC (ingressantes at\u00e9 2022)<ul> <li>SPDE8 - Sistemas Digitais Program\u00e1veis</li> </ul> </li> </ul> </li> <li>Curso T\u00e9cnico Concomitante/Subsequente:<ul> <li>T\u00e9cnico em Automa\u00e7\u00e3o Industrial - PPC</li> </ul> </li> <li>Curso T\u00e9cnico Integrado ao Ensino M\u00e9dio:<ul> <li>T\u00e9cnico em Mecatr\u00f4nica - PPC</li> </ul> </li> </ul> <p>PPC: Projeto Pedag\u00f3gico do Curso</p>","tags":["Disciplinas"]},{"location":"indicacoes/","title":"Indica\u00e7\u00f5es","text":"","tags":["automa\u00e7\u00e3o","eletr\u00f4nica"]},{"location":"indicacoes/#eletronica","title":"Eletr\u00f4nica","text":"<ul> <li> <p>   Luiz Bitencourt </p> </li> <li> <p>   Rodrigo Rech </p> </li> <li> <p>   Leandro Poloni </p> </li> <li> <p>  Eder Andrade  &lt;includemicro&gt;</p> </li> <li> <p>  Alison Freitas </p> </li> </ul>","tags":["automa\u00e7\u00e3o","eletr\u00f4nica"]},{"location":"indicacoes/#automacao","title":"Automa\u00e7\u00e3o","text":"<ul> <li>  Vicente Parolis - Aprendiz de Automa\u00e7\u00e3o </li> </ul>","tags":["automa\u00e7\u00e3o","eletr\u00f4nica"]},{"location":"indicacoes/#arte-e-cultura","title":"Arte e Cultura","text":"<ul> <li> <p>  Fernando Medeiros - Caf\u00e9s e blablabl\u00e1s </p> </li> <li> <p>  Ana Teixeira</p> </li> </ul>","tags":["automa\u00e7\u00e3o","eletr\u00f4nica"]},{"location":"indicacoes/#curiosidades","title":"Curiosidades","text":"<ul> <li>ASCII Art</li> </ul>","tags":["automa\u00e7\u00e3o","eletr\u00f4nica"]},{"location":"automacao/clp/","title":"Controladores Program\u00e1veis","text":"Aula T\u00edtulo Conte\u00fado Material complementar 01 Contexto hist\u00f3rico - O problema da ind\u00fastria;- O desafio da General Motors - 1968;- Modular Digital Controller (MODICON 084);- Ler-Decidir-Acionar;- Defini\u00e7\u00f5es (ABNT, NEMA e IEC);- Tipos de CLPs (Compactos e Modulares);- Fabricantes; - Norma IEC 61131-3; 1. Modicon: 50 anos de Pioneirismo e Inova\u00e7\u00f5es - Blog Schneider Electric  2. A hist\u00f3ria dos controladores program\u00e1veis - Altus  3. Curiosidades sobre os CLPs ou\u00a0PLC - O Professor Leandro  4. The Modicon 084 PLC Literally Changed the World - Kalil4.0  5. Who is the Father of the PLC ? - RealPairs  6. Programable Logic Controller Basics Explained - automation engineering - The Engineering Mindset 02 Descri\u00e7\u00e3o estrutural - Fonte de alimenta\u00e7\u00e3o;- Unidade Central de Processamento - CPU;- Mem\u00f3rias;- Entradas Digitais;- Sa\u00eddas Digitais;- Comunica\u00e7\u00e3o;- Expans\u00e3o;- Scan-time / Tempo de varredura; 1. Programable Logic Controller Basics Explained - The Engineering Mindset  2. PLC Basics - Programmable Logic Controller - RealPairs  3. PLC Hardware Components - Automatedo 03 Descri\u00e7\u00e3o funcional - Sinais de Entradas e Sa\u00eddas;- Mapa de Entradas e Sa\u00eddas;- Planejar e Executar - Partida de motor: \u2003 - Contato aberto e contato fechado; \u2003 - Bobina e Mem\u00f3ria;    \u2003 - L\u00f3gica Combinacional (E, OU e N\u00c3O);    \u2003 - Fun\u00e7\u00e3o Set e Reset","tags":["CLP","Controlador program\u00e1vel","PLC","IFSP"]},{"location":"automacao/clp/altus_tb131/h1_10_1-ihm_display_var/","title":"Display Vari\u00e1vel","text":"","tags":["CLP","Altus","TB131","IHM","Display var"]},{"location":"automacao/clp/altus_tb131/h1_10_1-ihm_display_var/#1-configuracao-de-formato-de-exibicao","title":"1. Configura\u00e7\u00e3o de formato de exibi\u00e7\u00e3o","text":"<ol> <li>Selecione a aba <code>Visualiza\u00e7\u00f5es</code>;</li> <li>Duplo clique na visualiza\u00e7\u00e3o <code>MAIN</code>;</li> <li>Selecione a ferramenta de desenho <code>ret\u00e2ngulo</code>;</li> <li>Desenhe um ret\u00e2ngulo e aplique um duplo clique sobre ele, abrindo a janela <code>Configura\u00e7\u00e3o de elemento regular</code>;</li> <li>Selecione a categoria: <code>Texto</code>;</li> <li>Insira <code>%u</code> para a exibi\u00e7\u00e3o da vari\u00e1vel no formato inteiro.<ul> <li>Para informa\u00e7\u00f5es de formatos poss\u00edveis, clique no bot\u00e3o <code>?</code> ao lado da janela de <code>Conte\u00fado</code>.</li> </ul> </li> </ol>","tags":["CLP","Altus","TB131","IHM","Display var"]},{"location":"automacao/clp/altus_tb131/h1_10_1-ihm_display_var/#2-link-de-exibicao-com-variavel","title":"2. Link de exibi\u00e7\u00e3o com vari\u00e1vel","text":"<ol> <li>Selecione a categoria: <code>Vari\u00e1veis</code>;</li> <li>Um clique simples no campo <code>Texto</code> da se\u00e7\u00e3o <code>Vari\u00e1veis</code>;</li> <li>Pressione a tecla <code>F2</code> para abrir o <code>Assistente de entrada</code>;</li> <li>Selecione a vari\u00e1vel que se quer exibir, seja ela global ou do seu projeto.</li> </ol> <ol> <li>Clique em <code>OK</code> e novamente em <code>OK</code>.</li> <li>Clique em <code>Projetos</code> e <code>Compilar Tudo</code>;</li> <li>Estando tudo certo <code>0 Erros</code> fa\u00e7a o Download e execute a aplica\u00e7\u00e3o.</li> </ol>","tags":["CLP","Altus","TB131","IHM","Display var"]},{"location":"automacao/clp/altus_tb131/h1_10_2-ihm_edita_var/","title":"Edi\u00e7\u00e3o de Vari\u00e1veis atrav\u00e9s da IHM","text":"","tags":["CLP","Altus","TB131","IHM","Teclas"]},{"location":"automacao/clp/altus_tb131/h1_10_2-ihm_edita_var/#1-criando-programa-de-exemplo-adicao-de-dois-valores-editaveis","title":"1. Criando programa de exemplo: Adi\u00e7\u00e3o de dois valores edit\u00e1veis.","text":"","tags":["CLP","Altus","TB131","IHM","Teclas"]},{"location":"automacao/clp/altus_tb131/h1_10_2-ihm_edita_var/#2-construcao-de-tela-e-atribucao-de-variaveis","title":"2. Constru\u00e7\u00e3o de tela e atribu\u00e7\u00e3o de vari\u00e1veis","text":"","tags":["CLP","Altus","TB131","IHM","Teclas"]},{"location":"automacao/clp/altus_tb131/h1_10_2-ihm_edita_var/#3-simulacao-de-bloco-de-adicao","title":"3. Simula\u00e7\u00e3o de bloco de adi\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","IHM","Teclas"]},{"location":"automacao/clp/altus_tb131/lab00-ambientacao/","title":"Equipamento","text":"<p>O Duo \u00e9 um equipamento da s\u00e9rie de Controladores Program\u00e1veis da Altus com Interface Homem M\u00e1quina (IHM) incorporada. Utilizado em sistemas que demandam supervis\u00e3o e controle em um s\u00f3 ambiente.</p> <p>O controlador utilizado no laborat\u00f3rio est\u00e1 montado em um kit did\u00e1tico denominado TB131, contendo conex\u00f5es que facilitam testes de bancada e conex\u00f5es com eletrov\u00e1lvulas, contatores e sensores com a utiliza\u00e7\u00e3o de cabos com pino tipo 'banana'. Possui ainda ch\u00e1ves para simula\u00e7\u00e3o de acionamentos, motor de passo incorporado, potenci\u00f4metros em entradas anal\u00f3gicas e display de 7 segmentos para sa\u00edda anal\u00f3gica.</p> <p></p>","tags":["CLP","Altus","TB131","Ambienta\u00e7\u00e3o"]},{"location":"automacao/clp/altus_tb131/lab00-ambientacao/#ferramentas-de-desenvolvimento","title":"Ferramentas de Desenvolvimento","text":"<p>Para o desenvolvimento dos programas, pode-se baixar o software Master Tool IEC diretamente do site da Altus SA, acessando o seguinte caminho:</p> <ul> <li>Download &gt; Software de Programa\u00e7\u00e3o &gt; Software</li> </ul> <p></p> <p></p> <p>Para a comunica\u00e7\u00e3o do controlador com o computador, pode ser necess\u00e1ria a instala\u00e7\u00e3o de um driver de comunica\u00e7\u00e3o.</p>","tags":["CLP","Altus","TB131","Ambienta\u00e7\u00e3o"]},{"location":"automacao/clp/altus_tb131/lab00-ambientacao/#ambiente-de-desenvolvimento","title":"Ambiente de Desenvolvimento","text":"<p>O Master Tool IEC \u00e9 o ambiente de desenvolvimento para o controlador program\u00e1vel da s\u00e9rie Duo, da Altus.</p> <p>A figura abaixo ilustra as ferramentas da sua interface padr\u00e3o, destacando-se:</p> <ol> <li>Barra de ferramentas;</li> <li>Janela de navega\u00e7\u00e3o no projeto ou Organizador de objetos;</li> <li>Editor de declara\u00e7\u00e3o de vari\u00e1veis;</li> <li>Editor de c\u00f3digo (programa);</li> <li>Janela de mensagens;</li> <li>Barra de status;</li> </ol> <p></p>","tags":["CLP","Altus","TB131","Ambienta\u00e7\u00e3o"]},{"location":"automacao/clp/altus_tb131/lab01-novo_projeto/","title":"Criando um novo projeto","text":"<p>1. Criando um novo projeto a partir de um modelo:</p> <p>1.1 Com o Master Tool IEC aberto, clique em <code>Arquivo</code> &gt; <code>Novo a partir do modelo...</code></p> <p>1.2 Selecione a segunda op\u00e7\u00e3o: Modelo_DU350_DU351_v110 &gt; Abrir</p> <p></p> <p>2. Verificando arquivo <code>NAVEGA (PRG)</code>:</p> <p>Em POUs, abra o arquivo <code>NAVEGA (PRG)</code> e verifique se o conte\u00fado est\u00e1 como ilustrado abaixo:</p> <pre><code>PROGRAM NAVEGA\nVAR\n    ControleTelas : NAVIGATION;\n    ListaTelas  : ARRAY [0..30] OF STRING(10);\nEND_VAR\n</code></pre> <pre><code>(* Adiciona a tela MAIN como tela principal *)\nListaTelas[0] := 'MAIN';\n\n(* Ativa o controle autom\u00e1tico de navega\u00e7\u00e3o somente pelo teclado *)\nControleTelas(ENABLE_UPDW := FALSE, VISU_LIST := ListaTelas, UP := FALSE , DOWN := FALSE);\n</code></pre> <p>Caso o conte\u00fado esteja ausente, copie este conte\u00fado e insira-o no arquivo <code>NAVEGA (PRG)</code>.</p> <p>3. Acrescentando um objeto do tipo <code>Programa</code> em linguagem <code>Ladder</code>:</p> <p>3.1 Em POUs, clique com o bot\u00e3o direito do mouse e selecione: Acrescentar objeto...</p> <p>3.2 Na janela <code>Nova POU</code>, selecione:</p> <p>3.3 Tipo da POU: Programa;</p> <p>3.4 Linguagem da POU: LD;</p> <p>3.5 Mantenha o Nome da nova POU: PLC_PRG;</p> <p>3.6 Clique em OK.</p> <p></p> <p>4. Testando comunica\u00e7\u00e3o com PLC:</p> <p>4.1 Conecte o PLC ao computador;</p> <p>4.2 Abra o gerenciador de dispositivos e verifique qual porta foi alocada para a comunica\u00e7\u00e3o com o PLC:</p> <p></p> <p>Aqui a porta alocada foi a <code>COM3</code>.</p> <p>4.3 No MasterTool, clique em <code>Comunica\u00e7\u00e3o</code> -&gt; <code>Par\u00e2metros de comunica\u00e7\u00e3o ...</code></p> <p></p> <p>4.4 Para ajustar a porta clique duplo sobre a <code>COMn</code> e use as setas para cima e para baixo para ajustar a porta correta, neste caso a <code>COM3</code>;</p> <p>4.5 Clique em <code>OK</code>.</p> <p>5. Testando o processo de grava\u00e7\u00e3o:</p> <p>5.1 Ap\u00f3s todos os ajustes realizados, clique em <code>Comunica\u00e7\u00e3o</code> e <code>Login</code>.</p> <p>5.2 A mensagem: <code>O programa foi alterado! Enviar o novo programa?</code> deve aparecer se estiver tudo certo.</p> <p>5.3 Estando tudo certo, clique em <code>Sim</code> e o Download ser\u00e1 realizado.</p> <p></p> <p>5.4 Caso um erro ocorra:</p> <p>5.4.1 Verificar os cabos de conex\u00e3o e tente novamente. Se persistir, solicite orienta\u00e7\u00e3o ao professor.</p> <p>5.4.2 N\u00e3o entre em p\u00e2nico !</p>","tags":["CLP","Altus","TB131","Novo projeto"]},{"location":"automacao/clp/altus_tb131/lab02-contatos_bobinas/","title":"Contatos e Bobinas","text":"<p>Os elementos b\u00e1sicos na programa\u00e7\u00e3o em linguagem Ladder s\u00e3o os contatos e as bobinas. </p> <p>Um contato \u00e9 uma representa\u00e7\u00e3o do estado l\u00f3gico de uma das entradas. </p> <p>Os contatos mais comuns s\u00e3o: aberto e fechado, em sua condi\u00e7\u00e3o normal.</p> <p>Na condi\u00e7\u00e3o em que n\u00e3o h\u00e1 est\u00edmulo da entrada, o contato respectivo permanece na condi\u00e7\u00e3o normal, mas quando a entrada \u00e9 estimulada, ou seja, \u00e9 aplicada uma tens\u00e3o proveniente do fechamento de uma chave, fim-de-curso ou sensor, o cotato muda de estado: o contato aberto fecha e o fechado abre, indicando uma mudan\u00e7a de estado da entrada f\u00edsica. </p> <p>Uma bobina \u00e9 uma representa\u00e7\u00e3o do estado l\u00f3gico de uma das sa\u00eddas. Da mesma forma que nas entradas, por\u00e9m, a sa\u00edda f\u00edsica que \u00e9 acionada ou n\u00e3o dependendo do estado l\u00f3gico da bobina, no programa. </p> <p></p>","tags":["CLP","Altus","TB131","Contatos","Bobinas"]},{"location":"automacao/clp/altus_tb131/lab02-contatos_bobinas/#enderecamento-das-entradas-e-saidas-digitais","title":"Endere\u00e7amento das entradas e sa\u00eddas digitais","text":"<p>Todas as entradas e sa\u00eddas s\u00e3o mapeadas em regi\u00f5es de mem\u00f3ria. Assim para fazer a l\u00f3gica em um programa, basta acessar o endere\u00e7o correspondente \u00e0 entrada que se quer ler e associ\u00e1-la a um contato, que passa a representar o estado l\u00f3gico da entrada f\u00edsica. </p> <p></p> <p>No kit de treinamento TB131 h\u00e1 a seguinte rela\u00e7\u00e3o das entradas e sa\u00eddas com os respectivos endere\u00e7os de mem\u00f3ria:</p> TB131  Entradas Mem\u00f3ria TB131  Sa\u00eddas Mem\u00f3ria I00 %IX0.0 Q10 %QX1.0 I01 %IX0.1 Q11 %QX1.1 I02 %IX0.2 Q12 %QX1.2 I03 %IX0.3 Q13 %QX1.3 I04 %IX0.4 Q14 %QX1.4 I05 %IX0.5 Q15 %QX1.5 I06 %IX0.6 Q16 %QX1.6 I07 %IX0.7 Q17 %QX1.7 <p>Assim, para a primeira entrada acionar a primeira sa\u00edda com l\u00f3gica direta, basta realizar a seguinte liga\u00e7\u00e3o: </p> <pre><code>   %IX0.0                     %QX1.0\n|----| |------------------------( )----|\n</code></pre> <p>Ou ainda, pode-se utilizar a declara\u00e7\u00e3o das vari\u00e1veis j\u00e1 existente para o equipamento, em que os endere\u00e7os das vari\u00e1veis est\u00e3o associados com os respectivos nomes de marca\u00e7\u00e3o na parte f\u00edsica do equipamento. Ent\u00e3o, o mesmo c\u00f3digo pode ser declarado da seguinte forma:</p> <pre><code>     I00                        Q10\n|----| |------------------------( )----|\n</code></pre>","tags":["CLP","Altus","TB131","Contatos","Bobinas"]},{"location":"automacao/clp/altus_tb131/lab02-contatos_bobinas/#declaracao-de-variaveis-e-identificadores","title":"Declara\u00e7\u00e3o de Vari\u00e1veis e Identificadores","text":"<p>A sintaxe da declara\u00e7\u00e3o de vari\u00e1veis \u00e9:</p> <pre><code>&lt;Identificador&gt; {AT &lt;Endere\u00e7o&gt;}:&lt;Type&gt; {:=&lt;inicializa\u00e7\u00e3o&gt;}; \n</code></pre> <ul> <li>Os elementos entre chaves <code>{ }</code> s\u00e3o opcionais.</li> <li>O identificador \u00e9 o nome de uma vari\u00e1vel:<ul> <li>n\u00e3o pode conter espa\u00e7os ou caracteres n\u00e3o permitidos;</li> <li>ele n\u00e3o pode ser declarado em dobro;</li> <li>n\u00e3o pode ser id\u00eantico a qualquer palavra-chave.</li> <li>a escrita de vari\u00e1veis em mai\u00fasculas/min\u00fasculas \u00e9 ignorada<ul> <li>Ex: VAR1, Var1 e var1 n\u00e3o s\u00e3o vari\u00e1veis diferentes. </li> </ul> </li> </ul> </li> </ul> <p>Exemplo: </p> <pre><code>(* Declara\u00e7\u00e3o de vari\u00e1veis *)\n\nLigar       AT %IX0.1: BOOL := 0; \nDesligar    AT %IX0.0: BOOL := 0; \nMotor       AT %QX1.0: BOOL := 0; \n</code></pre> <p>Obs: Nos exemplos s\u00e3o apresentadas apenas as declara\u00e7\u00f5es das vari\u00e1veis, sem a seguinte estrutura: </p> <pre><code>PROGRAM PLC_PRG\nVAR\n\nEND_VAR\n</code></pre> <p>Bem como o programa, \u00e9 apresentado em forma de texto monoespa\u00e7ado, para reduzir a quantidade de imagens no site, facilitando a sua renderiza\u00e7\u00e3o da p\u00e1gina. </p> <pre><code>(* Programa em linguagem Ladder *)\n\n     Ligar     Desligar                       Motor\n|-----| |--------|/|---------------------------( )----|\n           |\n     Motor |\n|-----| |--\u00b4\n</code></pre> <p>Obs: Este trecho n\u00e3o pode ser copiado, pois o editor do Master Tool IEC \u00e9 gr\u00e1fico e n\u00e3o possui interface para este tipo de nota\u00e7\u00e3o. </p> <p>Segue ilustra\u00e7\u00e3o da declara\u00e7\u00e3o das vari\u00e1veis e do programa inseridos no Master Tool IEC. </p> <p></p> <p>Note que ap\u00f3s a compila\u00e7\u00e3o, deve aparecer a mensagem como na Janela de Mansagens: <code>0 erro(s), 0 aviso(s)</code>.</p> <p>Para executar o programa clique em <code>Comunica\u00e7\u00e3o</code> -&gt; <code>Run</code>.</p>","tags":["CLP","Altus","TB131","Contatos","Bobinas"]},{"location":"automacao/clp/altus_tb131/lab02-contatos_bobinas/#operacoes-logicas","title":"Opera\u00e7\u00f5es l\u00f3gicas","text":"<p>As opera\u00e7\u00f5es l\u00f3gicas s\u00e3o regras que se baseiam em proposi\u00e7\u00f5es iniciais para produzir um valor l\u00f3gico como resultado. </p> <p>As proposi\u00e7\u00f5es iniciais e o resultado s\u00e3o estados l\u00f3gicos booleanos, Verdadeiro e Falso, que s\u00e3o aqui representados com os valores 1 e 0 respectivamente.</p> <p>As opera\u00e7\u00f5es l\u00f3gicas mais comuns s\u00e3o: Nega\u00e7\u00e3o (~), Conjun\u00e7\u00e3o (^), Disjun\u00e7\u00e3o (v) e ainda Condicional (-&gt;) e Bicondicional (&lt;-&gt;) que est\u00e3o fora do escopo deste material. </p> <p>Para utilizar estes operandos, \u00e9 necess\u00e1rio conhecer as suas regras de aplica\u00e7\u00e3o, que normalmente s\u00e3o expressas em forma de tabela verdade. </p> <p>A linguagem ladder utiliza a simbologia de contatos para representar os estados l\u00f3gicos: </p> <ul> <li>Contato aberto:  <code>---| |----</code></li> <li>Contato fechado: <code>---|/|----</code></li> </ul> <p>Opera\u00e7\u00e3o: Nega\u00e7\u00e3o (N\u00c3O)</p> A \\(Y = \\bar{A}\\) 0 1 1 0 <pre><code>      A                   Y\n|----|/|-----------------( )----|\n</code></pre> <p>Opera\u00e7\u00e3o: Conjun\u00e7\u00e3o (E)</p> A B Y = A.B 0 0 0 0 1 0 1 0 0 1 1 1 <pre><code>      A      B               Y\n|----| |----| |-------------( )----|\n</code></pre> <p>Opera\u00e7\u00e3o: Disjun\u00e7\u00e3o (OU)</p> A B Y = A+B 0 0 0 0 1 1 1 0 1 1 1 1 <pre><code>      A                      Y\n|----| |--------------------( )----|\n            |\n      B     |\n|----| |----'\n</code></pre> <p>Associa\u00e7\u00e3o de opera\u00e7\u00f5es</p> <p>As associa\u00e7\u00f5es de opera\u00e7\u00f5es podem ser realizadas, como o j\u00e1 visto acionamento do motor.</p> <pre><code>     Ligar     Desligar                       Motor\n|-----| |--------|/|---------------------------( )----|\n           |\n     Motor |\n|-----| |--\u00b4\n</code></pre> <p>Este programa pode ser descrito na forma de express\u00e3o alg\u00e9brica da seguinte forma:</p> \\[ Motor = (Ligar + Motor).\\overline{ Desligar } \\] <p>Lembrando que o operador <code>OU</code> \u00e9 representado pelo s\u00edmbolo <code>+</code> e o operador <code>E</code> \u00e9 representado pelo s\u00edmbolo <code>.</code>.</p> <p>Exerc\u00edcios</p> <p>1. Como ficam os programas para as seguintes express\u00f5es?</p> <ol> <li>\\(Y_1 = A \\cdot \\overline{B} + \\overline{A} \\cdot B\\)</li> <li>\\(Y_2 = \\overline{A} \\cdot \\overline{B}+A \\cdot B\\)</li> <li>\\(Y_3 = \\overline{A \\cdot B}\\)</li> <li>\\(Y_4 = \\overline{A+B}\\)</li> </ol> <p>2. Elabore um programa que apresente o comportamento descrito pela seguinte tabela verdade:</p> <ul> <li>Vari\u00e1veis independentes (Entrada): C, B, A</li> <li>Vari\u00e1veis dependentes (Sa\u00edda): \\(S_1\\), \\(S_0\\)</li> </ul> C B A \\(S_1\\) \\(S_0\\) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1","tags":["CLP","Altus","TB131","Contatos","Bobinas"]},{"location":"automacao/clp/altus_tb131/lab03-setReset/","title":"Fun\u00e7\u00f5es SET e RESET","text":"<p>As fun\u00e7\u00f5es <code>SET</code> e <code>RESET</code> podem ser atribu\u00eddas \u00e0 uma bobina  de modo que ela precise apenas de um pulso para permanecer no estado de acionamento, 1 e 0, respectivamente. </p> <p></p> <p>Essas fun\u00e7\u00f5es operam de forma complementar, assim, ap\u00f3s ativar uma bobina com a fun\u00e7\u00e3o <code>SET</code> \u00e9 necess\u00e1rio um acionamento da mesma bobina com a fun\u00e7\u00e3o <code>RESET</code> para que ela retorne \u00e0 condi\u00e7\u00e3o normal desligada. </p> <p></p> <p>Em algumas situa\u00e7\u00f5es, seu uso facilita a constru\u00e7\u00e3o do programa, mas pode trazer erros l\u00f3gicos ao desenvolvimento da aplica\u00e7\u00e3o caso sejam utilizadas de modo inadequado. </p> <p>O seguinte trecho de c\u00f3digo: </p> <pre><code>     Ligar     Desligar                       Motor\n|-----| |--------|/|---------------------------( )----|\n           |\n     Motor |\n|-----| |--\u00b4\n</code></pre> <p>pode ser declarado da seguinte forma:</p> <pre><code>     Ligar                                     Motor\n|-----| |--------------------------------------( S )----|\n\n     Desligar                                  Motor\n|-----| |--------------------------------------( R )----|\n</code></pre> <p>Recomenda\u00e7\u00e3o: </p> <p>N\u00e3o usar no c\u00f3digo a bobina <code>Motor</code> mais do que uma vez para cada fun\u00e7\u00e3o. Ou seja, apenas um uso para o <code>SET</code> e apenas um uso para o <code>RESET</code>.</p>","tags":["CLP","Altus","TB131","Set","Reset"]},{"location":"automacao/clp/altus_tb131/lab04-borda_subida_descida/","title":"Detec\u00e7\u00e3o de Borda","text":"<p>1. Carta de tempos</p> <p></p> <p>2. Inserir bloco de detec\u00e7\u00e3o de borda</p> <p></p> <p>3. Simula\u00e7\u00e3o de detec\u00e7\u00e3o de borda</p> <p></p>","tags":["CLP","Altus","TB131","Detec\u00e7\u00e3o de borda"]},{"location":"automacao/clp/altus_tb131/lab05-temporizadores/","title":"Temporizadores","text":"","tags":["CLP","Altus","TB131","Temporizadores"]},{"location":"automacao/clp/altus_tb131/lab05-temporizadores/#1-ton-on-delay-timer","title":"1. TON - ON Delay Timer","text":"<p>Bloco funcional que produz uma atraso de acionamento da sa\u00edda em fun\u00e7\u00e3o do acionamento da entrada. </p> <p>A Figura 1 apresenta uma carta de tempos de funcionamento do TON.</p> <p>Nomenclatura:</p> <ul> <li>IN: Entrada digital;</li> <li>Q: Sa\u00edda digital;</li> <li>PT (Preset Time): Tempo de atraso;</li> <li> <p>ET (Elapsed Time): Tempo decorrido.</p> </li> <li> <p>Note que no instante <code>t0</code>, o sinal de entrada <code>IN</code> \u00e9 acionado. Com isso a vari\u00e1vel <code>ET</code> come\u00e7a a contar o tempo, at\u00e9 atingir o valor de <code>PT</code>. Quando isso ocorre, a sa\u00edda <code>Q</code> \u00e9 acionada. </p> </li> <li>Ao desligar a entrada <code>IN</code>, independente do tempo decorrido <code>ET</code>, a sa\u00edda tamb\u00e9m desliga. </li> </ul> Figura 1: Carta de tempos do TON Fonte: Master Tool IEC (Ajuda-&gt;Pesquisar...) <p>Exemplo</p> <p>Acionar um atuador, com atraso de 5 segundos em rela\u00e7\u00e3o ao acionamento de um sensor. </p> <p>Para realizar o acionamento conforme indicado, s\u00e3o necess\u00e1rias as declara\u00e7\u00f5es das vari\u00e1veis para o sensor, atuador e o temporizador.</p> <p>A declara\u00e7\u00e3o do sensor e do atuador, associados a um endere\u00e7o f\u00edsico j\u00e1 foi abordado. </p> <p>Para executar o bloco funcional TON, \u00e9 necess\u00e1ria a declara\u00e7\u00e3o de uma vari\u00e1vel do tipo <code>TON</code>, que aloca espa\u00e7o para o funcionamento adequando do bloco. </p> <p>Para visualizar o tempo decorrido enquanto ele avan\u00e7a, sugiro declarar uma vari\u00e1vel de apoio. Costumo utilizar o nome da declara\u00e7\u00e3o principal, acrescido das letras da porta que esta vari\u00e1vel vai receber o valor, assim, para o temporizador declarado como <code>T1</code>, o valor da sa\u00edda <code>ET</code> ser\u00e1 armazenado na vari\u00e1vel <code>T1et</code>, que deve ser do tipo <code>TIME</code>.</p> <p>Declara\u00e7\u00e3o de vari\u00e1veis</p> <pre><code>VAR\n    SENSOR  AT %IX0.1: BOOL;\n    ATUADOR AT %QX1.1: BOOL;\n\n    T1: TON;\n    T1et: TIME;\nEND_VAR\n</code></pre> <p>Programa LD (Ladder)</p> <ul> <li>Inserindo um bloco funcional de temporiza\u00e7\u00e3o: <ul> <li>Inserir \\( \\rightarrow \\) Bloco Funcional... (Ctrl+B)</li> <li>Blocos funcionais padr\u00e3o</li> <li><code>C:\\ ... \\STANDARD.LIB</code> \\( \\rightarrow \\) Timer \\( \\rightarrow \\) TON(FB)</li> </ul> </li> </ul> <pre><code>                 T1\n              ________\n    SENSOR   |   TON  |                          ATUADOR \n|----| |-----|IN     Q|----------------------------( )---|\n             |        |\n       T#5s -|PT    ET|- T1et\n             |________|\n</code></pre> <p>Programa ST (Structured Text)</p> <pre><code>T1( IN := SENSOR, PT := T#5s )\n\nT1et := T1.ET;\nATUADOR := T1.Q;\n</code></pre> <p>A Figura 2 apresenta um resumo da declara\u00e7\u00e3o e do uso do temporizador do tipo TON.</p> Figura 2: Declara\u00e7\u00e3o e exemplo de uso do TON Fonte: Autor","tags":["CLP","Altus","TB131","Temporizadores"]},{"location":"automacao/clp/altus_tb131/lab05-temporizadores/#2-tof-off-delay-timer","title":"2. TOF - OFF Delay Timer","text":"<p>Bloco funcional que produz uma atraso de desenergiza\u00e7\u00e3o da sa\u00edda em fun\u00e7\u00e3o do desligamento do sinal da entrada.</p> <p>A Figura 3 apresenta uma carta de tempos de funcionamento do TOF.</p> <p>Nomenclatura:</p> <ul> <li>IN: Entrada digital;</li> <li>Q: Sa\u00edda digital;</li> <li>PT (Preset Time): Tempo de atraso;</li> <li>ET (Elapsed Time): Tempo decorrido.</li> </ul> Figura 3: Carta de tempos do TOF Fonte: Master Tool IEC (Ajuda-&gt;Pesquisar...) <p>Exemplo</p> <p>Dado o acionamento de um sensor, ligar um atuador. Ao desacionar o sensor, produzir um atraso de 5 segundos e desligar o atuador.</p> <p>Para realizar o acionamento conforme indicado, s\u00e3o necess\u00e1rias as declara\u00e7\u00f5es das vari\u00e1veis para o sensor, atuador e o temporizador.</p> <p>A declara\u00e7\u00e3o do sensor e do atuador, associados a um endere\u00e7o f\u00edsico j\u00e1 foi abordado. </p> <p>Para este tipo de temporiza\u00e7\u00e3o, o bloco funcional TOF \u00e9 o mais adequado, necessitando a declara\u00e7\u00e3o de uma vari\u00e1vel do tipo <code>TOF</code>. </p> <p>Para visualizar o tempo decorrido da temporiza\u00e7\u00e3o, assim como com o <code>TON</code>, sugiro declarar uma vari\u00e1vel de apoio. Costumo utilizar o nome da declara\u00e7\u00e3o principal, acrescido das letras da porta que esta vari\u00e1vel vai receber o valor, assim, para o temporizador declarado como <code>T2</code>, o valor da sa\u00edda <code>ET</code> ser\u00e1 armazenado na vari\u00e1vel <code>T2et</code>, que deve ser do tipo <code>TIME</code>.</p> <p>Declara\u00e7\u00e3o de vari\u00e1veis</p> <pre><code>VAR\n    SENSOR  AT %IX0.1: BOOL;\n    ATUADOR AT %QX1.1: BOOL;\n\n    T2: TOF;\n    T2et: TIME;\nEND_VAR\n</code></pre> <p>Programa LD (Ladder)</p> <ul> <li>Inserindo um bloco funcional de temporiza\u00e7\u00e3o: <ul> <li>Inserir \\( \\rightarrow \\) Bloco Funcional... (Ctrl+B)</li> <li>Blocos funcionais padr\u00e3o</li> <li><code>C:\\ ... \\STANDARD.LIB</code> \\( \\rightarrow \\) Timer \\( \\rightarrow \\) TOF(FB)</li> </ul> </li> </ul> <pre><code>                 T2\n              ________\n    SENSOR   |   TOF  |                          ATUADOR \n|----| |-----|IN     Q|----------------------------( )---|\n             |        |\n       T#5s -|PT    ET|- T2et\n             |________|\n</code></pre> <p>Programa ST (Structured Text)</p> <pre><code>T2( IN := SENSOR, PT := T#5s )\n\nT2et := T2.ET;\nATUADOR := T2.Q;\n</code></pre>","tags":["CLP","Altus","TB131","Temporizadores"]},{"location":"automacao/clp/altus_tb131/lab05-temporizadores/#3-tp-pulse-timer","title":"3. TP - Pulse Timer","text":"<p>Bloco funcional que produz um acionamento temporizado, mediante uma borda de subida como est\u00edmulo de acionamento em sua entrada.</p> <p>A Figura 4 apresenta uma carta de tempos de funcionamento do TP.</p> <p>Nomenclatura:</p> <ul> <li>IN: Entrada digital;</li> <li>Q: Sa\u00edda digital;</li> <li>PT (Preset Time): Tempo de atraso;</li> <li>ET (Elapsed Time): Tempo decorrido.</li> </ul> Figura 4: Carta de tempos do TP Fonte: Master Tool IEC (Ajuda-&gt;Pesquisar...) <p>Exemplo</p> <p>Dada uma borda de subida em um sensor, ligar um atuador por um tempo de 5 segundos e ao final da temporiza\u00e7\u00e3o, deslig\u00e1-lo.</p> <p>Para realizar o acionamento conforme indicado, s\u00e3o necess\u00e1rias as declara\u00e7\u00f5es das vari\u00e1veis para o sensor, atuador e o temporizador.</p> <p>A declara\u00e7\u00e3o do sensor e do atuador, associados a um endere\u00e7o f\u00edsico j\u00e1 foi abordado. </p> <p>Para este tipo de temporiza\u00e7\u00e3o, o bloco funcional TP \u00e9 o mais adequado, necessitando a declara\u00e7\u00e3o de uma vari\u00e1vel do tipo <code>TP</code>. </p> <p>Para visualizar o tempo decorrido da temporiza\u00e7\u00e3o, assim como com o <code>TON</code> e o <code>TOF</code>, sugiro declarar uma vari\u00e1vel de apoio. Costumo utilizar o nome da declara\u00e7\u00e3o principal, acrescido das letras da porta que esta vari\u00e1vel vai receber o valor, assim, para o temporizador declarado como <code>T3</code>, o valor da sa\u00edda <code>ET</code> ser\u00e1 armazenado na vari\u00e1vel <code>T3et</code>, que deve ser do tipo <code>TIME</code>.</p> <p>Declara\u00e7\u00e3o de vari\u00e1veis</p> <pre><code>VAR\n    SENSOR  AT %IX0.1: BOOL;\n    ATUADOR AT %QX1.1: BOOL;\n\n    T3: TP;\n    T3et: TIME;\nEND_VAR\n</code></pre> <p>Programa LD (Ladder)</p> <ul> <li>Inserindo um bloco funcional de temporiza\u00e7\u00e3o: <ul> <li>Inserir \\( \\rightarrow \\) Bloco Funcional... (Ctrl+B)</li> <li>Blocos funcionais padr\u00e3o</li> <li><code>C:\\ ... \\STANDARD.LIB</code> \\( \\rightarrow \\) Timer \\( \\rightarrow \\) TP(FB)</li> </ul> </li> </ul> <pre><code>                 T3\n              ________\n    SENSOR   |   TP   |                          ATUADOR \n|----| |-----|IN     Q|----------------------------( )---|\n             |        |\n       T#5s -|PT    ET|- T3et\n             |________|\n</code></pre> <p>Programa ST (Structured Text)</p> <pre><code>T3( IN := SENSOR, PT := T#5s )\n\nT3et := T3.ET;\nATUADOR := T3.Q;\n</code></pre>","tags":["CLP","Altus","TB131","Temporizadores"]},{"location":"automacao/clp/altus_tb131/lab06-contadores/","title":"Contadores","text":"","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab06-contadores/#counter-up-ctu","title":"Counter UP - CTU","text":"<p>Bloco funcional de contagem incremental e apresenta o seguinte formato:</p> <pre><code>            CTU_instancia\n              _________\n             |   CTU   | \n            -|CU      Q|-\n            -|RESET    |\n            -|PV     CV|-\n             |_________|\n</code></pre> <p>Sendo:</p> <ul> <li><code>CU</code>: Entrada do tipo <code>Bool</code>. Incrementa a contagem ao detectar uma borda de subida;</li> <li><code>RESET</code>: Entrada do tipo <code>Bool</code>. Quando estiver o valor <code>True</code>, ou seja, estiver acionada, inicializa o contador com o valor <code>0</code>;</li> <li><code>PV</code>: Entrada do tipo <code>Word</code>. Valor limite superior de contagem;</li> <li><code>Q</code>: Sa\u00edda do tipo <code>Bool</code>. \u00c9 acionada quando a contagem \u00e9 igual ou superior ao valor de <code>PV</code>;</li> <li><code>CV</code>: Sa\u00edda do tipo <code>Word</code>. Valor de contagem. </li> </ul> <p>Para exemplificar o contador crescente, vamos declarar um <code>sensor</code> para servir de gatilho ao incremento, um <code>atuador</code> para ser acionado ao final da contagem e uma entrada <code>RST</code> para reiniciar o contatdor. </p> <p><code>C1</code> \u00e9 a inst\u00e2ncia do tipo <code>CTU</code>, ou seja, o objetivo ou a estrutura de mem\u00f3ria que armazena todos os registradores envolvidos na contagem. J\u00e1 a vari\u00e1vel <code>C1cv</code> foi declarada para receber o valor de contagem. </p> <pre><code>VAR\n    SENSOR  AT %IX0.1: BOOL;\n    RST     AT %IX0.0: BOOL;\n    ATUADOR AT %QX1.1: BOOL;\n\n\n    C1: CTU;\n    C1cv: WORD;\nEND_VAR\n</code></pre> <p>O bloco funcional de contagem pertence \u00e0 biblioteca <code>standard.lib</code> e pode ser inserido em um programa em linguagem <code>LD (Ladder)</code> da seguinte forma:</p> <ul> <li>Inserindo um bloco funcional CTU: <ul> <li>Inserir \\( \\rightarrow \\) Bloco Funcional... (Ctrl+B)</li> <li>Blocos funcionais padr\u00e3o</li> <li><code>C:\\ ... \\STANDARD.LIB</code> \\( \\rightarrow \\) Counter \\( \\rightarrow \\) CTU(FB)</li> </ul> </li> </ul> Figura 1: Inserindo bloco funcional CTU Fonte: Autor <p>Programa em LD (Ladder)</p> <pre><code>                 C1\n              _________\n    SENSOR   |   CTU   |                          ATUADOR \n|----| |-----|CU      Q|----------------------------( )---|\n        RST -|RESET    |\n         10 -|PV     CV|- C1cv\n             |_________|\n</code></pre> <p>Programa ST (Structured Text)</p> <pre><code>C1( CU := SENSOR, RESET := RST, PV := 10 );\n\nT1et := C1.CV;\nATUADOR := C1.Q;\n</code></pre>","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab07-blocos_funcionais/","title":"Blocos Funcionais","text":"","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab07-blocos_funcionais/#comparacao","title":"Compara\u00e7\u00e3o","text":"<ul> <li>EQ: EQUAL - IGUAL</li> <li>NE: NOT EQUAL - DIFERENTE</li> <li>LT - LESS THAN - MENOR QUE</li> <li>LE - LESS OR EQUAL - MENOR OU IGUAL</li> <li>GT - GREATER THAN - MAIOR QUE</li> <li>GE - GREATER OR EQUAL - MAIOR OU IGUAL</li> </ul> <p>Tipos de dados suportados para as compara\u00e7\u00f5es</p> <pre><code>                         ________\n                        |  COMP  |\n|-----------------------|EN      |\n                        |        |----- Resultado\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>Os blocos de compara\u00e7\u00e3o possuem tr\u00eas entradas e uma sa\u00edda, sendo elas:</p> <ul> <li>EN: Entrada do tipo <code>bool</code>, que tem como fun\u00e7\u00e3o habilitar a compara\u00e7\u00e3o;</li> <li>Resultado: Sa\u00edda do tipo <code>bool</code>, que expressa o resultado da opera\u00e7\u00e3o de compara\u00e7\u00e3o entre as duas entradas <code>Valor_A</code> e <code>Valor_B</code>;</li> <li>Valor_A e Valor_B: Valores de compara\u00e7\u00e3o. Podem ser de v\u00e1rios tipos: BOOL, BYTE, WORD, DWORD, SINT, USINT, INT, UINT, DINT, UDINT, REAL, LREAL, TIME, DATE, TIME_OF_DAY, DATE_AND_TIME e STRING.</li> </ul> <p>Podemos representar o comportamento do bloco COMP da seguinte forma: </p> <p><pre><code>IF EN == True THEN\n    Resultado = Valor_A COMP Valor_B\nEND_IF;\n</code></pre> O bloco <code>COMP</code> representa uma das opera\u00e7\u00f5es l\u00f3gicas de compara\u00e7\u00e3o.</p> <p>1. Fun\u00e7\u00e3o EQ - EQUAL - IGUAL</p> <pre><code>                         ________\n                        |   EQ   |\n|-----------------------|EN      |\n                        |        |----- Igual\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>2. Fun\u00e7\u00e3o NE - NOT EQUAL - DIFERENTE</p> <pre><code>                         ________\n                        |   NE   |\n|-----------------------|EN      |\n                        |        |----- Diferente\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>3. Fun\u00e7\u00e3o LT - LESS THAN - MENOR QUE</p> <pre><code>                         ________\n                        |   LT   |\n|-----------------------|EN      |\n                        |        |----- Menor_Que\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>4. Fun\u00e7\u00e3o LE - LESS OR EQUAL - MENOR OU IGUAL</p> <pre><code>                         ________\n                        |   EQ   |\n|-----------------------|EN      |\n                        |        |----- Menor_ou_Igual\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>5. Fun\u00e7\u00e3o GT - GREATER THAN - MAIOR QUE</p> <pre><code>                         ________\n                        |   GT   |\n|-----------------------|EN      |\n                        |        |----- Maior_Que\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>6. Fun\u00e7\u00e3o GE - GREATER OR EQUAL - MAIOR OU IGUAL</p> <pre><code>                         ________\n                        |   GE   |\n|-----------------------|EN      |\n                        |        |----- Maior_ou_Igual\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre>","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab07-blocos_funcionais/#aritmeticos","title":"Aritm\u00e9ticos","text":"<ul> <li>ADD: Adi\u00e7\u00e3o</li> <li>SUB: Subtra\u00e7\u00e3o</li> <li>ADD/SUB TIME: Adi\u00e7\u00e3o e Subtra\u00e7\u00e3o de tempo</li> <li>MUL: Multiplica\u00e7\u00e3o</li> <li>DIV: Divis\u00e3o</li> <li>MOD: M\u00f3dulo - Resto da Divis\u00e3o</li> </ul> <p>Tipos de dados suportados para as opera\u00e7\u00f5es aritm\u00e9ticas</p> <p>Os tipos de dados suportados pelas entradas <code>Valor_A</code> e <code>Valor_B</code> s\u00e3o: BYTE, WORD, DWORD, SINT, USINT, INT, UINT, DINT, UDINT, REAL e LREAL;</p> <pre><code>                         ________\n                        |OPERACAO|\n|-----------------------|EN      |\n                        |        |----- Resultado\n            Valor_A ----|        |\n            Valor_B ----|________|\n</code></pre> <p>As entradas <code>Valor_A</code> e <code>Valor_B</code> devem ser do mesmo tipo, que \u00e9 o tipo do <code>Resultado</code>.</p> <p>O bloco <code>OPERACAO</code> representa uma das opera\u00e7\u00f5es aritm\u00e9ticas. </p> <p>1. Fun\u00e7\u00e3o ADD - Adi\u00e7\u00e3o</p> <pre><code>                         _________\n                        |   ADD   |\n|-----------------------|EN       |\n                        |         |----- SOMA\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre> <p>2. Fun\u00e7\u00e3o SUB - Subtra\u00e7\u00e3o</p> <pre><code>                         _________\n                        |   SUB   |\n|-----------------------|EN       |\n                        |         |----- SUBTRACAO\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre> <p>3. Fun\u00e7\u00e3o ADD/SUB TIME - Adi\u00e7\u00e3o e Subtra\u00e7\u00e3o de tempo</p> <pre><code>                         _________\n                        | ADD/SUB |\n|-----------------------|EN       |\n                        |         |----- ADD_SUB_TIME\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre> <p>O tipo de dado aqui suportado \u00e9 apenas o tipo <code>TIME</code>.</p> <p>Ex: T#45s + T#50s = T#1m35s</p> <p>4. Fun\u00e7\u00e3o MUL - Multiplica\u00e7\u00e3o</p> <pre><code>                         _________\n                        |   MUL   |\n|-----------------------|EN       |\n                        |         |----- MULTIPLICACAO\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre> <p>5. Fun\u00e7\u00e3o DIV - Divis\u00e3o</p> <pre><code>                         _________\n                        |   DIV   |\n|-----------------------|EN       |\n                        |         |----- DIVISAO\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre> <p>Fun\u00e7\u00f5es <code>DIV</code> com os seguintes nomes: <code>CheckDivByte</code>, <code>CheckDivWord</code>, <code>CheckDivDWord</code> e <code>CheckDivReal</code> realizam o teste no divisor para evitar divis\u00e3o por zero.</p> <p>6. Fun\u00e7\u00e3o MOD - M\u00f3dulo - Resto da Divis\u00e3o</p> <pre><code>                         _________\n                        |   MOD   |\n|-----------------------|EN       |\n                        |         |----- RESTO\n            Valor_A ----|         |\n            Valor_B ----|_________|\n</code></pre>","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab07-blocos_funcionais/#selecao","title":"Sele\u00e7\u00e3o","text":"<ul> <li>MOVE: Mover</li> <li>MIN: Menor valor</li> <li>MAX: Maior valor</li> <li>LIMIT: Limitadores</li> <li>SEL: Sele\u00e7\u00e3o</li> <li>MUX: Multiplexa\u00e7\u00e3o</li> </ul> <p>1. Fun\u00e7\u00e3o MOVE - Mover</p> <pre><code>                         ________\n                        |  MOVE  |\n|-----------------------|EN      |\n                        |        |----- DESTINO\n              VALOR ----|        |\n                        |________|\n</code></pre> <p>2. Fun\u00e7\u00e3o MIN - Menor valor</p> <pre><code>                         ________\n                        |   MIN  |\n|-----------------------|EN      |\n                        |        |----- MENOR_VALOR\n            VALOR_A ----|        |\n            VALOR_B ----|________|\n</code></pre> <p>3. Fun\u00e7\u00e3o MAX - Maior valor</p> <pre><code>                         ________\n                        |   MAX  |\n|-----------------------|EN      |\n                        |        |----- MAIOR_VALOR\n            VALOR_A ----|        |\n            VALOR_B ----|________|\n</code></pre> <p>4. Fun\u00e7\u00e3o LIMIT - Limitadores</p> <pre><code>                         _________\n                        |  LIMIT  |\n|-----------------------|EN       |\n            VALOR_MIN --|         |\n     VALOR_DE_ENTRADA --|         |----- VALOR_LIMITADO\n            VALOR_MAX --|_________|\n</code></pre> <p>5. Fun\u00e7\u00e3o SEL - Sele\u00e7\u00e3o</p> <pre><code>                         _________\n                        |   SEL   |\n|-----------------------|EN       |\n              SELECAO --|         |\n            ENTRADA_0 --|         |----- VALOR_SELECIONADO\n            ENTRADA_1 --|_________|\n</code></pre> <p>6. Fun\u00e7\u00e3o MUX - Multiplexa\u00e7\u00e3o</p> <pre><code>                         _________\n                        |   MUX   |\n|-----------------------|EN       |\n              SELECAO --|         |\n            ENTRADA_0 --|         |----- VALOR_MULTIPLEXADO\n            ENTRADA_1 --|_________|\n</code></pre>","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab07-blocos_funcionais/#inserir-bloco-funcional","title":"Inserir Bloco Funcional","text":"","tags":["CLP","Altus","TB131","Contadores"]},{"location":"automacao/clp/altus_tb131/lab08-entradas_saidas_analogicas/","title":"Entradas e Sa\u00eddas Anal\u00f3gicas","text":"<p>Habilita\u00e7\u00e3o de Entradas Anal\u00f3gicas</p> <p></p> <p>Habilita\u00e7\u00e3o de Sa\u00eddas Anal\u00f3gicas</p> <p></p>","tags":["CLP","Altus","TB131","Entradas Anal\u00f3gicas","Sa\u00eddas Anal\u00f3gicas"]},{"location":"automacao/clp/altus_tb131/lab09-bloco_funcional/","title":"Criando um Bloco Funcional - Function Block","text":"<p>1. Criando um Bloco Funcional</p> <p></p> <p>2. Declara\u00e7\u00e3o de Bloco Funcional</p> <p></p> <p>3. Inserindo o Bloco Funcional no programa principal</p> <p></p> <p>4. Bloco Funcional no programa principal</p> <p></p>","tags":["CLP","Altus","TB131","Bloco Funcional"]},{"location":"automacao/clp/altus_tb131/lab10-funcao/","title":"Criando uma Fun\u00e7\u00e3o","text":"<p>1. Criando uma Fun\u00e7\u00e3o</p> <p></p> <p>2. Declara\u00e7\u00e3o de Fun\u00e7\u00e3o <code>N_QUADRADO</code></p> <p></p> <p>3. Inserindo a Fun\u00e7\u00e3o <code>N_QUADRADO</code> no programa principal</p> <p></p>","tags":["CLP","Altus","TB131","Fun\u00e7\u00e3o"]},{"location":"automacao/clp/tecnologia/01-fundamentos/","title":"Controladores L\u00f3gicos Program\u00e1veis","text":"<p>Os Controladores L\u00f3gicos Program\u00e1veis (CLPs) s\u00e3o definidos como computadores industriais projetados para controlar m\u00e1quinas e processos, tendo evolu\u00eddo originalmente como substitutos para sistemas de controle baseados em rel\u00e9s. Diferente de um computador pessoal, o CLP \u00e9 constru\u00eddo para operar em ambientes industriais severos, suportando varia\u00e7\u00f5es de temperatura, umidade e ru\u00eddos el\u00e9tricos.</p> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#1-arquitetura-e-componentes-de-hardware","title":"1. Arquitetura e Componentes de Hardware","text":"<p>Um sistema de CLP padr\u00e3o consiste em quatro partes essenciais:</p> <ul> <li> <p>Unidade Central de Processamento (CPU): Composto por um microprocessador que executa a l\u00f3gica do programa, gerencia a mem\u00f3ria e controla a comunica\u00e7\u00e3o entre os m\u00f3dulos.</p> </li> <li> <p>Se\u00e7\u00e3o de Entrada/Sa\u00edda (E/S): Forma a interface com os dispositivos de campo. As entradas recebem sinais de sensores e bot\u00f5es, enquanto as sa\u00eddas acionam atuadores como motores e v\u00e1lvulas. Existem dois tipos principais de configura\u00e7\u00f5es: </p> <ul> <li>fixas: t\u00edpicas de CLPs pequenos, onde CPU e E/S est\u00e3o no mesmo gabinete; </li> <li>modulares:que utilizam um rack ou chassi para conectar diversos m\u00f3dulos.</li> </ul> </li> <li> <p>Fonte de Alimenta\u00e7\u00e3o: Fornece a tens\u00e3o e corrente cont\u00ednua (CC) necess\u00e1ria para o funcionamento interno dos m\u00f3dulos do CLP.</p> </li> <li> <p>Dispositivo de Programa\u00e7\u00e3o: Geralmente um computador pessoal (PC) com software espec\u00edfico, utilizado para redigir a l\u00f3gica e transferi-la para a mem\u00f3ria do processador.</p> </li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#2-principio-de-funcionamento-ciclo-de-varredura","title":"2. Princ\u00edpio de Funcionamento (Ciclo de Varredura)","text":"<p>O CLP opera como um sistema de tempo real atrav\u00e9s de um processo repetitivo chamado varredura ou scan. Este ciclo consiste em tr\u00eas etapas principais:</p> <ol> <li> <p>Leitura das Entradas: O processador examina o estado (ligado/desligado ou valor anal\u00f3gico) de cada dispositivo de entrada e grava esses dados em sua mem\u00f3ria.</p> </li> <li> <p>Execu\u00e7\u00e3o do Programa: A CPU executa as instru\u00e7\u00f5es da l\u00f3gica ladder, degrau por degrau, utilizando os estados das entradas armazenados.</p> </li> <li> <p>Atualiza\u00e7\u00e3o das Sa\u00eddas: Com base nos resultados da l\u00f3gica, o processador atualiza os dispositivos de sa\u00edda f\u00edsicos.</p> </li> </ol> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#3-fundamentos-de-programacao-e-linguagem-ladder","title":"3. Fundamentos de Programa\u00e7\u00e3o e Linguagem Ladder","text":"<p>A linguagem de programa\u00e7\u00e3o mais popular para CLPs \u00e9 a Ladder (LD), que utiliza s\u00edmbolos gr\u00e1ficos semelhantes aos diagramas de contatos el\u00e9tricos, por\u00e9m existem outras linguagens de programa\u00e7\u00e3o para CLP, como Structured Text (ST), Instruction List (IL), Function Block Diagram (FBD), e Sequential Function Chart (SFC), que foram padronizadas pela IEC 61131-3, de modo a padronizar e facilitar a integra\u00e7\u00e3o de diferentes sistemas de controle.</p> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#4-tipos-de-sinais","title":"4. Tipos de Sinais","text":"<ul> <li> <p>Sinais Digitais (ou Discretos): Possuem apenas dois estados, como ligado/desligado ou 0/1. Exemplos comuns incluem bot\u00f5es de press\u00e3o e chaves-limite.</p> </li> <li> <p>Sinais Anal\u00f3gicos: Representam grandezas f\u00edsicas que variam continuamente em uma escala, como temperatura e press\u00e3o. Operam geralmente em faixas de 0 a 10 V ou 4 a 20 mA.</p> </li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#5-vantagens-do-uso-de-clps","title":"5. Vantagens do Uso de CLPs","text":"<p>A substitui\u00e7\u00e3o da l\u00f3gica de rel\u00e9s por CLPs oferece benef\u00edcios significativos:</p> <ul> <li>maior flexibilidade: as mudan\u00e7as s\u00e3o feitas via software;</li> <li>confiabilidade elevada: componentes de estado s\u00f3lido sem partes m\u00f3veis;</li> <li>facilidade na verifica\u00e7\u00e3o de defeitos atrav\u00e9s do monitoramento em tempo real;</li> <li>redu\u00e7\u00e3o de custos.</li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#6-contexto-historico","title":"6. Contexto Hist\u00f3rico","text":"<p>O final da d\u00e9cada de 60 proporcionaram para o desenvolvimento tecnol\u00f3gico industrial um marco de extrema import\u00e2ncia para o grande desenvolvimento da automa\u00e7\u00e3o no ch\u00e3o de f\u00e1brica, o nascimento do primeiro controlador program\u00e1vel.</p> <p>A General Motors, j\u00e1 uma grande montadora de ve\u00edculos automotores, lan\u00e7ou um desafio t\u00e9cnico, que refletia um grande inconveniente para a produ\u00e7\u00e3o, que precisava ser expandida, mas que possuia um gargalo tecnol\u00f3gico no setup da linha de produ\u00e7\u00e3o.</p> Figura 1: General Motors - Linha de montagem <p>Para a altera\u00e7\u00e3o de um modelo de fabrica\u00e7\u00e3o na linha de montagem, era necess\u00e1rio redesenhar todo o processo, remontando os paineis de acionamento e dispositivos, devido a altera\u00e7\u00e3o da l\u00f3gica de acionamento, que era completamente realizada por circuitos a rele.</p> Figura 2: Paineis montados com l\u00f3gica de contatos - Reles <p>Todo este processo demandava muito tempo, o que impedia a produ\u00e7\u00e3o de ser executada em toda troca de modelo de produ\u00e7\u00e3o, implicando em altos gastos de tempo e dinheiro.</p> <p>Assim, a Hydronic Division da GM, em 1968, prop\u00f4s que gostaria de um dispositivo com as seguintes caracter\u00edsticas:</p> <ol> <li>Facilidade de programa\u00e7\u00e3o e reprograma\u00e7\u00e3o, linguagem de contatos;</li> <li>Possibilidade de manuten\u00e7\u00e3o e reparo, blocos de entradas e sa\u00eddas modulares;</li> <li>Confiabilidade, para ser utilizado em ambiente industrial;</li> <li>Redu\u00e7\u00e3o de tamanho;</li> <li>Custo competitivo.</li> </ol> <p>No ano seguinte, a Bedford Associate cumpriu o desafio com o seu Modular Digital Controller (MODICON 084), projeto este liderado pelo engenheiro Richard E. Morley (01/12/1932 \u201317/10/2017), entrando para a hist\u00f3ria pelo desenvolvimento de um dos mais importantes equipamentos tecnol\u00f3gicos da todos os tempos, revolucionando a ind\u00fastria e impulsionando de forma in\u00e9dita a automa\u00e7\u00e3o industrial.</p> Figura 3: Modular Digital Controller - MODICON 084 <p>O Controlador Digital e Modular</p> <p>O objetivo do MODICON 084 e de sua linhagem, at\u00e9 os dias atuais \u00e9, controlar m\u00e1quinas ou processos por meio da leitura de sinais de entrada (como chaves ou sensores) e decidir, por meio de instru\u00e7\u00f5es pr\u00e9-programadas, as a\u00e7\u00f5es a serem realizadas no acionamento de contatores, v\u00e1lvulas, motores e demais cargas.</p> Figura 4: Controlador Digital e Modular <p>Desta forma, \u00e9 poss\u00edvel substituir todo o volume de reles respons\u00e1veis por realizar as l\u00f3gicas de acionamento de forma f\u00edsica, por opera\u00e7\u00f5es l\u00f3gicas processadas pelo controlador, sobrando apenas a interface simples entre os dispositivos de entrada de dados, inicialmente, de l\u00f3gica booleana, como sensores, chaves, fins de curso, e dispositivos de sa\u00edda, como contatores, v\u00e1lvulas e sinaleiros.</p> Figura 5: Diagrama el\u00e9trico de comando e com o controlador digital modular <p>Assim, para mudan\u00e7as l\u00f3gicas, no comportamento de um equipamento ou sistema sem mudar sua interface, n\u00e3o \u00e9 necess\u00e1rio remontar todo o painel de comandos, apenas alterar o programa que est\u00e1 na mem\u00f3ria do controlador que o comportamento do sistema muda.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#7-a-norma","title":"7. A Norma","text":"<p>Existem v\u00e1rias defini\u00e7\u00f5es para o Controlador L\u00f3gico Program\u00e1vel (CLP), que convergem, mas com graus de profundidades diferentes, entre Associa\u00e7\u00e3o Brasileira de Normas T\u00e9cnicas (ABNT), National Electrical Manufacturers Association (NEMA) e a International Electrotechnical Commission (IEC). Apresento aqui a defini\u00e7\u00e3o desta \u00faltima:</p> <p>\u201cSistema eletr\u00f4nico operando digitalmente, projetado para uso em um ambiente industrial, que usa uma mem\u00f3ria program\u00e1vel para a armazenagem interna de instru\u00e7\u00f5es orientadas para o usu\u00e1rio para implementar fun\u00e7\u00f5es espec\u00edficas, tais como l\u00f3gica, sequencial, temporiza\u00e7\u00e3o, contagem e aritm\u00e9tica, para controlar, atrav\u00e9s de entradas e sa\u00eddas digitais ou anal\u00f3gicas, v\u00e1rios tipos de m\u00e1quinas ou processos. O controlador program\u00e1vel e seus perif\u00e9ricos associados s\u00e3o projetados para serem facilmente integr\u00e1veis em um sistema de controle industrial e facilmente usados em todas suas fun\u00e7\u00f5es previstas.\u201d</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#8-fabricantes-e-o-mercado","title":"8. Fabricantes e o Mercado","text":"<p>CLP \u00e9 marca registrada da Rockwell Automation, assim \u00e9 comum, mesmo em portugu\u00eas, o uso da sigla PLC de Programmable Logic Controller ou de forma mais gen\u00e9rica a denomina\u00e7\u00e3o Controlador Program\u00e1vel.</p> Figura 8: Principais fabricantes de CLP Figura 9: Mercado de CLP Fonte: Where Siemens, Emerson, Rockwell Automation, ABB, and Schneider Electric place emphasis - Carlos Unda - LinkedIn","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#9-iec-61131","title":"9. IEC-61131","text":"<p>Para que equipamentos industriais de automa\u00e7\u00e3o sejam facilmente integr\u00e1veis como pressup\u00f5e a norma, foram criados grupos de trabalho da IEC para avaliar e padronizar o projeto de CLPs em v\u00e1rios aspectos, tais como:</p> <ul> <li>Hardware;</li> <li>Forma de instala\u00e7\u00e3o;</li> <li>Procedimento de testes;</li> <li>Documenta\u00e7\u00e3o;</li> <li>Formas de programa\u00e7\u00e3o e comunica\u00e7\u00e3o.</li> </ul> <p>Assim foi desenvolvida a norma IEC 61131 e suas v\u00e1rias se\u00e7\u00f5es:</p> <ul> <li>IEC 61131-1: Informa\u00e7\u00f5es gerais. Nomenclaturas e conceitos.</li> <li>IEC 61131-2: Requisitos de Equipamentos e Testes. Parte eletr\u00f4nica e mec\u00e2nica;</li> <li>IEC 61131-3: Linguagens de Programa\u00e7\u00e3o. Linguagens e forma de execu\u00e7\u00e3o de programas;</li> <li>IEC 61131-4: Diretrizes de usu\u00e1rio. Instala\u00e7\u00e3o, manuten\u00e7\u00e3o etc;</li> <li>IEC 61131-5: Comunica\u00e7\u00e3o. Fun\u00e7\u00f5es de comunica\u00e7\u00f5es com outros equipamentos;</li> <li>IEC 61131-6: Reservada;</li> <li>IEC 61131-7: Reservada para L\u00f3gica Fuzzy (Ferramenta Computacional);</li> <li>IEC 61131-8: Orienta\u00e7\u00f5es para as formas de simplementa\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o.</li> </ul> Figura 10: Linguagens definidas pela Norma IEC 61131-3","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#10-material-complementar","title":"10. Material Complementar","text":"<ol> <li>Modicon: 50 anos de Pioneirismo e Inova\u00e7\u00f5es - Blog Schneider Electric</li> <li>A hist\u00f3ria dos controladores program\u00e1veis - Altus</li> <li>Curiosidades sobre os CLPs ou\u00a0PLC - O Professor Leandro</li> <li>The Modicon 084 PLC Literally Changed the World - Kalil4.0</li> <li>Who is the Father of the PLC ? - RealPairs</li> <li>Programable Logic Controller Basics Explained - automation engineering - The Engineering Mindset</li> </ol>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/01-fundamentos/#referencias","title":"Refer\u00eancias","text":"<ol> <li>PETRUZELLA, Frank D. Controladores L\u00f3gicos Program\u00e1veis. Tradu\u00e7\u00e3o de Romeu Abdo; revis\u00e3o t\u00e9cnica de Antonio Pertence J\u00fanior. 4. ed. Porto Alegre: AMGH, 2014.</li> <li>GEORGINI, Marcelo. Automa\u00e7\u00e3o Aplicada: Descri\u00e7\u00e3o e Implementa\u00e7\u00e3o de Sistemas Sequenciais com PLCs. 9. ed. S\u00e3o Paulo: \u00c9rica, 2007.</li> <li>SILVA FILHO, Bernardo Severo da. Curso de Controladores L\u00f3gicos Program\u00e1veis. Rio de Janeiro: UERJ, Faculdade de Engenharia, Laborat\u00f3rio de Engenharia El\u00e9trica, [s.d.].</li> <li>MITSUBISHI ELECTRIC BRASIL. CLP: O que \u00e9, para que serve e como funciona na ind\u00fastria. [s.l.]: YouTube, [s.d.]. 1 v\u00eddeo.</li> <li>ALTUS. O que \u00e9 CLP e quando utiliz\u00e1-lo?. S\u00e3o Leopoldo: Altus, [s.d.]. Dispon\u00edvel em: Blog da Altus.</li> </ol>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/02-interfaces/","title":"Interfaces de Entrada e Sa\u00edda","text":"<p>As interfaces de entrada e sa\u00edda (E/S) de um CLP, representam o local onde os dispositivos de campo s\u00e3o conectados, servindo como o v\u00ednculo f\u00edsico e de comunica\u00e7\u00e3o entre esses dispositivos e a Unidade Central de Processamento (CPU). A fun\u00e7\u00e3o primordial dessas interfaces \u00e9 condicionar os v\u00e1rios sinais recebidos ou enviados aos dispositivos externos, garantindo que a comunica\u00e7\u00e3o entre o mundo f\u00edsico e o processador ocorra de forma eficiente.</p> <p>As fun\u00e7\u00f5es podem ser detalhadas da seguinte maneira:</p> <ul> <li>Interface de Entrada: Recebe sinais dos dispositivos de processo (como sensores e bot\u00f5es) e os converte em sinais digitais que podem ser utilizados pelo processador.</li> </ul> <p></p> <ul> <li>Interface de Sa\u00edda: Recebe os dados digitais resultantes da l\u00f3gica do programa e os converte em sinais el\u00e9tricos externos para acionar atuadores (como motores, v\u00e1lvulas e sinaleiros).</li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/02-interfaces/#configuracoes-fisicas","title":"Configura\u00e7\u00f5es F\u00edsicas","text":"<p>Existem dois modos principais de incorporar essas interfaces ao CLP:</p> <ol> <li> <p>E/S Fixa: Comum em CLPs de pequeno porte, onde o processador e os terminais de entrada e sa\u00edda s\u00e3o incorporados em uma \u00fanica unidade n\u00e3o remov\u00edvel. Embora tenha menor custo, sua flexibilidade \u00e9 limitada, pois o n\u00famero de conex\u00f5es \u00e9 fixado pelo fabricante.</p> </li> <li> <p>E/S Modular: Utiliza um rack ou chassi com compartimentos (slots) onde os m\u00f3dulos de E/S podem ser plugados individualmente. Isso oferece grande flexibilidade, permitindo misturar diferentes tipos de m\u00f3dulos conforme a necessidade da aplica\u00e7\u00e3o.</p> </li> </ol> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/02-interfaces/#tipos-de-sinais-e-processamento","title":"Tipos de Sinais e Processamento","text":"<p>As interfaces s\u00e3o divididas conforme a natureza do sinal que processam:</p> <ul> <li> <p>Interfaces Discretas (Digitais): Lidam com dispositivos de natureza LIGA/DESLIGA, onde cada bit na mem\u00f3ria representa um estado completo (como uma chave aberta ou fechada).</p> </li> <li> <p>Interfaces Anal\u00f3gicas: Monitoram grandezas f\u00edsicas que variam continuamente, como temperatura e press\u00e3o. Elas utilizam um conversor anal\u00f3gico-digital (A/D) para traduzir o sinal do campo para o processador e um conversor digital-anal\u00f3gico (D/A) para enviar comandos proporcionais aos atuadores.</p> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/02-interfaces/#protecao-e-seguranca","title":"Prote\u00e7\u00e3o e Seguran\u00e7a","text":"<p>Para garantir a integridade do sistema, os CLPs utilizam isoladores \u00f3pticos nas interfaces de E/S. Esses componentes usam a luz para acoplar os circuitos, isolando eletricamente os terminais de campo dos circuitos l\u00f3gicos internos do processador, o que previne danos causados por transientes de tens\u00e3o e ru\u00eddos el\u00e9tricos do ambiente industrial.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/02-interfaces/#enderecamento","title":"Endere\u00e7amento","text":"<p>Al\u00e9m disso, as interfaces utilizam um sistema de endere\u00e7amento, que funciona como um n\u00famero residencial, indicando exatamente onde cada informa\u00e7\u00e3o est\u00e1 localizada na mem\u00f3ria para que o processador saiba qual dispositivo deve monitorar ou controlar. Em sistemas modernos, como o ControlLogix, esse endere\u00e7amento evoluiu para o uso de etiquetas (tags), nomes descritivos que facilitam a identifica\u00e7\u00e3o dos dados.</p> Tipo E/S Etiqueta (TAG) Contato Endere\u00e7o Descri\u00e7\u00e3o Entrada Digital X0 Stop NO IX0.0 Parar o processo Entrada Digital X1 Start NO IX0.1 Iniciar o processo Entrada Digital X2 Clean NO IX0.2 Zerar contadores Entrada Digital X3 Reset NO IX0.3 Reiniciar o processo Entrada Digital X4 FS1 NO IX0.4 Acionamento por pedal 1 Entrada Digital X5 FS2 NC IX0.5 Acionamento por pedal 2 Entrada Digital X6 TC1 NO IX0.6 Contato auxiliar de temporiza\u00e7\u00e3o Entrada Digital X7 P/S1 NO IX0.7 Sensor Sa\u00edda Digital Y0 K1 - QX0.0 Comum Sa\u00edda Digital Y1 K2 - QX0.1 Estrela Sa\u00edda Digital Y2 K3 - QX0.2 Triangulo Sa\u00edda Digital Y3 K4 - QX0.3 Direta Sa\u00edda Digital Y4 K5 - QX0.4 Sinaliza\u00e7\u00e3o Sa\u00edda Digital Y5 K6 - QX0.5 Auxiliar <p>Material Complementar</p> <ol> <li>Programable Logic Controller Basics Explained - The Engineering Mindset</li> <li>PLC Basics - Programmable Logic Controller - RealPairs</li> <li>PLC Hardware Components - Automatedo</li> </ol>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/","title":"Sistema Num\u00e9rico","text":"<p>Os CLPs operam internamente atrav\u00e9s de n\u00fameros bin\u00e1rios para processar e armazenar informa\u00e7\u00f5es, por isso h\u00e1 um import\u00e2ncia em conhecer como s\u00e3o representados os dados em algumas de suas diferentes formas.  </p> <p> </p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#1-sistemas-de-numeracao-decimal-binario-octal-e-hexadecimal","title":"1. Sistemas de Numera\u00e7\u00e3o (Decimal, Bin\u00e1rio, Octal e Hexadecimal)","text":"<ul> <li> <p>Sistema Decimal: Utiliza a base 10 e os d\u00edgitos de 0 a 9, onde o valor de cada d\u00edgito \u00e9 determinado pelo seu peso (pot\u00eancia de 10) conforme sua posi\u00e7\u00e3o.</p> </li> <li> <p>Sistema Bin\u00e1rio: \u00c9 a base do funcionamento dos circuitos digitais e dos CLPs, utilizando a base 2 (d\u00edgitos 0 e 1). Cada d\u00edgito bin\u00e1rio \u00e9 chamado de bit, sendo que um grupo de 8 bits forma um byte e um conjunto de dois ou mais bytes forma uma palavra (word).</p> </li> <li> <p>Sistema Octal: Baseado na base 8 (d\u00edgitos 0 a 7), \u00e9 usado para representar grupos de 3 bits, facilitando a leitura de n\u00fameros bin\u00e1rios extensos. \u00c9 comum no endere\u00e7amento de controladores como o PLC-5 da Allen-Bradley.</p> </li> <li> <p>Sistema Hexadecimal: Utiliza a base 16, empregando os d\u00edgitos de 0 a 9 e as letras de A a F para representar valores decimais de 10 a 15. \u00c9 amplamente utilizado para visualizar o estado de palavras de dados de 16 ou 32 bits em telas de programa\u00e7\u00e3o.</p> </li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#12-numeros-negativos-e-aritmetica-binaria","title":"1.2 N\u00fameros Negativos e Aritm\u00e9tica Bin\u00e1ria","text":"<ul> <li> <p>N\u00fameros Negativos: Como os CLPs n\u00e3o usam sinais de \"+\" ou \"-\", eles utilizam um bit de sinal no lado mais significativo (MSB), onde 0 indica positivo e 1 indica negativo. O m\u00e9todo mais comum para expressar esses valores \u00e9 o complemento de 2.</p> </li> <li> <p>Aritm\u00e9tica Bin\u00e1ria: Opera\u00e7\u00f5es de soma, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o e divis\u00e3o s\u00e3o executadas pela CPU. Tamb\u00e9m s\u00e3o executadas instru\u00e7\u00f5es de compara\u00e7\u00e3o (Igual, Maior que, Menor que), fundamentais para o controle de processos baseados em valores acumulados de temporizadores e contadores.</p> </li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#2-codigos-digitais-bcd-gray-e-ascii","title":"2. C\u00f3digos Digitais (BCD, Gray e ASCII)","text":"<ul> <li>BCD (Decimal Codificado em Bin\u00e1rio): Representa cada d\u00edgito decimal individualmente atrav\u00e9s de um grupo de 4 bits. \u00c9 o formato utilizado por dispositivos externos como chaves de tambor (thumbwheels) e displays de LED.</li> </ul> <ul> <li>C\u00f3digo Gray: Caracteriza-se por mudar apenas um bit na transi\u00e7\u00e3o entre n\u00fameros consecutivos, sendo ideal para codificadores (encoders) \u00f3pticos, pois minimiza erros de leitura em movimentos r\u00e1pidos.</li> </ul> <ul> <li>C\u00f3digo ASCII: C\u00f3digo alfanum\u00e9rico que utiliza 7 ou 8 bits para representar letras, n\u00fameros e caracteres especiais, permitindo a interface do CLP com teclados e impressoras.</li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#3-integridade-de-dados","title":"3. Integridade de Dados","text":"<ul> <li>Bit de Paridade: \u00c9 um d\u00edgito bin\u00e1rio adicional anexado a uma palavra para detectar erros durante a transmiss\u00e3o de dados entre CLPs ou computadores. Pode ser configurado como paridade par ou \u00edmpar, dependendo da l\u00f3gica do sistema.</li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#4-fundamentos-de-logica","title":"4. Fundamentos de l\u00f3gica","text":"<p>O CLP opera com base no princ\u00edpio bin\u00e1rio, onde estados como ligado/desligado ou verdadeiro/falso s\u00e3o representados pelos d\u00edgitos 1 e 0. Uma porta l\u00f3gica \u00e9 um circuito que possui v\u00e1rias entradas e uma \u00fanica sa\u00edda, ativada por combina\u00e7\u00f5es espec\u00edficas dessas entradas. A l\u00f3gica permite que o controlador tome decis\u00f5es baseadas em um ou mais fatores antes de executar uma a\u00e7\u00e3o.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#41-funcoes-logicas-fundamentais-and-or-e-not","title":"4.1 Fun\u00e7\u00f5es L\u00f3gicas Fundamentais (AND, OR e NOT)","text":"<ul> <li>Fun\u00e7\u00e3o AND: A sa\u00edda \u00e9 1 apenas se todas as entradas forem 1. Em termos el\u00e9tricos, \u00e9 an\u00e1loga a dispositivos conectados em s\u00e9rie.</li> </ul> <pre><code>        A        B                 L\u00e2mpada\n|------| |------| |------------------( )-----|\n</code></pre> <ul> <li>Fun\u00e7\u00e3o OR: A sa\u00edda \u00e9 1 se uma ou mais entradas forem 1. \u00c9 similar a dispositivos conectados em paralelo.</li> </ul> <p> <pre><code>        A                         L\u00e2mpada\n|------| |---------------------------( )-----|\n              |\n        B     |\n|------| |----'\n</code></pre></p> <ul> <li>Fun\u00e7\u00e3o NOT: Possui apenas uma entrada e sua sa\u00edda \u00e9 sempre o inverso desta, sendo por isso chamada de inversor.</li> </ul> <p></p> <pre><code>        A                       L\u00e2mpada\n|------|/|------------------------( )-----|\n</code></pre> <ul> <li>NAND, NOR e XOR: Tamb\u00e9m temos as portas derivadas NAND (AND invertida), a NOR (OR invertida) e a XOR (OR Exclusivo), cuja sa\u00edda \u00e9 1 apenas se uma das entradas for 1, mas n\u00e3o ambas.</li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#42-algebra-booleana","title":"4.2. \u00c1lgebra Booleana","text":"<p>A \u00e1lgebra booleana \u00e9 o estudo matem\u00e1tico da l\u00f3gica e fornece um m\u00e9todo simples para escrever combina\u00e7\u00f5es complexas atrav\u00e9s de equa\u00e7\u00f5es. \u00c9 poss\u00edvel desenvolver circuitos l\u00f3gicos a partir de express\u00f5es booleanas e vice-versa. </p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#421-axiomas-e-teoremas","title":"4.2.1 Axiomas e Teoremas","text":"<p>Para a simplifica\u00e7\u00e3o de express\u00f5es, as fontes destacam postulados fundamentais:</p> <ul> <li> <p>Identidade: </p> <ul> <li>\\(A + 0 = A\\)</li> <li>\\(A \\cdot 1 = A\\)</li> </ul> </li> <li> <p>Nulo (Absorvente): </p> <ul> <li>\\(A + 1 = 1\\)</li> <li>\\(A \\cdot 0 = 0\\)</li> </ul> </li> <li> <p>Idempot\u00eancia: </p> <ul> <li>\\(A + A = A\\)</li> <li>\\(A \\cdot A = A\\)</li> </ul> </li> <li> <p>Complementaridade: </p> <ul> <li>\\(A + \\overline{A} = 1\\)</li> <li>\\(A \\cdot \\overline{A} = 0\\)</li> </ul> </li> <li> <p>Involu\u00e7\u00e3o (Dupla Nega\u00e7\u00e3o): </p> <ul> <li>\\(\\overline{\\overline{A}} = A\\)</li> </ul> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#422-propriedades-e-leis-algebricas","title":"4.2.2 Propriedades e Leis Alg\u00e9bricas","text":"<p>Essas leis regem a manipula\u00e7\u00e3o de express\u00f5es complexas e seguem princ\u00edpios similares \u00e0 \u00e1lgebra convencional, com exce\u00e7\u00f5es espec\u00edficas.</p> <ul> <li> <p>Comutativa: A ordem das vari\u00e1veis n\u00e3o altera o resultado da opera\u00e7\u00e3o</p> <ul> <li>\\(A + B = B + A\\)</li> <li>\\(A \\cdot B = B \\cdot A\\)</li> </ul> </li> <li> <p>Associativa: O agrupamento de termos em somas ou produtos n\u00e3o altera o resultado final </p> <ul> <li>\\(A + (B + C) = (A + B) + C\\)</li> <li>\\(A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C\\)</li> </ul> </li> <li> <p>Distributiva: Permite a expans\u00e3o ou fatora\u00e7\u00e3o de termos </p> <ul> <li>\\(A \\cdot (B + C) = (A \\cdot B) + (A \\cdot C)\\)</li> <li>\\((A \\cdot B) + C = (A + C) \\cdot (B + C)\\)</li> </ul> </li> <li> <p>Absor\u00e7\u00e3o: Termos redundantes s\u00e3o eliminados pela vari\u00e1vel dominante </p> <ul> <li>\\(A + A \\cdot B = A\\)</li> <li>\\(A \\cdot (A + B) = A\\)</li> </ul> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#423-teoremas-de-de-morgan","title":"4.2.3 Teoremas de De Morgan","text":"<p>Augustus De Morgan estabeleceu dois teoremas vitais que permitem a convers\u00e3o entre operadores e a simplifica\u00e7\u00e3o de barras de invers\u00e3o sobre express\u00f5es complexas.</p> <ul> <li> <p>Primeira Lei: O complemento do produto de vari\u00e1veis \u00e9 igual \u00e0 soma dos complementos individuais </p> <ul> <li>\\(\\overline{A \\cdot B} = \\overline{A} + \\overline{B}\\)</li> </ul> </li> <li> <p>Segunda Lei: O complemento da soma de vari\u00e1veis \u00e9 igual ao produto dos complementos individuais </p> <ul> <li>\\(\\overline{A + B} = \\overline{A} \\cdot \\overline{B}\\)</li> </ul> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#424-principio-da-dualidade","title":"4.2.4 Princ\u00edpio da Dualidade","text":"<p>Toda express\u00e3o booleana permanece v\u00e1lida se os operadores AND e OR forem trocados entre si, simultaneamente com a troca dos valores l\u00f3gicos 0 e 1. Este princ\u00edpio \u00e9 fundamental para a s\u00edntese de hardware, permitindo, por exemplo, a implementa\u00e7\u00e3o de uma porta AND utilizando uma porta OR com entradas e sa\u00eddas invertidas.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#43-logica-instalada-vs-logica-programada","title":"4.3 L\u00f3gica Instalada vs. L\u00f3gica Programada","text":"<ul> <li> <p>L\u00f3gica Instalada: Refere-se a fun\u00e7\u00f5es de controle determinadas por conex\u00f5es el\u00e9tricas f\u00edsicas entre dispositivos (l\u00f3gica de rel\u00e9s), que s\u00e3o dif\u00edceis de modificar.</p> </li> <li> <p>L\u00f3gica Programada: Baseia-se em fun\u00e7\u00f5es l\u00f3gicas fundamentais executadas via software no CLP. A linguagem mais comum \u00e9 a L\u00f3gica Ladder, que utiliza s\u00edmbolos de contatos e bobinas para simplificar a convers\u00e3o de esquemas de rel\u00e9s para programas.</p> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/03-num_logicas/#44-instrucoes-logicas-em-nivel-de-palavra","title":"4.4 Instru\u00e7\u00f5es L\u00f3gicas em N\u00edvel de Palavra","text":"<p>Muitos CLPs possuem instru\u00e7\u00f5es que realizam opera\u00e7\u00f5es l\u00f3gicas (AND, OR, XOR, NOT) n\u00e3o apenas em bits individuais, mas em palavras de dados completas (16 ou 32 bits). Essas instru\u00e7\u00f5es orientam o processador a comparar ou combinar dois endere\u00e7os de origem e armazenar o resultado em um destino. Elas s\u00e3o frequentemente utilizadas em diagn\u00f3sticos, como na compara\u00e7\u00e3o de estados reais de chaves com estados desejados.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/","title":"Acionamento B\u00e1sico com CLP","text":"","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#1-partida-direta-de-motor","title":"1. Partida Direta de Motor","text":"<p>Uma partida de motor, especificamente a chave de partida direta, \u00e9 um dispositivo projetado para fornecer pot\u00eancia el\u00e9trica a motores de forma controlada.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#11-composicao-da-chave-de-partida","title":"1.1 Composi\u00e7\u00e3o da Chave de Partida","text":"<p>Uma chave de partida direta \u00e9 composta fundamentalmente por dois componentes acoplados f\u00edsica e eletricamente:</p> <ul> <li> <p>Contator: Funciona como uma chave magn\u00e9tica que estabelece e interrompe o fluxo de energia para o motor. Ele possui contatos de pot\u00eancia (para a corrente alta do motor) e contatos auxiliares (para o circuito de controle).</p> </li> <li> <p>Rel\u00e9 de Sobrecarga: Sua fun\u00e7\u00e3o \u00e9 proteger o motor contra correntes excessivas. Ele detecta o aumento de calor causado pela sobrecorrente e abre o circuito, desenergizando a bobina do contator e parando o motor para evitar danos.</p> </li> </ul> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#12-funcionamento-do-acionamento-tradicional","title":"1.2 Funcionamento do Acionamento Tradicional","text":"<p>No modo manual/eletromec\u00e2nico, o acionamento ocorre da seguinte forma:</p> <ul> <li> <p>Partida (S1): Ao pressionar um bot\u00e3o de comando normalmente aberto, a bobina do contator (K1) \u00e9 energizada. Isso fecha os contatos de pot\u00eancia, ligando o motor.</p> </li> <li> <p>Circuito de Selo: Como o bot\u00e3o de partida \u00e9 moment\u00e2neo, utiliza-se um contato auxiliar do pr\u00f3prio contator em paralelo com o bot\u00e3o. Quando o bot\u00e3o \u00e9 liberado, este contato (chamado de selo ou manuten\u00e7\u00e3o) mant\u00e9m a bobina energizada.</p> </li> <li> <p>Parada (S0): O motor para quando o bot\u00e3o de parada (normalmente fechado) \u00e9 pressionado ou quando o rel\u00e9 de sobrecarga atua, interrompendo o fluxo de corrente para a bobina.</p> </li> </ul> Figura 1: Diagrama de Pot\u00eancia e Comando de uma partida direta de motor Fonte: PARTIDA DIRETA DE MOTORES - COMO LIGAR? - \u00d4mega Treinamentos","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#13-acionamento-realizado-via-clp","title":"1.3 Acionamento Realizado via CLP","text":"<p>Ao utilizar um Controlador L\u00f3gico Program\u00e1vel, a l\u00f3gica de fia\u00e7\u00e3o f\u00edsica \u00e9 substitu\u00edda pela l\u00f3gica programada (software).</p> <ul> <li> <p>Conex\u00e3o de Hardware: Os bot\u00f5es de partida e parada s\u00e3o conectados aos m\u00f3dulos de entrada do CLP. A bobina da chave de partida \u00e9 conectada ao m\u00f3dulo de sa\u00edda.</p> </li> <li> <p>L\u00f3gica de Programa\u00e7\u00e3o (Ladder): O acionamento \u00e9 realizado atrav\u00e9s de um programa em l\u00f3gica Ladder que emula o circuito de selo. </p> <ul> <li>S1 - PARTIDA (Contato Normalmente Aberto): Quando acionado realiza a partida do motor.</li> <li>S0 - PARADA (Contato Normalmente Fechado): Quando acionado realiza a parada do motor.</li> <li>OL (Contato Normalmente Fechado): Quando acionado indica sobrecarga no acionamento do motor.</li> <li>K1: Ativa a bobina do contator que liga o motor.</li> <li>G: Ativa sinaleiro verde.</li> <li>R: Ativa sinaleiro vermelho.</li> </ul> </li> </ul> <p></p> Partida Direta de Motor com Sinaliza\u00e7\u00e3o<pre><code>      S0       S1        OL                       K1\n|----| |-------| |------| |-----------------------( )-----|\n           |         |\n           |    K1   |\n           '---| |---'\n\n      K1                                           G\n|-----|/|-----------------------------------------( )-----|\n\n      K1                                           R\n|-----| |-----------------------------------------( )-----|\n</code></pre>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#14-praticas-recomendas-de-seguranca","title":"1.4 Pr\u00e1ticas Recomendas de Seguran\u00e7a","text":"<p>O programa do CLP \u00e9 mais seguro quando utiliza um contato auxiliar f\u00edsico do contator como sinal de entrada para o controlador. Isso fornece uma realimenta\u00e7\u00e3o positiva, permitindo que o processador saiba se o motor realmente ligou ou se houve uma falha (como a atua\u00e7\u00e3o do rel\u00e9 de sobrecarga), evitando condi\u00e7\u00f5es de opera\u00e7\u00e3o perigosas. Al\u00e9m disso, bot\u00f5es de parada de emerg\u00eancia devem ser sempre conectados fisicamente para desenergizar o rel\u00e9 mestre de controle (MCR), garantindo o desligamento independente do software.</p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#2-partida-direta-com-reversao","title":"2. Partida Direta com Revers\u00e3o","text":"<p>A partida direta com revers\u00e3o \u00e9 um m\u00e9todo de acionamento para motores el\u00e9tricos trif\u00e1sicos que permite alterar o sentido de giro do eixo. Isso \u00e9 essencial em equipamentos como tornos, pontes rolantes e esteiras transportadoras. </p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#21-como-funciona","title":"2.1 Como funciona?","text":"<p>O princ\u00edpio b\u00e1sico \u00e9 a invers\u00e3o de duas das tr\u00eas fases que alimentam o motor. Ao trocar a sequ\u00eancia das fases (ex: de R-S-T para T-S-R), o campo magn\u00e9tico girante do estator muda de dire\u00e7\u00e3o, for\u00e7ando o motor a girar no sentido oposto. </p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#22-componentes-principais","title":"2.2 Componentes Principais","text":"<p>Para realizar essa manobra de forma segura, o painel el\u00e9trico utiliza:</p> <ul> <li>Dois Contatores (K1 e K2): Um para o sentido hor\u00e1rio e outro para o anti-hor\u00e1rio.</li> <li>Disjuntor Motor ou Rel\u00e9 T\u00e9rmico: Protege o motor contra sobrecargas e curtos-circuitos.</li> <li>Botoeiras: Geralmente tr\u00eas bot\u00f5es \u2014 um para \"Sentido 1\", um para \"Sentido 2\" e um para \"Parar\".</li> <li>Intertravamento: Um recurso de seguran\u00e7a cr\u00edtico (via contatos auxiliares NF) que impede que os dois contatores entrem simultaneamente, o que causaria um curto-circuito entre fases. </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#23-diagramas-de-conexao","title":"2.3 Diagramas de Conex\u00e3o","text":"<ul> <li> <p>Circuito de Pot\u00eancia: Mostra a liga\u00e7\u00e3o dos cabos que levam a energia ao motor, evidenciando a invers\u00e3o f\u00edsica das fases nos contatores.</p> </li> <li> <p>Circuito de Comando: Define a l\u00f3gica de funcionamento, garantindo que o motor s\u00f3 inverta o giro ap\u00f3s ser desligado (ou conforme a configura\u00e7\u00e3o de seguran\u00e7a) e gerenciando o intertravamento. </p> </li> </ul>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#24-atividade","title":"2.4 Atividade","text":"<p>Elabore o programa em linguagem Ladder para realizar o acionamento de uma partida direta com revers\u00e3o conforme as indica\u00e7\u00f5es de entradas e sa\u00eddas da figura a seguir.</p> <p></p>","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/clp/tecnologia/04-acionamento_basico/#referencias","title":"Refer\u00eancias","text":"<p>Explica\u00e7\u00e3o detalhada sobre o acionamento n\u00e3o faz parte do escopo deste material, sendo assim, seguem indica\u00e7\u00f5es:</p> <ol> <li>Sala da El\u00e9trica</li> <li>PARTIDA DIRETA DE MOTORES - COMO LIGAR? - \u00d4mega Treinamentos</li> </ol> V\u00eddeo 1: Anima\u00e7\u00e3o de liga\u00e7\u00f5es em um comando de partida direta de motor Fonte: Comando El\u00e9trico Super F\u00e1cil (Partida Direta) - Marcos Instala\u00e7\u00e3o El\u00e9trica","tags":["CLP","Controlador program\u00e1vel","PLC"]},{"location":"automacao/pneumatica/fluidsim/01-simulacao/","title":"Simula\u00e7\u00e3o","text":"<p>Primeira simula\u00e7\u00e3o no FluidSim</p> <p>Ao abrir o simulador <code>FluidSim Pneum\u00e1tica</code>, clique em:</p> <p>1) <code>Arquivo</code></p> <p>2) <code>Novo            Ctrl+N</code></p> <p>3) Uma janela em branco \u00e9 aberta com a indica\u00e7\u00e3o de arquivo <code>noname.ct</code>, como mostrado na Figura 1.</p> Figura 1: Criando um novo arquivo para um circuito Fonte: Autor <p>Para inserir os elementos do circuito pneum\u00e1tico, clique em:</p> <p>4) <code>Inserir</code> e <code>Procurar componente ...    F3</code></p> <p>\u00c9 aberta a janela para busca de componente, conforme mostrado na Figura 2.</p> <p>No campo <code>Palavras ...</code>, fazer a busca pelas pelavras chave dos componentes que se quer inserir.</p> <p>Uma lista de op\u00e7\u00f5es encontradas \u00e9 exibida, em que pode ser feita a sele\u00e7\u00e3o do componente desejado.</p> <p>Abaixo \u00e9 mostrada uma visualiza\u00e7\u00e3o da simbologia do componente selecionado;</p> <p>5) Ao selecionar o componente correto, clique em <code>OK</code> para inser\u00ed-lo na folha do circuito.</p> <p>6) Lista de componentes a serem inseridos no item 4:</p> <ul> <li>\"Alimenta\u00e7\u00e3o de ar comprimido\"</li> <li>\"Cilindro de simples a\u00e7\u00e3o\"</li> <li>\"V\u00e1lvula 3/2 vias, com bot\u00e3o de acionamento, normalmente fechada\"</li> </ul> Figura 2: Inserindo componentes Fonte: Autor <p>Ap\u00f3s inserir os componentes na folha do circuito, e posicion\u00e1-los de forma adequada para conex\u00e3o dos componentes, use as ferramentas de ajuste e posicionamento da imagem no item 1 da Figura 3.</p> <p>Conecte os dispositivos de acordo com o circuito proposto. Ao passar o mouse sobre o ponto de conex\u00e3o, ele fica na cor verde, item 2 da Figura 3, e deve-se clicar e arrastar at\u00e9 o ponto de destino.</p> Figura 3: Inserindo componentes Fonte: Autor <p>Ap\u00f3s conecatar todos os componentes, clique no bot\u00e3o de start para iniciar a simula\u00e7\u00e3o, item 3 da Figura 3.</p> <p>Note que as linhas que ficam em azul escuro, representam um linha de press\u00e3o e as linhas em azul claro a press\u00e3o atmosf\u00e9rica.</p> <p>\u00c9 possivel clicar no dispositivo que representa o bot\u00e3o de acionamento da v\u00e1lvula, item 4 da Figura 3, comutando a v\u00e1lvula e acionando a o cilindro.</p> <p>Ao soltar o bot\u00e3o, a mola retorna a v\u00e1lvula para a posi\u00e7\u00e3o original e o cilindro recua, da mesma forma por a\u00e7\u00e3o de sua mola.</p> <p>Para encerrar a simula\u00e7\u00e3o, clique em Stop, item 5 da Figura 3.</p> Figura 4: Simula\u00e7\u00e3o de circuito pneum\u00e1tico Fonte: Autor Figura 5: Altera\u00e7\u00e3o de par\u00e2metros dos elementos do circuito Fonte: Autor Figura 6: Acionamento de v\u00e1lvula via bot\u00e3o com trava Fonte: Autor Figura 7: Altera\u00e7\u00e3o do recuo da v\u00e1lvula Fonte: Autor Figura 8: Simula\u00e7\u00e3o de duplo acionamento manual Fonte: Autor","tags":["Pneum\u00e1tica","FluidSim","Simula\u00e7\u00e3o"]},{"location":"automacao/pneumatica/fluidsim/02-circuitosSequenciais/","title":"Exerc\u00edcios","text":"<p>Exerc\u00edcios</p> <p>Elabore o diagrama de acionamento dos circuitos eletropneum\u00e1ticos das figuras 1, 2, 3 e 4 utilizando a t\u00e9cnica de maximiza\u00e7\u00e3o de contatos.</p> Figura 1: Sequencia de movimentos A+ A- Fonte: Autor Figura 2: Sequencia de movimentos A+ B+ B- A- Fonte: Autor Figura 3: Sequencia de movimentos A+ B+ A- B- Fonte: Autor Figura 4: Sequencia de movimentos A+ A- B+ B- Fonte: Autor <p>Elabore os diagramas pneum\u00e1ticos e de acionamento das sequencias de movimento para os atuadores A, B e C das figuras 5, 6, 7 e 8, utilizando a t\u00e9cnica de maximiza\u00e7\u00e3o de contatos.</p> Figura 5: Diagrama Trajeto-Passo Fonte: Autor Figura 6: Diagrama Trajeto-Passo Fonte: Autor Figura 7: Diagrama Trajeto-Passo Fonte: Autor Figura 8: Diagrama Trajeto-Passo Fonte: Autor","tags":["Pneum\u00e1tica","FluidSim","Simula\u00e7\u00e3o"]},{"location":"automacao/redes/","title":"Redes e Protocolos Industriais","text":"","tags":["RPI","Redes Industriais","Protocolos Industriais","IFSP"]},{"location":"automacao/redes/#slides-aulas","title":"Slides: Aulas","text":"Aula T\u00edtulo Conte\u00fado 01 O que s\u00e3o Redes Industriais? Conceito, hist\u00f3ria e evolu\u00e7\u00e3o - Defini\u00e7\u00e3o: Rede e ind\u00fastria;- Revolu\u00e7\u00f5es Industriais;- Tipos de redes industriais;- Converg\u00eancia tecnol\u00f3gica: TI + TA;- Arquitetura de refer\u00eancia para uma planta de Automa\u00e7\u00e3o Industrial;- Necessidades emergentes;- Benef\u00edcios da converg\u00eancia;- Objetivos da Rede Industrial;- Protocolos de comunica\u00e7\u00e3o:\u2003 - N\u00edveis da rede industrial;\u2003 - Evolu\u00e7\u00e3o das redes industriais;\u2003 - Tipos de transmiss\u00e3o;\u2003 - Finalidade dos protocolos no meio industrial; 02 Classifica\u00e7\u00e3o e arquiteturas - Topologia f\u00edsica;- Modelos de redes;- M\u00e9todo de troca de dados;- Tipo de conex\u00e3o;- Modo de transmiss\u00e3o;- Sincroniza\u00e7\u00e3o de bits;- Modo de opera\u00e7\u00e3o;- Tipo de comunica\u00e7\u00e3o; 03 Crit\u00e9rios para dimensionamento - Meio f\u00edsico de comunica\u00e7\u00e3o;- Cobertura geogr\u00e1fica;- M\u00e9todo de acesso;- Desempenho: Velocidade x Throughput;- Confiabilidade: Determin\u00edstico x Probabil\u00edstico;- Protocolo de comunica\u00e7\u00e3o; 04 Modelo OSI/ISO - Caracter\u00edsticas do Modelo- Camada 7 - Aplica\u00e7\u00e3o- Camada 6 - Apresenta\u00e7\u00e3o- Camada 5 - Sess\u00e3o- Camada 4 - Transporte- Camada 3 - Rede - Camada 2 - Enlace- Camada 1 - F\u00edsica 05 Meio F\u00edsico  RS232/RS485/RS422 - RS232\u2003 - Conectores e pinagem\u2003 - Caracter\u00edsticas el\u00e9tricas\u2003 - Dist\u00e2ncia e baud rate\u2003 - Controle de fluxo por hardware\u2003 - Transceiver - MAX232- RS485\u2003 - Aplica\u00e7\u00e3o\u2003 - Topologias\u2003 - Par diferencial e n\u00edveis de tens\u00e3o\u2003 - Resistor de termina\u00e7\u00e3o\u2003 - Dist\u00e2ncia e velocidade de comunica\u00e7\u00e3o\u2003 - Multiponto\u2003 - Transceivers comerciais 06 Protocolo de comunica\u00e7\u00e3o  MODBUS - Introdu\u00e7\u00e3o - Modicon, protocolo aberto- Conex\u00e3o e cabo de transmiss\u00e3o- Modbus e modelo ISO/OSI- Cliente-Servidor - Unicast x Broadcast- Codifica\u00e7\u00e3o da mensagem - RTU e Ascii- Modelo de organiza\u00e7\u00e3o da mem\u00f3ria- Unidade de dados de protocolo (PDU)- Frame e temporiza\u00e7\u00e3o em modo RTU- Codifica\u00e7\u00e3o da mensagem 07 Sistema Supervis\u00f3rio  SCADA - Objetivos- Aplica\u00e7\u00f5es- Benef\u00edcios- Desafios- Exemplos de sistemas:\u2003 - Indusoft/Aveva Edge\u2003 - Elipse\u2003 - BluePlant\u2003 - ScadaBR 08 Rede sem fio industrial - Introdu\u00e7\u00e3o- Wi-Fi- Bluetooth- Redes de Sensores Sem Fio (RSSF)- Fatores determinantes em redes sem fio- Pr\u00e1ticas recomendadas 09 IIoT - Ind\u00fastria 4.0- Modelo hier\u00e1rquico ISA95- Mudan\u00e7a de paradigma com dados- IoT x IIoT- Tecnologias de IIoT\u2003 - Intelig\u00eancia artificial\u2003 - Seguran\u00e7a cibern\u00e9tica\u2003 - Computa\u00e7\u00e3o em nuvem\u2003 - Computa\u00e7\u00e3o de borda\u2003 - Minera\u00e7\u00e3o e An\u00e1lise de Dados- Desafios da IIoT","tags":["RPI","Redes Industriais","Protocolos Industriais","IFSP"]},{"location":"automacao/redes/#a1-pratica-orientada-em-laboratorio","title":"A1. Pr\u00e1tica orientada em laborat\u00f3rio","text":"<ol> <li> <p>Sinal de comunica\u00e7\u00e3o</p> <ol> <li>Baud Rate, Tbit; </li> <li>Configura\u00e7\u00f5es de comunica\u00e7\u00e3o:<ol> <li>Bit de in\u00edcio de comunica\u00e7\u00e3o (Start bits);</li> <li>Bits de Dados;</li> <li>Bit de Paridade;</li> <li>Bits de parada (Stop bits);</li> <li>Tchar;</li> </ol> </li> <li>Tabela Ascii<ol> <li>C\u00f3digos em hexadecimal</li> <li>C\u00f3digos em bin\u00e1rio</li> </ol> </li> <li>Lab. Sinais de Comunica\u00e7\u00e3o - ArduinoUno</li> </ol> </li> <li> <p>Comunica\u00e7\u00e3o Serial via RS485</p> </li> <li> <p>Sistema Supervis\u00f3rio - ScadaBR</p> </li> <li> <p>Projeto Modbus+Supervis\u00f3rio</p> </li> </ol>","tags":["RPI","Redes Industriais","Protocolos Industriais","IFSP"]},{"location":"automacao/redes/#a2-ferramentassoftware","title":"A2. Ferramentas/Software","text":"<ul> <li>Termite: a simple RS232 terminal</li> <li> <p>Terminal</p> </li> <li> <p>T1: Soldagem SMD</p> </li> </ul>","tags":["RPI","Redes Industriais","Protocolos Industriais","IFSP"]},{"location":"automacao/redes/tecnologia/01-redes_conceito/","title":"Conceito de Rede","text":"<p>O que s\u00e3o Redes Industriais? Conceito, hist\u00f3ria e evolu\u00e7\u00e3o</p> <ul> <li>Defini\u00e7\u00e3o: Rede e ind\u00fastria;</li> <li>Revolu\u00e7\u00f5es Industriais;</li> <li>Tipos de redes industriais;</li> <li>Converg\u00eancia tecnol\u00f3gica: TI + TA;</li> <li>Arquitetura de refer\u00eancia para uma planta de Automa\u00e7\u00e3o Industrial;</li> <li>Necessidades emergentes;</li> <li>Benef\u00edcios da converg\u00eancia;</li> <li>Objetivos da Rede Industrial;</li> <li>Protocolos de comunica\u00e7\u00e3o:<ul> <li>N\u00edveis da rede industrial;</li> <li>Evolu\u00e7\u00e3o das redes industriais;</li> <li>Tipos de transmiss\u00e3o;</li> <li>Finalidade dos protocolos no meio industrial;</li> </ul> </li> </ul> <p>1.0 Introdu\u00e7\u00e3o: A Espinha Dorsal da Ind\u00fastria Moderna</p> <p>No cora\u00e7\u00e3o da automa\u00e7\u00e3o moderna, as redes industriais funcionam como um sistema nervoso central, conectando m\u00e1quinas, processos e pessoas para criar um ecossistema produtivo coeso e inteligente. Para os profissionais de automa\u00e7\u00e3o, compreender a evolu\u00e7\u00e3o e os objetivos dessas redes n\u00e3o \u00e9 apenas um exerc\u00edcio t\u00e9cnico, mas uma necessidade estrat\u00e9gica para impulsionar a efici\u00eancia, a competitividade e a inova\u00e7\u00e3o. Sem uma base de comunica\u00e7\u00e3o robusta, as promessas de otimiza\u00e7\u00e3o e intelig\u00eancia da Ind\u00fastria 4.0 permanecem inating\u00edveis.</p> <p>Em sua ess\u00eancia, uma rede industrial \u00e9 um sistema de comunica\u00e7\u00e3o de dados projetado especificamente para a troca de informa\u00e7\u00f5es entre, no m\u00ednimo, dois dispositivos em um ambiente industrial. A din\u00e2mica fundamental dessa troca pode ser simplificada pelo modelo cl\u00e1ssico de comunica\u00e7\u00e3o, que permanece relevante at\u00e9 hoje:</p> <p><code>Emissor ---&gt; Mensagem ---&gt; Receptor</code></p> <p>Essa estrutura b\u00e1sica, no entanto, evoluiu de simples conex\u00f5es ponto a ponto para arquiteturas complexas que sustentam opera\u00e7\u00f5es globais. Para entender verdadeiramente o estado atual e o futuro dessas redes, \u00e9 essencial revisitar as revolu\u00e7\u00f5es industriais que moldaram sua necessidade e seu desenvolvimento.</p> <p>2.0 As Quatro Revolu\u00e7\u00f5es Industriais: Uma Base para a Conectividade</p> <p>Entender as revolu\u00e7\u00f5es industriais \u00e9 fundamental, pois elas atuaram como catalisadores para a evolu\u00e7\u00e3o da tecnologia de produ\u00e7\u00e3o e, consequentemente, das redes de comunica\u00e7\u00e3o. Cada revolu\u00e7\u00e3o introduziu um novo n\u00edvel de complexidade e escala, aumentando exponencialmente a necessidade de troca de informa\u00e7\u00f5es, desde simples comandos mec\u00e2nicos at\u00e9 o fluxo massivo de dados que define a era atual.</p> <p>2.1 Ind\u00fastria 1.0: A Era da Mecaniza\u00e7\u00e3o</p> <p>A primeira revolu\u00e7\u00e3o industrial, ocorrida entre os s\u00e9culos XVIII e XIX, foi marcada por uma transforma\u00e7\u00e3o fundamental nos m\u00e9todos de produ\u00e7\u00e3o, impulsionada por novas fontes de energia e inova\u00e7\u00f5es tecnol\u00f3gicas.</p> <ul> <li>Fonte de Energia: O carv\u00e3o foi o principal combust\u00edvel que alimentou as m\u00e1quinas a vapor.</li> <li>Tecnologia: Houve uma mudan\u00e7a r\u00e1pida e sem precedentes nas tecnologias de produ\u00e7\u00e3o, substituindo o trabalho artesanal pela manufatura mecanizada.</li> <li>Impacto Social: Desencadeou a cria\u00e7\u00e3o de novas estruturas econ\u00f4mico-sociais.</li> </ul> <p>2.2 Ind\u00fastria 2.0: A Era da Produ\u00e7\u00e3o em Massa</p> <p>Avan\u00e7ando para o s\u00e9culo XIX, a segunda revolu\u00e7\u00e3o industrial refinou os processos de fabrica\u00e7\u00e3o, introduzindo novas fontes de energia e modelos de organiza\u00e7\u00e3o que permitiram a produ\u00e7\u00e3o em grande escala.</p> <ul> <li>Fonte de Energia: A eletricidade tornou-se uma for\u00e7a motriz, permitindo o desenvolvimento de motores e m\u00e1quinas mais eficientes.</li> <li>Modelo de Produ\u00e7\u00e3o: A introdu\u00e7\u00e3o das linhas de montagem viabilizou a produ\u00e7\u00e3o em massa, padronizando produtos e aumentando drasticamente a produtividade.</li> </ul> <p>2.3 Ind\u00fastria 3.0: A Revolu\u00e7\u00e3o da Automa\u00e7\u00e3o</p> <p>O s\u00e9culo XX testemunhou a terceira revolu\u00e7\u00e3o industrial, na qual a eletr\u00f4nica e a tecnologia da informa\u00e7\u00e3o come\u00e7aram a automatizar os processos de produ\u00e7\u00e3o, reduzindo a necessidade de interven\u00e7\u00e3o humana direta.</p> <ul> <li>Tecnologia Central: A automa\u00e7\u00e3o foi o conceito definidor, com o uso crescente da eletr\u00f4nica e da tecnologia da informa\u00e7\u00e3o para controlar as m\u00e1quinas.</li> <li>Produ\u00e7\u00e3o: Os processos foram parcialmente automatizados, aumentando a precis\u00e3o e a efici\u00eancia.</li> <li>Marco Hist\u00f3rico: O ano de 1969 \u00e9 um ponto de inflex\u00e3o, com a cria\u00e7\u00e3o do primeiro Controlador L\u00f3gico Program\u00e1vel (CLP), um dispositivo que se tornaria a base da automa\u00e7\u00e3o industrial moderna.</li> </ul> <p>2.4 Ind\u00fastria 4.0: A Revolu\u00e7\u00e3o Digital</p> <p>A quarta revolu\u00e7\u00e3o industrial, que caracteriza o s\u00e9culo XXI, \u00e9 definida pela digitaliza\u00e7\u00e3o e pela conectividade total, onde os dados se tornam o ativo mais valioso no processo produtivo.</p> <ul> <li>Ativo Central: Os dados s\u00e3o a mat\u00e9ria-prima da Ind\u00fastria 4.0, impulsionando a tomada de decis\u00f5es e a otimiza\u00e7\u00e3o.</li> <li>Conectividade: A digitaliza\u00e7\u00e3o e a conex\u00e3o de todos os atores e sistemas no processo de gera\u00e7\u00e3o de valor s\u00e3o fundamentais.</li> <li>Converg\u00eancia: Caracteriza-se pela fus\u00e3o da produ\u00e7\u00e3o industrial com as mais avan\u00e7adas tecnologias de informa\u00e7\u00e3o e comunica\u00e7\u00e3o, criando um elo entre o mundo f\u00edsico e o cibern\u00e9tico.</li> </ul> <p>Essa trajet\u00f3ria evolutiva, da mecaniza\u00e7\u00e3o \u00e0 digitaliza\u00e7\u00e3o, culminou na era da conectividade total, estabelecendo o cen\u00e1rio para os objetivos estrat\u00e9gicos que as redes industriais modernas devem cumprir.</p> <p>3.0 Objetivos Estrat\u00e9gicos da Rede Industrial Moderna</p> <p>As redes industriais evolu\u00edram de simples cabos de controle, projetados para substituir fia\u00e7\u00f5es complexas, para se tornarem ativos estrat\u00e9gicos essenciais. Hoje, seus objetivos v\u00e3o muito al\u00e9m da mera conectividade, visando otimizar toda a cadeia de valor. Uma rede industrial bem arquitetada n\u00e3o apenas transmite dados, mas tamb\u00e9m gera intelig\u00eancia, agilidade e efici\u00eancia para o neg\u00f3cio.</p> <p>Os m\u00faltiplos objetivos de uma rede industrial moderna podem ser sintetizados nos seguintes pontos estrat\u00e9gicos:</p> <ul> <li>Redu\u00e7\u00e3o de Custos e Aumento da Flexibilidade: Eliminar interfaces manuais, substituir a fia\u00e7\u00e3o ponto a ponto complexa e cara por um \u00fanico meio de comunica\u00e7\u00e3o f\u00edsico, e eliminar a redund\u00e2ncia de atividades para reduzir custos operacionais e de instala\u00e7\u00e3o.</li> <li>Otimiza\u00e7\u00e3o da Qualidade e Efici\u00eancia: Melhorar a qualidade e a efic\u00e1cia do processo produtivo ao garantir um fluxo de informa\u00e7\u00f5es otimizado e confi\u00e1vel entre todos os componentes da organiza\u00e7\u00e3o.</li> <li>Disponibilidade de Informa\u00e7\u00f5es em Tempo Real: Fornecer dados em tempo real de toda a planta para todas as camadas da empresa, desde o ch\u00e3o de f\u00e1brica at\u00e9 o n\u00edvel corporativo, garantindo agilidade empresarial.</li> <li>Acelera\u00e7\u00e3o da Tomada de Decis\u00e3o: Ao disponibilizar informa\u00e7\u00f5es precisas e imediatas, as redes aceleram o processo de tomada de decis\u00e3o e reduzem o tempo de resposta da empresa \u00e0s demandas do mercado.</li> <li>Integra\u00e7\u00e3o Completa: Interligar todos os participantes do processo de automa\u00e7\u00e3o \u2014 de sensores e atuadores a sistemas de gerenciamento \u2014 em uma \u00fanica arquitetura coesa.</li> </ul> <p>A realiza\u00e7\u00e3o desses objetivos \u00e9 impulsionada pela poderosa converg\u00eancia de dois mundos tecnol\u00f3gicos historicamente distintos: a Tecnologia da Informa\u00e7\u00e3o (TI) e a Tecnologia de Automa\u00e7\u00e3o (TA).</p> <p>4.0 A Converg\u00eancia de TI e TA: A Arquitetura da Ind\u00fastria 4.0</p> <p>A fus\u00e3o da Tecnologia da Informa\u00e7\u00e3o (TI) com a Tecnologia de Automa\u00e7\u00e3o/Opera\u00e7\u00e3o (TA) \u00e9 a pedra angular da Ind\u00fastria 4.0. Enquanto a TI tradicionalmente gerenciava dados em ambientes de escrit\u00f3rio e corporativos, a TA operava m\u00e1quinas e processos no ch\u00e3o de f\u00e1brica. A converg\u00eancia desses dois dom\u00ednios \u00e9 a for\u00e7a motriz por tr\u00e1s da digitaliza\u00e7\u00e3o e da intelig\u00eancia nas f\u00e1bricas modernas, permitindo um fluxo cont\u00ednuo de informa\u00e7\u00f5es entre o mundo f\u00edsico e os sistemas de gest\u00e3o.</p> <p>4.1 Distinguindo os Dom\u00ednios de TI e TA</p> <p>Para implementar a converg\u00eancia de forma eficaz, \u00e9 crucial entender as diferen\u00e7as culturais e t\u00e9cnicas que historicamente separaram os dom\u00ednios de TI e TA.</p> Caracter\u00edstica Tecnologia da Informa\u00e7\u00e3o (TI) Tecnologia de Automa\u00e7\u00e3o (TA) Prop\u00f3sito Gerenciamento de dados e informa\u00e7\u00f5es Controle de sistemas e processos Ambiente de Opera\u00e7\u00e3o Consumidor / Escrit\u00f3rio Ambiente industrial Sistema Operacional Comum (ex: Windows, Linux) Desenvolvido para prop\u00f3sito espec\u00edfico Ciclo de Vida 3-5 anos D\u00e9cadas Manuten\u00e7\u00e3o Simples Especializada Atualiza\u00e7\u00f5es Frequente, r\u00e1pida Pouco frequente, com testes extensos e impacto na produ\u00e7\u00e3o Forma Poucas op\u00e7\u00f5es de configura\u00e7\u00e3o Dispositivos pequenos, montados de forma \u00fanica Interface de rede Cabeada, \u00f3ptica ou Wi-Fi LoraWAN ou WiSun Protocolos Sobre TCP/IP Muitos <p>4.2 Os Benef\u00edcios Quantific\u00e1veis da Converg\u00eancia</p> <p>A integra\u00e7\u00e3o bem-sucedida de TI e TA gera resultados mensur\u00e1veis e impactantes para o neg\u00f3cio, otimizando processos e melhorando os resultados financeiros.</p> <ul> <li>Redu\u00e7\u00e3o de defeitos: -48,9% (A an\u00e1lise de dados de TI pode identificar problemas de equipamento para reduzir defeitos.)</li> <li>Redu\u00e7\u00e3o do tempo de inatividade n\u00e3o planejado: -47,8% (A an\u00e1lise de dados de m\u00e1quinas pode prever necessidades de manuten\u00e7\u00e3o.)</li> <li>Redu\u00e7\u00e3o dos custos de energia: -17,5% (A otimiza\u00e7\u00e3o do gerenciamento de edif\u00edcios e processos reduz os custos de energia.)</li> <li>Redu\u00e7\u00e3o do tempo de introdu\u00e7\u00e3o de novos produtos: -23,1% (Os dados de fabrica\u00e7\u00e3o aceleram o ciclo de desenvolvimento e introdu\u00e7\u00e3o de novos produtos.)</li> <li>Aumento do giro de estoque: +34,8% (O rastreamento de estoque em tempo real, frequentemente via RFID, melhora o gerenciamento e a log\u00edstica.)</li> <li>Aumento da efic\u00e1cia do equipamento: +16,2%</li> </ul> <p>Esses indicadores demonstram que a converg\u00eancia n\u00e3o \u00e9 apenas uma atualiza\u00e7\u00e3o t\u00e9cnica, mas um catalisador direto para a excel\u00eancia operacional, impactando desde a efici\u00eancia do ch\u00e3o de f\u00e1brica (OEE) at\u00e9 o tempo de lan\u00e7amento de produtos no mercado (time-to-market).</p> <p>Para implementar essa converg\u00eancia de forma eficaz e colher seus benef\u00edcios, \u00e9 crucial entender as diferentes arquiteturas e classifica\u00e7\u00f5es que estruturam o universo das redes industriais.</p> <p>5.0 Anatomia das Redes Industriais: Uma An\u00e1lise Estrutural</p> <p>As redes industriais n\u00e3o s\u00e3o monol\u00edticas; elas s\u00e3o projetadas e classificadas de v\u00e1rias maneiras para atender a diferentes necessidades de desempenho, custo e aplica\u00e7\u00e3o. Compreender sua taxonomia \u00e9 o primeiro passo para projetar uma arquitetura de comunica\u00e7\u00e3o robusta e escal\u00e1vel. Esta se\u00e7\u00e3o ir\u00e1 dissecar a classifica\u00e7\u00e3o das redes por sua arquitetura (aberta vs. propriet\u00e1ria) e por sua hierarquia funcional (a Pir\u00e2mide da Automa\u00e7\u00e3o).</p> <p>5.1 An\u00e1lise por Arquitetura: Redes Abertas vs. Propriet\u00e1rias</p> <p>A escolha entre uma arquitetura de rede aberta ou propriet\u00e1ria representa uma decis\u00e3o estrat\u00e9gica fundamental com implica\u00e7\u00f5es diretas em custo, flexibilidade e manuten\u00e7\u00e3o. Redes abertas s\u00e3o projetadas para suportar equipamentos de m\u00faltiplos fabricantes, enquanto redes propriet\u00e1rias s\u00e3o desenvolvidas por um \u00fanico fabricante para seus pr\u00f3prios dispositivos.</p> Caracter\u00edstica Redes Abertas Redes Propriet\u00e1rias Vantagens <ul><li>N\u00e3o gera depend\u00eancia ou limita\u00e7\u00f5es a um \u00fanico fornecedor.</li><li>\u00c9 mais vers\u00e1til para controlar processos com equipamentos diversos.</li></ul> <ul><li>Maior estabilidade de comunica\u00e7\u00e3o.</li><li>Facilidade na instala\u00e7\u00e3o de novos equipamentos do mesmo fabricante.</li></ul> Desvantagens <ul><li>Possibilidade de falhas de comunica\u00e7\u00e3o entre dispositivos de diferentes fabricantes.</li><li>Velocidades de comunica\u00e7\u00e3o podem ser vari\u00e1veis.</li><li>Requer dom\u00ednio do protocolo de cada fabricante envolvido.</li></ul> <ul><li>Limita o uso a um \u00fanico fabricante (vendor lock-in).</li><li>Depend\u00eancia de upgrades dedicados e espec\u00edficos do fornecedor.</li></ul> <p>5.2 An\u00e1lise por Hierarquia: A Pir\u00e2mide da Automa\u00e7\u00e3o e os N\u00edveis de Rede</p> <p>O modelo da Pir\u00e2mide da Automa\u00e7\u00e3o \u00e9 uma estrutura conceitual amplamente utilizada para entender os diferentes n\u00edveis hier\u00e1rquicos de uma planta industrial, desde os dispositivos no ch\u00e3o de f\u00e1brica at\u00e9 os sistemas de gerenciamento corporativo.</p> <p>Os cinco n\u00edveis da pir\u00e2mide s\u00e3o:</p> <ol> <li>Dispositivos de Campo: Sensores e atuadores que interagem diretamente com o processo f\u00edsico.</li> <li>Dispositivos de Controle: Equipamentos como CLPs e SDCDs que executam o controle automatizado.</li> <li>Esta\u00e7\u00f5es (Supervis\u00e3o): Sistemas de supervis\u00e3o e aquisi\u00e7\u00e3o de dados (SCADA) e Interfaces Homem-M\u00e1quina (IHM).</li> <li>Centro de Trabalho (Gerenciamento de planta): Sistemas de execu\u00e7\u00e3o de manufatura (MES) para gerenciar a produ\u00e7\u00e3o.</li> <li>Empresa (Gerenciamento corporativo): Sistemas de planejamento de recursos empresariais (ERP) que gerenciam o neg\u00f3cio como um todo.</li> </ol> <p>Essa hierarquia de automa\u00e7\u00e3o se reflete diretamente na estrutura das redes industriais, que s\u00e3o segmentadas em n\u00edveis funcionais para atender aos requisitos espec\u00edficos de cada camada.</p> <p>N\u00edvel 0: SensorBus</p> <ul> <li>Fun\u00e7\u00e3o: Conectar sensores e atuadores discretos e de baixo custo.</li> <li>Tipo de Dados: Bits.</li> <li>Velocidade: Comunica\u00e7\u00e3o r\u00e1pida, na ordem de dezenas de milissegundos.</li> <li>Dist\u00e2ncia: Pequenas dist\u00e2ncias, tipicamente dezenas de metros.</li> <li>Protocolos Exemplo: AS-Interface (ASi), Seriplex, CAN.</li> </ul> <p>N\u00edvel 0.5: DeviceBus</p> <ul> <li>Fun\u00e7\u00e3o: Distribuir perif\u00e9ricos de controle e conectar dispositivos um pouco mais complexos.</li> <li>Tipo de Dados: Bytes ou words.</li> <li>Velocidade: Comunica\u00e7\u00e3o r\u00e1pida, na ordem de dezenas de milissegundos, similar ao SensorBus, mas com maior capacidade de dados.</li> <li>Dist\u00e2ncia: Dist\u00e2ncias de at\u00e9 centenas de metros (ex: 500m).</li> <li>Protocolos Exemplo: DeviceNet, Profibus DP, Interbus.</li> </ul> <p>N\u00edvel 1: FieldBus</p> <ul> <li>Fun\u00e7\u00e3o: Conectar equipamentos de campo mais inteligentes e sistemas de controle.</li> <li>Tipo de Dados: Words ou blocos de dados.</li> <li>Velocidade: Comunica\u00e7\u00e3o mais lenta, na escala de centenas de milissegundos, mas capaz de trafegar dados mais complexos (discretos, anal\u00f3gicos, par\u00e2metros, etc.).</li> <li>Dist\u00e2ncia: Dist\u00e2ncias de centenas de metros.</li> <li>Protocolos Exemplo: Foundation Fieldbus, Modbus, Profibus PA, HART.</li> </ul> <p>N\u00edvel 2: DataBus</p> <ul> <li>Fun\u00e7\u00e3o: Realizar a transfer\u00eancia massiva de dados entre equipamentos de controle, sistemas de supervis\u00e3o e redes corporativas.</li> <li>Tipo de Dados: Blocos de dados ou arquivos.</li> <li>Velocidade: Comunica\u00e7\u00e3o mais lenta, na escala de segundos ou minutos, otimizada para grandes volumes de dados.</li> <li>Dist\u00e2ncia: Grandes dist\u00e2ncias (LAN, WAN, Internet).</li> <li>Protocolos Exemplo: Ethernet/IP, FDDI, MAP.</li> </ul> <p>Embora essa estrutura hier\u00e1rquica seja fundamental para entender a organiza\u00e7\u00e3o das redes industriais, o avan\u00e7o cont\u00ednuo de novas tecnologias est\u00e1 criando desafios e oportunidades emergentes que remodelam esse cen\u00e1rio.</p> <p>6.0 O Horizonte Futuro: Necessidades Emergentes e Desafios</p> <p>A cont\u00ednua evolu\u00e7\u00e3o tecnol\u00f3gica, impulsionada pela Ind\u00fastria 4.0, imp\u00f5e novas demandas e desafios \u00e0s redes industriais. Para se manterem relevantes e competitivos, os profissionais de automa\u00e7\u00e3o devem adotar uma abordagem proativa, antecipando as tend\u00eancias que definir\u00e3o o futuro da conectividade industrial.</p> <p>As principais necessidades emergentes e desafios incluem:</p> <ul> <li>Seguran\u00e7a Cibern\u00e9tica: A crescente conectividade, especialmente com a ado\u00e7\u00e3o da Internet Industrial das Coisas (IIoT) e do 5G, aumenta drasticamente a superf\u00edcie de ataque das plantas industriais. A ciberseguran\u00e7a deixa de ser um requisito de TI para se tornar uma prioridade cr\u00edtica e integrada em todos os n\u00edveis da rede de automa\u00e7\u00e3o.</li> <li>Ado\u00e7\u00e3o de IIoT e 5G: A combina\u00e7\u00e3o dessas tecnologias habilita capacidades transformadoras, como g\u00eameos digitais, manuten\u00e7\u00e3o preditiva em larga escala e opera\u00e7\u00f5es remotas com baixa lat\u00eancia. No entanto, sua implementa\u00e7\u00e3o apresenta desafios significativos de padroniza\u00e7\u00e3o e interoperabilidade, exigindo protocolos robustos e arquiteturas bem definidas.</li> <li>Intelig\u00eancia Artificial (IA): A IA representa uma tecnologia de dupla face. Por um lado, oferece oportunidades imensas para otimiza\u00e7\u00e3o de processos, controle aut\u00f4nomo e an\u00e1lise preditiva. Por outro, introduz novos vetores de ataque e desafios para a seguran\u00e7a dos dados. Sua integra\u00e7\u00e3o eficaz demanda esfor\u00e7os arquitet\u00f4nicos de longo prazo, guiados por frameworks de refer\u00eancia como RAMI 4.0, IIRA e OpenFog, para garantir a interoperabilidade e a seguran\u00e7a.</li> </ul> <p>Da mecaniza\u00e7\u00e3o da Ind\u00fastria 1.0 aos complexos sistemas ciberf\u00edsicos da Ind\u00fastria 4.0, a jornada da manufatura tem sido uma busca cont\u00ednua por maior efici\u00eancia e intelig\u00eancia. Nesse percurso, as redes industriais evolu\u00edram de uma necessidade operacional para se tornarem a base da competitividade estrat\u00e9gica. Dominar sua arquitetura, seus protocolos e seus desafios futuros n\u00e3o \u00e9 mais uma op\u00e7\u00e3o, mas sim um imperativo para qualquer profissional ou organiza\u00e7\u00e3o que aspire a liderar a transforma\u00e7\u00e3o digital no setor industrial.</p>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/02-classificacao_arquiteturas/","title":"Classifica\u00e7\u00e3o e Arquiteturas","text":"<p>Classifica\u00e7\u00e3o e arquiteturas</p> 1 Topologia f\u00edsica - Barramento; - Anel; - Estrela; - \u00c1rvore; - Misto. 2 Modelos de redes - Origem-Destino; - Produtor-Consumidor. 3 M\u00e9todo de troca de dados - Polling; - C\u00edclico; - Mudan\u00e7a de estado. 4 Tipo de conex\u00e3o - Ponto a ponto; - Multiplos pontoss. 5 Modo de transmiss\u00e3o - Serial;  - Paralelo. 6 Sincroniza\u00e7\u00e3o de bits - S\u00edncrona;  - Ass\u00edncrona. 7 Modo de opera\u00e7\u00e3o - Simplex;  - Half duplex;  - Full duplex. 8 Tipo de comunica\u00e7\u00e3o - Comuta\u00e7\u00e3o de circuitos;  - Comuta\u00e7\u00e3o de  pacotes. <p>An\u00e1lise Comparativa de Classifica\u00e7\u00f5es de Redes Industriais</p> <p>Introdu\u00e7\u00e3o</p> <p>A complexidade dos ambientes de automa\u00e7\u00e3o modernos exige uma compreens\u00e3o clara dos fundamentos que governam a comunica\u00e7\u00e3o entre dispositivos, desde o n\u00edvel de ch\u00e3o de f\u00e1brica at\u00e9 os sistemas de supervis\u00e3o.</p> <p>A compreens\u00e3o dessas classifica\u00e7\u00f5es \u2014 que abrangem desde a topologia f\u00edsica e os modelos l\u00f3gicos at\u00e9 os modos de transmiss\u00e3o e opera\u00e7\u00e3o \u2014 \u00e9 fundamental para a tomada de decis\u00f5es informadas no projeto e na arquitetura de sistemas de automa\u00e7\u00e3o. Uma escolha adequada de arquitetura garante n\u00e3o apenas o desempenho requerido pela aplica\u00e7\u00e3o, mas tamb\u00e9m a efici\u00eancia, a confiabilidade e a escalabilidade do sistema como um todo. Este relat\u00f3rio ir\u00e1 dissecar sistematicamente cada categoria de classifica\u00e7\u00e3o, detalhando suas variantes e implica\u00e7\u00f5es pr\u00e1ticas para o ambiente industrial.</p> <p>1.0 An\u00e1lise de Topologias F\u00edsicas</p> <p>A escolha da topologia f\u00edsica de uma rede industrial \u00e9 uma decis\u00e3o estrat\u00e9gica de projeto. O arranjo f\u00edsico dos n\u00f3s (dispositivos) e dos cabos que os interconectam impacta diretamente fatores cr\u00edticos como o custo de implementa\u00e7\u00e3o, a robustez do sistema a falhas, a facilidade de expans\u00e3o futura e o desempenho geral da comunica\u00e7\u00e3o. A seguir, analisamos as topologias mais comuns no contexto industrial.</p> <p>1.1 Topologia Barramento (Bus)</p> <p>A topologia de barramento, ou bus, \u00e9 caracterizada por uma estrutura onde todos os n\u00f3s compartilham um mesmo meio f\u00edsico de transmiss\u00e3o. Nessa configura\u00e7\u00e3o, a comunica\u00e7\u00e3o \u00e9 realizada de forma que apenas um dispositivo pode transmitir dados por vez, evitando colis\u00f5es de informa\u00e7\u00e3o.</p> <ul> <li>Caracter\u00edsticas Principais:</li> <li>Todos os n\u00f3s est\u00e3o conectados ao mesmo meio de comunica\u00e7\u00e3o.</li> <li>Apenas um n\u00f3 pode comunicar por vez.</li> <li>\u00c9 uma topologia muito utilizada na ind\u00fastria devido \u00e0 sua simplicidade.</li> <li>Apresenta um menor custo de implementa\u00e7\u00e3o em compara\u00e7\u00e3o com outras topologias.</li> </ul> <p>Esta simplicidade, no entanto, introduz um ponto \u00fanico de falha cr\u00edtico: uma quebra no cabo principal pode interromper a comunica\u00e7\u00e3o para todo o segmento da rede, um risco significativo em aplica\u00e7\u00f5es de miss\u00e3o cr\u00edtica.</p> <p>1.2 Topologia Anel (Ring)</p> <p>Utilizada em diversos sistemas de automa\u00e7\u00e3o industrial, a topologia em anel conecta os n\u00f3s em uma forma\u00e7\u00e3o circular fechada. Cada dispositivo se comunica diretamente com seus vizinhos imediatos, e a informa\u00e7\u00e3o circula pelo anel, sendo regenerada em cada n\u00f3 at\u00e9 chegar ao seu destino.</p> <ul> <li>Vantagens Estrat\u00e9gicas:</li> <li>Capacidade de transmitir dados para ambos os lados do anel.</li> <li>Possibilidade de implementa\u00e7\u00e3o com dupla redund\u00e2ncia, aumentando a toler\u00e2ncia a falhas.</li> <li>Garante que todos os n\u00f3s da rede recebam a informa\u00e7\u00e3o transmitida.</li> </ul> <p>A principal vantagem reside na sua alta resili\u00eancia quando implementada com redund\u00e2ncia, mas a adi\u00e7\u00e3o ou remo\u00e7\u00e3o de n\u00f3s pode exigir a interrup\u00e7\u00e3o tempor\u00e1ria da rede, e a lat\u00eancia aumenta linearmente com o n\u00famero de dispositivos no anel.</p> <p>1.3 Topologia Estrela (Star)</p> <p>Na topologia em estrela, todos os dispositivos s\u00e3o interligados a um equipamento central, como um concentrador ou switch, que centraliza e coordena toda a comunica\u00e7\u00e3o. Cada n\u00f3 possui um link dedicado ao ponto central, e a comunica\u00e7\u00e3o entre n\u00f3s perif\u00e9ricos deve, obrigatoriamente, passar por este equipamento.</p> <ul> <li>Vulnerabilidades e Limita\u00e7\u00f5es:</li> <li>Pontos de Falha: A opera\u00e7\u00e3o da rede \u00e9 vulner\u00e1vel a falhas tanto no n\u00f3 central (o que compromete toda a rede) quanto em um n\u00f3 de extremidade (que isola apenas aquele dispositivo).</li> <li>Limites de Expans\u00e3o: A capacidade de expans\u00e3o \u00e9 limitada pelo n\u00famero de portas dispon\u00edveis no equipamento central.</li> <li>Limites de Velocidade: A velocidade da rede pode ser limitada pela capacidade de processamento do n\u00f3 central.</li> <li>Custo de Implementa\u00e7\u00e3o: O custo de implementa\u00e7\u00e3o costuma ser mais elevado que o das topologias de barramento e anel devido \u00e0 necessidade do equipamento central e maior quantidade de cabeamento.</li> </ul> <p>Por outro lado, esta centraliza\u00e7\u00e3o simplifica drasticamente a detec\u00e7\u00e3o e o isolamento de falhas, pois um n\u00f3 ou cabo defeituoso pode ser desconectado do hub central sem impactar o restante da rede, um benef\u00edcio consider\u00e1vel para a manuten\u00e7\u00e3o.</p> <p>1.4 Topologia em \u00c1rvore (Tree)</p> <p>A topologia em \u00e1rvore pode ser vista como uma extens\u00e3o hier\u00e1rquica da topologia estrela. Ela conecta m\u00faltiplas redes em estrela a um barramento central ou a um n\u00f3 raiz, criando uma estrutura ramificada.</p> <ul> <li>Caracter\u00edsticas e Aplica\u00e7\u00f5es:</li> <li>Permite a segmenta\u00e7\u00e3o da rede em grupos de trabalho l\u00f3gicos e gerenci\u00e1veis.</li> <li>Facilita a expans\u00e3o da rede de forma estruturada, adicionando novas \"ramifica\u00e7\u00f5es\".</li> <li>A falha de um n\u00f3 afeta apenas sua pr\u00f3pria ramifica\u00e7\u00e3o, mas a falha de um n\u00f3 de n\u00edvel superior (especialmente a raiz) pode isolar grandes segmentos da rede.</li> </ul> <p>Esta topologia \u00e9 ideal para plantas industriais de grande porte, onde diferentes setores ou linhas de produ\u00e7\u00e3o podem ser organizados como ramos distintos da rede principal.</p> <p>Al\u00e9m destas, topologias como Malha (Mesh), onde os n\u00f3s se interconectam diretamente com m\u00faltiplos outros n\u00f3s para m\u00e1xima redund\u00e2ncia, e Mista (Hybrid), que combina caracter\u00edsticas de duas ou mais topologias, s\u00e3o empregadas para atender a requisitos espec\u00edficos de confiabilidade e escalabilidade. Embora a topologia f\u00edsica defina o layout da infraestrutura, s\u00e3o os modelos l\u00f3gicos de comunica\u00e7\u00e3o que ditam como os dados s\u00e3o efetivamente trocados entre os dispositivos.</p> <p>2.0 An\u00e1lise de Modelos de Comunica\u00e7\u00e3o de Redes</p> <p>Os modelos de comunica\u00e7\u00e3o definem a arquitetura l\u00f3gica e a hierarquia da troca de informa\u00e7\u00f5es em uma rede industrial. Eles estabelecem as regras de intera\u00e7\u00e3o, determinando como os dispositivos iniciam a comunica\u00e7\u00e3o, acessam os dados e respondem a solicita\u00e7\u00f5es, independentemente do arranjo f\u00edsico dos cabos.</p> <p>2.1 Modelos Origem/Destino e Mestre/Escravo</p> <p>O modelo fundamental de comunica\u00e7\u00e3o \u00e9 o Origem/Destino (Source/Destination), no qual as mensagens s\u00e3o explicitamente endere\u00e7adas de um n\u00f3 de origem para um n\u00f3 de destino espec\u00edfico. A rede garante a entrega da mensagem ao destinat\u00e1rio endere\u00e7ado.</p> <p>Uma implementa\u00e7\u00e3o hier\u00e1rquica e especializada deste conceito \u00e9 o modelo Mestre/Escravo (Master/Slave). Nesta arquitetura, um dispositivo \"Mestre\" (Master) controla a rede, sendo o \u00fanico a iniciar todas as transa\u00e7\u00f5es e enviar requisi\u00e7\u00f5es aos dispositivos \"Escravos\" (Slaves).</p> <ul> <li>Papel do Escravo: O \"escravo\" \u00e9 um dispositivo perif\u00e9rico passivo \u2014 como sensores, atuadores ou inversores de frequ\u00eancia \u2014 cuja fun\u00e7\u00e3o \u00e9 exclusivamente responder a requisi\u00e7\u00f5es diretas vindas do mestre.</li> <li>Varia\u00e7\u00f5es: Uma rede pode operar com um \u00fanico mestre (monomestre) ou com v\u00e1rios mestres no mesmo barramento (multimestre), embora o acesso ao meio ainda precise ser coordenado.</li> </ul> <p>Este modelo oferece simplicidade e determinismo, mas sua principal limita\u00e7\u00e3o \u00e9 que os escravos n\u00e3o podem iniciar a comunica\u00e7\u00e3o, mesmo que possuam dados cr\u00edticos para reportar, devendo aguardar a interroga\u00e7\u00e3o do mestre.</p> <p>2.2 Modelo Produtor/Consumidor (Producer/Consumer)</p> <p>O modelo Produtor/Consumidor (Producer/Consumer) opera sob um princ\u00edpio de comunica\u00e7\u00e3o orientada a dados, e n\u00e3o a dispositivos. Neste modelo, os pacotes de dados recebem um identificador \u00fanico (como um Connection ID ou CAN ID) que os associa a uma informa\u00e7\u00e3o espec\u00edfica, n\u00e3o a um dispositivo de destino.</p> <p>O processo de comunica\u00e7\u00e3o se d\u00e1 quando um n\u00f3 \"Produtor\" publica os dados na rede. Qualquer n\u00f3 \"Consumidor\" que tenha sido configurado para \"assinar\" aquele identificador de dados espec\u00edfico ir\u00e1 receb\u00ea-lo e process\u00e1-lo. Este mecanismo resulta em uma significativa economia de banda, pois as informa\u00e7\u00f5es s\u00e3o transmitidas uma \u00fanica vez e consumidas por m\u00faltiplos n\u00f3s interessados, sem a necessidade de envios individuais. Este modelo \u00e9 altamente eficiente e flex\u00edvel, mas pode exigir uma configura\u00e7\u00e3o mais complexa para gerenciar as associa\u00e7\u00f5es entre produtores e consumidores.</p> <p>Embora os modelos Mestre/Escravo e Produtor/Consumidor sejam prevalentes em redes de ch\u00e3o de f\u00e1brica, outros modelos como Cliente/Servidor, baseados em filas ou em tabelas de comunica\u00e7\u00e3o, tamb\u00e9m existem em contextos industriais, tipicamente em n\u00edveis mais altos da pir\u00e2mide de automa\u00e7\u00e3o (MES, ERP). A escolha do modelo de comunica\u00e7\u00e3o influencia diretamente os m\u00e9todos pelos quais os dados s\u00e3o consultados e transmitidos na rede.</p> <p>3.0 An\u00e1lise de M\u00e9todos de Troca de Dados</p> <p>O m\u00e9todo de troca de dados determina o gatilho para a transmiss\u00e3o de informa\u00e7\u00f5es entre os dispositivos. Essa escolha impacta criticamente a efici\u00eancia do uso da banda de rede, o determinismo (previsibilidade do tempo de entrega de mensagens) e a lat\u00eancia da comunica\u00e7\u00e3o, fatores essenciais em sistemas de controle em tempo real.</p> <p>3.1 Polling</p> <p>No m\u00e9todo de Polling (ou varredura), a comunica\u00e7\u00e3o \u00e9 iniciada por um dispositivo mestre, que interroga sequencialmente cada um dos dispositivos escravos na rede para solicitar dados ou enviar comandos. O escravo s\u00f3 transmite informa\u00e7\u00f5es quando \"questionado\" pelo mestre.</p> <ul> <li>Caracter\u00edsticas e Compatibilidades:</li> <li>Compatibilidade: \u00c9 compat\u00edvel com sistemas Mestre/Escravo e Multimestre.</li> <li>Base de Desenvolvimento: Constru\u00eddo sobre os modelos de comunica\u00e7\u00e3o Origem/Destino e Mestre/Escravo.</li> <li>Limita\u00e7\u00e3o: \u00c9 inerentemente um m\u00e9todo ponto a ponto, n\u00e3o oferecendo suporte a multicast.</li> </ul> <p>O Polling garante um alto n\u00edvel de determinismo, pois o mestre controla todo o tr\u00e1fego. Contudo, pode ser ineficiente se os dados nos escravos mudarem com pouca frequ\u00eancia, consumindo largura de banda para consultar informa\u00e7\u00f5es inalteradas.</p> <p>3.2 C\u00edclico (Cyclic)</p> <p>No m\u00e9todo C\u00edclico, os dispositivos s\u00e3o configurados para produzir e transmitir dados em intervalos de tempo pr\u00e9-definidos pelo usu\u00e1rio. Cada n\u00f3 opera com uma taxa de atualiza\u00e7\u00e3o espec\u00edfica, adequada \u00e0 sua fun\u00e7\u00e3o no processo.</p> <ul> <li>Fatores de Efici\u00eancia:</li> <li>Permite que os dados sejam transferidos a uma taxa adequada para cada dispositivo ou aplica\u00e7\u00e3o.</li> <li>Preserva recursos de rede, pois dispositivos que geram dados com alta varia\u00e7\u00e3o podem ter taxas mais altas, enquanto outros, mais lentos, utilizam menos banda.</li> <li>Proporciona um bom determinismo, j\u00e1 que a transmiss\u00e3o ocorre em intervalos regulares.</li> <li>\u00c9 compat\u00edvel com os modelos Mestre/Escravo, Multimestre, \"peer-to-peer\" e Multicast.</li> </ul> <p>Este m\u00e9todo oferece um excelente equil\u00edbrio entre determinismo e efici\u00eancia para a maioria das aplica\u00e7\u00f5es de controle, embora ainda possa haver desperd\u00edcio de banda se os dados permanecerem constantes entre os ciclos de transmiss\u00e3o.</p> <p>3.3 Mudan\u00e7a de Estado (Change of State)</p> <p>O m\u00e9todo de Mudan\u00e7a de Estado \u00e9 projetado para otimizar ao m\u00e1ximo o uso da rede. A transmiss\u00e3o de dados ocorre apenas quando o estado de um dispositivo \u00e9 alterado, ou seja, quando h\u00e1 uma nova informa\u00e7\u00e3o relevante a ser comunicada. Para garantir que um dispositivo silencioso ainda est\u00e1 funcional, um sinal de Heartbeat \u00e9 transmitido ciclicamente para confirmar que ele continua operacional.</p> <ul> <li>Benef\u00edcios de Efici\u00eancia:</li> <li>Reduz significativamente o tr\u00e1fego da rede, pois elimina transmiss\u00f5es redundantes.</li> <li>Evita o desperd\u00edcio de recursos de processamento, pois os dispositivos n\u00e3o precisam processar dados antigos que n\u00e3o foram alterados.</li> </ul> <p>Esta abordagem \u00e9 a mais eficiente em termos de largura de banda, mas sacrifica o determinismo temporal estrito, pois o instante da transmiss\u00e3o depende do processo e n\u00e3o de um ciclo de rel\u00f3gio fixo.</p> <p>Estes m\u00e9todos de troca de dados s\u00e3o suportados por diferentes naturezas de conex\u00f5es f\u00edsicas que os sustentam.</p> <p>4.0 An\u00e1lise de Tipos de Conex\u00e3o</p> <p>O tipo de conex\u00e3o descreve a forma como os dispositivos s\u00e3o ligados a um meio de transmiss\u00e3o. A escolha entre um link dedicado ou compartilhado tem implica\u00e7\u00f5es diretas na aloca\u00e7\u00e3o de largura de banda, na complexidade da instala\u00e7\u00e3o f\u00edsica, no custo e na resili\u00eancia da rede a falhas de equipamentos.</p> <p>4.1 Conex\u00e3o Ponto a Ponto (Point-to-Point)</p> <p>Uma conex\u00e3o ponto a ponto estabelece um link de comunica\u00e7\u00e3o dedicado que conecta apenas dois dispositivos. N\u00e3o h\u00e1 compartilhamento do meio f\u00edsico com outros n\u00f3s.</p> <ul> <li>Atributos:</li> <li>Instala\u00e7\u00e3o f\u00e1cil e pr\u00e1tica.</li> <li>Modelo de f\u00e1cil entendimento.</li> <li>N\u00e3o h\u00e1 divis\u00e3o de banda, o que contribui para a estabilidade e previsibilidade da conex\u00e3o.</li> </ul> <p>Este tipo de conex\u00e3o \u00e9 ideal para links de comunica\u00e7\u00e3o cr\u00edticos e de alta velocidade entre dois equipamentos espec\u00edficos, como um CLP e um sistema de I/O remoto principal.</p> <p>4.2 Conex\u00e3o M\u00faltiplos Pontos (Multipoint/Multicast)</p> <p>Na conex\u00e3o de m\u00faltiplos pontos, um \u00fanico link f\u00edsico \u00e9 compartilhado por diversos dispositivos. Esta topologia de meio compartilhado \u00e9 a base para a comunica\u00e7\u00e3o Multicast, onde uma \u00fanica mensagem pode ser recebida por m\u00faltiplos (mas n\u00e3o necessariamente todos) os n\u00f3s.</p> <ul> <li>Caracter\u00edsticas Principais:</li> <li>A largura de banda do link \u00e9 dividida entre todos os dispositivos conectados.</li> <li>Instala\u00e7\u00e3o geralmente f\u00e1cil e de baixo custo.</li> <li>Alta confiabilidade e resili\u00eancia, pois a falha de um dos equipamentos da rede n\u00e3o causa a interrup\u00e7\u00e3o da conex\u00e3o para os outros dispositivos no barramento.</li> </ul> <p>Esta abordagem \u00e9 extremamente econ\u00f4mica em termos de cabeamento, mas requer um protocolo de acesso ao meio para gerenciar o compartilhamento da banda e evitar colis\u00f5es.</p> <p>Al\u00e9m do tipo de conex\u00e3o, o modo como os bits de dados s\u00e3o enviados atrav\u00e9s do meio f\u00edsico \u00e9 outra camada fundamental da arquitetura de comunica\u00e7\u00e3o.</p> <p>5.0 An\u00e1lise de Modos de Transmiss\u00e3o</p> <p>O modo de transmiss\u00e3o refere-se \u00e0 maneira como os bits de informa\u00e7\u00e3o s\u00e3o enviados atrav\u00e9s do canal de comunica\u00e7\u00e3o. A escolha entre enviar m\u00faltiplos bits simultaneamente ou um de cada vez define uma rela\u00e7\u00e3o fundamental entre velocidade de transmiss\u00e3o, custo do cabeamento e complexidade da interconex\u00e3o f\u00edsica.</p> <p>5.1 Transmiss\u00e3o Paralela</p> <p>Na transmiss\u00e3o paralela, um conjunto de bits (como um byte de 8 bits) \u00e9 enviado simultaneamente atrav\u00e9s de v\u00e1rias vias ou fios condutores. Embora ofere\u00e7a alt\u00edssima taxa de transfer\u00eancia em curtas dist\u00e2ncias, \u00e9 impratic\u00e1vel em ambientes industriais devido ao alto custo do cabeamento e \u00e0 suscetibilidade a ru\u00eddo (crosstalk) e desalinhamento de clock (skew) em cabos longos.</p> <p>5.2 Transmiss\u00e3o Serial</p> <p>Na transmiss\u00e3o serial, os bits s\u00e3o enviados um ap\u00f3s o outro, em sequ\u00eancia, pelo mesmo meio f\u00edsico. Este m\u00e9todo \u00e9 o padr\u00e3o para praticamente todas as redes industriais.</p> <ul> <li>Vantagens em Aplica\u00e7\u00f5es Industriais:</li> <li>Economia na Interconex\u00e3o: Requer menos fios, resultando em cabos mais simples, de menor custo e mais robustos.</li> <li>Maior Velocidade em Longas Dist\u00e2ncias: Surpreendentemente, em longas dist\u00e2ncias comuns no ch\u00e3o de f\u00e1brica, a transmiss\u00e3o serial atinge velocidades superiores, pois \u00e9 imune aos problemas de ru\u00eddo (crosstalk) e desalinhamento de clock (skew) que degradam sinais paralelos.</li> </ul> <p>A transmiss\u00e3o de bits, seja ela serial ou paralela, requer um mecanismo de sincroniza\u00e7\u00e3o para que o receptor possa interpretar o fluxo de dados corretamente.</p> <p>6.0 An\u00e1lise de Sincroniza\u00e7\u00e3o de Bits</p> <p>Para que o dispositivo receptor interprete corretamente um fluxo de dados recebido, ele precisa saber exatamente quando cada bit come\u00e7a e termina. A sincroniza\u00e7\u00e3o de bits \u00e9 o mecanismo que estabelece um acordo sobre o tempo de cada bit. Este alinhamento temporal \u00e9 alcan\u00e7ado atrav\u00e9s de m\u00e9todos s\u00edncronos ou ass\u00edncronos.</p> <p>6.1 Transmiss\u00e3o S\u00edncrona</p> <p>Na transmiss\u00e3o s\u00edncrona, um sinal de temporiza\u00e7\u00e3o, conhecido como clock, \u00e9 enviado por um circuito separado, paralelamente ao sinal de dados. Cada pulso do sinal de clock marca o intervalo de tempo exato de um bit, garantindo uma sincroniza\u00e7\u00e3o perfeita. Este m\u00e9todo \u00e9 altamente eficiente para a transfer\u00eancia de grandes blocos de dados, mas o circuito de clock adicional aumenta o custo e a complexidade do cabeamento.</p> <p>6.2 Transmiss\u00e3o Ass\u00edncrona</p> <p>A transmiss\u00e3o ass\u00edncrona n\u00e3o utiliza um sinal de clock externo. Em vez disso, a sincroniza\u00e7\u00e3o \u00e9 feita por caractere ou byte. Cada bloco de dados \u00e9 enquadrado por um \"bit de in\u00edcio\" (start bit) e um ou mais \"bits de parada\" (stop bits). Opcionalmente, um bit de paridade pode ser inclu\u00eddo no quadro para detec\u00e7\u00e3o de erros b\u00e1sicos. Este m\u00e9todo, associado ao conceito de Baud rate (taxa de s\u00edmbolos por segundo), \u00e9 mais simples e barato de implementar, sendo ideal para comunica\u00e7\u00e3o intermitente, mas o overhead dos bits de enquadramento reduz a taxa de transfer\u00eancia efetiva de dados.</p> <p>Al\u00e9m da sincroniza\u00e7\u00e3o, a direcionalidade do fluxo de dados \u00e9 outra caracter\u00edstica fundamental que define a comunica\u00e7\u00e3o.</p> <p>7.0 An\u00e1lise de Modos de Opera\u00e7\u00e3o</p> <p>Os modos de opera\u00e7\u00e3o classificam a comunica\u00e7\u00e3o com base na direcionalidade do fluxo de informa\u00e7\u00f5es entre dois dispositivos. Eles determinam se a transmiss\u00e3o pode ocorrer em um ou em ambos os sentidos e, no segundo caso, se essa comunica\u00e7\u00e3o bidirecional pode ser simult\u00e2nea.</p> <p>Em redes maiores, com m\u00faltiplos caminhos poss\u00edveis, a forma como as conex\u00f5es s\u00e3o estabelecidas e os dados s\u00e3o roteados define o tipo de comuta\u00e7\u00e3o utilizado.</p> <p>8.0 An\u00e1lise de Tipos de Comuta\u00e7\u00e3o</p> <p>Para que os dados possam atravessar uma rede composta por m\u00faltiplos n\u00f3s e caminhos, s\u00e3o necess\u00e1rias estrat\u00e9gias para estabelecer rotas entre a origem e o destino. A comuta\u00e7\u00e3o \u00e9 o processo que gerencia esse roteamento. As duas principais abordagens s\u00e3o a comuta\u00e7\u00e3o de circuitos e a comuta\u00e7\u00e3o de pacotes.</p> <p>8.1 Comuta\u00e7\u00e3o de Circuitos</p> <p>A comuta\u00e7\u00e3o de circuitos \u00e9 um m\u00e9todo onde uma conex\u00e3o f\u00edsica dedicada e exclusiva \u00e9 estabelecida entre a origem e o destino antes do in\u00edcio da transfer\u00eancia de dados. Este circuito permanece ativo durante toda a sess\u00e3o, garantindo uma taxa de transmiss\u00e3o constante e lat\u00eancia m\u00ednima. Embora ideal para dados sens\u00edveis ao tempo, como voz, \u00e9 ineficiente para o tr\u00e1fego de dados t\u00edpico, pois a largura de banda fica alocada mesmo durante os per\u00edodos de sil\u00eancio.</p> <p>8.2 Comuta\u00e7\u00e3o de Pacotes</p> <p>Na comuta\u00e7\u00e3o de pacotes, a mensagem original \u00e9 dividida em blocos menores, chamados pacotes. Cada pacote cont\u00e9m informa\u00e7\u00f5es de endere\u00e7amento e \u00e9 enviado pela rede de forma independente, podendo seguir rotas diferentes at\u00e9 o destino, onde a mensagem \u00e9 reconstru\u00edda. Esta abordagem, base da Internet e das redes Ethernet industriais, permite um uso altamente eficiente dos recursos da rede. No entanto, pode introduzir varia\u00e7\u00f5es na lat\u00eancia (jitter), o que representa um desafio de engenharia para aplica\u00e7\u00f5es de controle em tempo real.</p> <p>Esta an\u00e1lise completa as principais categorias de classifica\u00e7\u00e3o que definem a arquitetura de uma rede.</p> <p>\u00c9 crucial entender que essas categorias n\u00e3o s\u00e3o mutuamente exclusivas; pelo contr\u00e1rio, elas formam um conjunto de caracter\u00edsticas que, quando combinadas, definem a arquitetura completa de uma rede industrial espec\u00edfica. O dom\u00ednio deste framework de classifica\u00e7\u00e3o \u00e9, portanto, essencial para que engenheiros e arquitetos de sistemas possam projetar, implementar e otimizar solu\u00e7\u00f5es de rede que atendam com precis\u00e3o aos rigorosos requisitos de desempenho, custo e confiabilidade exigidos pelas modernas aplica\u00e7\u00f5es de automa\u00e7\u00e3o industrial.</p>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/03-dimensionamento/","title":"Crit\u00e9rios para dimensionamento","text":"<p>Crit\u00e9rios para dimensionamento</p> <ul> <li>Meio f\u00edsico de comunica\u00e7\u00e3o;</li> <li>Cobertura geogr\u00e1fica;</li> <li>M\u00e9todo de acesso;</li> <li>Desempenho: Velocidade x Throughput;</li> <li>Confiabilidade: Determin\u00edstico x Probabil\u00edstico;</li> <li>Protocolo de comunica\u00e7\u00e3o.</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/04-modelo_osi_iso/","title":"Modelo OSI/ISO","text":"<p>Modelo OSI/ISO</p> <ul> <li>Caracter\u00edsticas do Modelo</li> <li>Camada 7 - Aplica\u00e7\u00e3o</li> <li>Camada 6 - Apresenta\u00e7\u00e3o</li> <li>Camada 5 - Sess\u00e3o</li> <li>Camada 4 - Transporte</li> <li>Camada 3 - Rede</li> <li>Camada 2 - Enlace</li> <li>Camada 1 - F\u00edsica</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/05-meio_fisico/","title":"Meio F\u00edsico","text":"<p>Meio F\u00edsico  RS232/RS485/RS422</p> <ul> <li>RS232<ul> <li>Conectores e pinagem;</li> <li>Caracter\u00edsticas el\u00e9tricas;</li> <li>Dist\u00e2ncia e baud rate;</li> <li>Controle de fluxo por hardware;</li> <li>Transceiver - MAX232.</li> </ul> </li> <li>RS485<ul> <li>Aplica\u00e7\u00e3o;</li> <li>Topologias;</li> <li>Par diferencial e n\u00edveis de tens\u00e3o;</li> <li>Resistor de termina\u00e7\u00e3o;</li> <li>Dist\u00e2ncia e velocidade de comunica\u00e7\u00e3o;</li> <li>Multiponto;</li> <li>Transceivers comerciais.</li> </ul> </li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/06-protocolos_comunicacao/","title":"Protocolos de Comunica\u00e7\u00e3o","text":"<p>Protocolo de comunica\u00e7\u00e3o  MODBUS</p> <ul> <li>Introdu\u00e7\u00e3o;</li> <li>Modicon, protocolo aberto;</li> <li>Conex\u00e3o e cabo de transmiss\u00e3o;</li> <li>Modbus e modelo ISO/OSI;</li> <li>Cliente-Servidor - Unicast x Broadcast;</li> <li>Codifica\u00e7\u00e3o da mensagem - RTU e Ascii;</li> <li>Modelo de organiza\u00e7\u00e3o da mem\u00f3ria;</li> <li>Unidade de dados de protocolo (PDU);</li> <li>Frame e temporiza\u00e7\u00e3o em modo RTU;</li> <li>Codifica\u00e7\u00e3o da mensagem.</li> </ul> <p>Principais protocolos de comunica\u00e7\u00e3o industriais</p> <ol> <li>Modbus: Um dos protocolos mais antigos e difundidos, estabelecendo um padr\u00e3o para a troca de dados em sistemas de automa\u00e7\u00e3o.</li> <li>Profibus: Desenvolvido pela Siemens, \u00e9 um protocolo de comunica\u00e7\u00e3o de campo para automa\u00e7\u00e3o de processos, permitindo a troca de dados entre dispositivos e controladores.\u00a0</li> <li>Profinet:  A evolu\u00e7\u00e3o do Profibus, \u00e9 um protocolo de Ethernet Industrial que permite uma comunica\u00e7\u00e3o mais r\u00e1pida e eficiente, suportando a arquitetura da Ind\u00fastria 4.0.\u00a0</li> <li>Ethernet/IP: Um protocolo de Ethernet Industrial suportado pela ODVA, amplamente utilizado para comunica\u00e7\u00e3o de aplica\u00e7\u00f5es e controle.\u00a0</li> <li>CANopen: Baseado no CAN (Controller Area Network), \u00e9 um protocolo de comunica\u00e7\u00e3o em tempo real utilizado em sistemas de automa\u00e7\u00e3o, rob\u00f3tica e equipamentos automotivos.\u00a0</li> <li>DeviceNet: Um protocolo de automa\u00e7\u00e3o que permite a conex\u00e3o e comunica\u00e7\u00e3o de dispositivos no ch\u00e3o de f\u00e1brica.\u00a0</li> <li>EtherCAT: Um protocolo de Ethernet Industrial de alta performance, conhecido por sua velocidade e efici\u00eancia em aplica\u00e7\u00f5es de controle de movimento.\u00a0</li> <li>HART: Faz comunica\u00e7\u00e3o digital bidirecional usando loops de corrente anal\u00f3gica. Auxilia na calibra\u00e7\u00e3o e no ajuste de damping e range de diversos dispositivos industriais, como sensores e atuadores.</li> <li>ASi: Para projetos de automa\u00e7\u00e3o \u00e9 um protocolo pr\u00e1tico e barato, ideal para maquin\u00e1rio de pequeno porte, realizando a conectividade digital de atuadores e sensores com os seus respectivos controladores.</li> <li>Zigbee: \u00c9 um protocolo de comunica\u00e7\u00e3o sem fio projetado para dispositivos de baixo consumo de energia e baixa taxa de dados, ideal para automa\u00e7\u00e3o residencial e industrial, como sensores e l\u00e2mpadas inteligentes.</li> <li>OPC UA (Open Platform Communications Unified Architecture): Um padr\u00e3o de comunica\u00e7\u00e3o aberto e seguro para a troca de dados, que se baseia na tecnologia bin\u00e1ria para garantir a interoperabilidade entre diversos dispositivos e sistemas.\u00a0</li> <li>MQTT (Message Queue Telemetry Transport): Um protocolo leve e flex\u00edvel, ideal para sistemas de IoT, com baixo consumo de energia e aplic\u00e1vel em dispositivos com restri\u00e7\u00f5es de hardware e redes com banda limitada.\u00a0</li> <li>IO-Link: Uma interface padr\u00e3o aberta para sensores e atuadores, que permite a comunica\u00e7\u00e3o bidirecional e fornece dados detalhados sobre o status dos dispositivos, sendo crucial para a manuten\u00e7\u00e3o preditiva.</li> </ol>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/07-wireless/","title":"Redes sem fio","text":"<p>Rede sem fio industrial</p> <ul> <li>Introdu\u00e7\u00e3o;</li> <li>Wi-Fi;</li> <li>Bluetooth;</li> <li>Redes de Sensores Sem Fio (RSSF);</li> <li>Fatores determinantes em redes sem fio;</li> <li>Pr\u00e1ticas recomendadas.</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/redes/tecnologia/08-iiot/","title":"IoT Industrial","text":"<p>IIoT</p> <ul> <li>Ind\u00fastria 4.0;</li> <li>Modelo hier\u00e1rquico ISA95;</li> <li>Mudan\u00e7a de paradigma com dados;</li> <li>IoT x IIoT;</li> <li>Tecnologias de IIoT:<ul> <li>Intelig\u00eancia artificial;</li> <li>Seguran\u00e7a cibern\u00e9tica;</li> <li>Computa\u00e7\u00e3o em nuvem;</li> <li>Computa\u00e7\u00e3o de borda;</li> <li>Minera\u00e7\u00e3o e An\u00e1lise de Dados;</li> <li>Desafios da IIoT.</li> </ul> </li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/scada/tecnologia/01-conceito/","title":"SCADA","text":"<p>Sistemas SCADA - Introdu\u00e7\u00e3o</p> <p>Como grandes opera\u00e7\u00f5es, como usinas de energia, redes de saneamento ou linhas de produ\u00e7\u00e3o complexas, s\u00e3o gerenciadas de forma centralizada e eficiente? A tecnologia chave para tudo isso \u00e9 chamada de SCADA.</p> <p>1. O Que \u00e9 um Sistema SCADA?</p> <p>O termo que voc\u00ea encontrar\u00e1 em toda a ind\u00fastria \u00e9 SCADA. Este acr\u00f4nimo representa Supervisory Control and Data Acquisition, que em portugu\u00eas se traduz como Controle Supervis\u00f3rio e Aquisi\u00e7\u00e3o de Dados.</p> <p>\u00c9 comum encontrar outros nomes para se referir a essa tecnologia, como:</p> <ul> <li>Sistema Supervis\u00f3rio</li> <li>Sistema de Monitoramento Remoto</li> <li>Sistema de Supervis\u00e3o Remota</li> <li>Software SCADA</li> </ul> <p>Em termos simples, um sistema SCADA \u00e9 um tipo de software projetado para permitir que um operador humano monitore e controle processos industriais ou infraestruturas, mesmo que estejam espalhados por grandes dist\u00e2ncias. De um centro de comando de uma planta industrial, uma \u00fanica sala com v\u00e1rias telas, os operadores podem ver o status de todos os sistemas, monitorar dados vitais em tempo real e enviar comandos para fazer ajustes, tudo isso sem precisar estar fisicamente nos locais dos sensores ou atuadores. O SCADA oferece essa capacidade de vis\u00e3o e controle para uma f\u00e1brica inteira. A Figura 1 ilustra uma tela de processo no sistema Scada Indusoft. </p> Figura 1: Exemplos de SCADA - Indusoft <p>2. Por Que o SCADA \u00e9 Essencial? Os Objetivos e Benef\u00edcios</p> <p>Os sistemas SCADA n\u00e3o s\u00e3o apenas sobre conveni\u00eancia, eles s\u00e3o projetados com objetivos claros que trazem benef\u00edcios tang\u00edveis para qualquer opera\u00e7\u00e3o,  e quando bem implementados, atingem objetivos fundamentais, que s\u00e3o a base de sua funcionalidade: </p> <ul> <li>Comunica\u00e7\u00e3o Multi-protocolo: Garantir a capacidade de se conectar e coletar dados de equipamentos de diversos fabricantes, que \"falam\" linguagens (protocolos) diferentes, unificando a comunica\u00e7\u00e3o.</li> <li>Interface Gr\u00e1fica para Opera\u00e7\u00e3o: Apresentar dados em tempo real atrav\u00e9s de telas intuitivas (sin\u00f3ticos, gr\u00e1ficos, dashboards) que permitem ao operador n\u00e3o s\u00f3 visualizar, mas tamb\u00e9m controlar o processo remotamente.</li> <li>Registro de Eventos e Relat\u00f3rios Hist\u00f3ricos: Armazenar dados e ocorr\u00eancias do sistema para criar relat\u00f3rios detalhados, essenciais para an\u00e1lise de performance, rastreabilidade e otimiza\u00e7\u00e3o de processos.</li> <li>Gerenciamento de Alarmes Configur\u00e1veis: Notificar os operadores sobre condi\u00e7\u00f5es anormais ou falhas de forma imediata, permitindo uma resposta r\u00e1pida para garantir a seguran\u00e7a e a estabilidade da opera\u00e7\u00e3o.</li> </ul> <p>Ao alcan\u00e7ar esses objetivos, os sistemas SCADA geram um impacto direto e positivo nos resultados do neg\u00f3cio:</p> <ol> <li>Aumento da efici\u00eancia operacional<ul> <li>A centraliza\u00e7\u00e3o do controle e a vis\u00e3o completa do processo permitem tomar decis\u00f5es mais r\u00e1pidas e inteligentes, otimizando a produ\u00e7\u00e3o.</li> </ul> </li> <li>Redu\u00e7\u00e3o de custos<ul> <li>Ao monitorar o uso de recursos e prevenir falhas e paradas de produ\u00e7\u00e3o dispendiosas, o SCADA ajuda a economizar energia, mat\u00e9ria-prima e custos de manuten\u00e7\u00e3o.</li> </ul> </li> <li>Melhoria na qualidade do produto<ul> <li>O controle preciso e imediato de vari\u00e1veis como temperatura e press\u00e3o garante que o processo se mantenha dentro das especifica\u00e7\u00f5es ideais, resultando em um produto final mais consistente e de maior qualidade.</li> </ul> </li> <li>Seguran\u00e7a industrial<ul> <li>A detec\u00e7\u00e3o antecipada de condi\u00e7\u00f5es perigosas e a capacidade de operar equipamentos remotamente reduzem a exposi\u00e7\u00e3o dos trabalhadores a ambientes de risco.</li> </ul> </li> </ol> <p>Para alcan\u00e7ar esses benef\u00edcios, o sistema SCADA depende de uma arquitetura bem definida que conecta o software \u00e0 opera\u00e7\u00e3o f\u00edsica. A figura 2 ilustra uma tela no software Scada Aveva, que anteriormente era conhecida como Indusoft, dominante no mercado industrial. </p> Figura 2: Ilustra\u00e7\u00e3o de software Scada Aveva, antiga Indusoft <p>3. A Arquitetura de um Sistema SCADA</p> <p>Um sistema SCADA n\u00e3o funciona sozinho. Ele \u00e9 a camada superior de uma arquitetura de automa\u00e7\u00e3o que pode ser dividida em tr\u00eas n\u00edveis.</p> <ol> <li>Sistema SCADA<ul> <li>Esta \u00e9 a camada de software e hardware (computadores e servidores) onde tudo acontece para o operador. \u00c9 aqui que os dados s\u00e3o apresentados em telas gr\u00e1ficas, conhecidas como Interface Homem-M\u00e1quina (HMI), e de onde os comandos de controle s\u00e3o enviados.</li> </ul> </li> <li>Controladores<ul> <li>Esta camada intermedi\u00e1ria \u00e9 composta por equipamentos como os CLPs (Controladores L\u00f3gicos Program\u00e1veis). Eles recebem os comandos do SCADA e executam a l\u00f3gica de controle localmente, tomando decis\u00f5es em tempo real para gerenciar os equipamentos de campo.</li> </ul> </li> <li>Atuadores e Sensores<ul> <li>Esta \u00e9 a camada de campo, onde a a\u00e7\u00e3o f\u00edsica ocorre. Os sensores (de temperatura, press\u00e3o, n\u00edvel) coletam os dados do processo e os enviam para os controladores. Os atuadores (motores, v\u00e1lvulas, bombas) recebem os comandos dos controladores e executam as a\u00e7\u00f5es f\u00edsicas.</li> </ul> </li> </ol> <p>A Figura 3 ilustra uma planta industrial com sistema supervis\u00f3rio Elipse, um dos mais populares no mercado. </p> Figura 3: Infraestrutura de uma planta industrial com sistema supervis\u00f3rio Fonte: Elipse <p>4. Aplica\u00e7\u00f5es no Mundo Real</p> <p>Devido \u00e0 sua capacidade de gerenciar opera\u00e7\u00f5es complexas e geograficamente distribu\u00eddas, os sistemas SCADA s\u00e3o onipresentes em setores vitais para a sociedade.</p> <p>Os sistemas SCADA s\u00e3o a espinha dorsal do monitoramento de infraestruturas essenciais, incluindo:</p> <ul> <li>Energia el\u00e9trica (gera\u00e7\u00e3o e distribui\u00e7\u00e3o)</li> <li>G\u00e1s (transporte e distribui\u00e7\u00e3o)</li> <li>\u00c1gua (esta\u00e7\u00f5es de tratamento e redes de saneamento)</li> <li>Petr\u00f3leo (refinarias e oleodutos)</li> </ul> <p>Dentro do ambiente industrial, o SCADA desempenha pap\u00e9is cruciais em diversas frentes:</p> <ol> <li>Monitoramento de Processos<ul> <li>Permite o acompanhamento instant\u00e2neo de todas as a\u00e7\u00f5es na linha de produ\u00e7\u00e3o. Ao organizar e gerenciar todas as vari\u00e1veis em telas intuitivas, o sistema facilita a compreens\u00e3o e permite a corre\u00e7\u00e3o de falhas no momento exato em que elas surgem.</li> </ul> </li> <li>Controle de Produ\u00e7\u00e3o<ul> <li>Todo o ciclo de produ\u00e7\u00e3o pode ser controlado automaticamente para seguir os par\u00e2metros definidos. Se for necess\u00e1rio ajustar a temperatura, press\u00e3o ou vaz\u00e3o, essas corre\u00e7\u00f5es s\u00e3o feitas sem atrasos, mantendo a qualidade e a produtividade de todo o processo.</li> </ul> </li> <li>Gerenciamento de Ativos<ul> <li>Auxilia na supervis\u00e3o da estrutura f\u00edsica da ind\u00fastria, permitindo a cria\u00e7\u00e3o de indicadores de produ\u00e7\u00e3o baseados nas capacidades t\u00e9cnicas dos equipamentos. Isso possibilita ao gestor uma verifica\u00e7\u00e3o precisa do ciclo de vida de cada material e ativo.</li> </ul> </li> </ol> Figura 4: Tela de monitoramento em sistema Elipse SCADA <p>5. Conclus\u00e3o</p> <p>Em resumo, um sistema SCADA  coleta informa\u00e7\u00f5es do mundo f\u00edsico atrav\u00e9s dos sensores, processa esses dados em um centro de controle e permite que os operadores tomem decis\u00f5es informadas e executem a\u00e7\u00f5es precisas atrav\u00e9s dos atuadores.</p> <p>Entender o que \u00e9 um SCADA e como ele funciona \u00e9 dar o primeiro passo para compreender a base da automa\u00e7\u00e3o moderna e a tecnologia que mant\u00e9m nosso mundo funcionando de forma eficiente, segura e confi\u00e1vel.</p> <p>Refer\u00eancias</p> <ul> <li>ALTUS. BluePlant | Produtos . Acesso em: 15 out.2024.</li> <li>ALTUS. Como o sistema supervis\u00f3rio ajuda na produtividade de uma empresa? Acesso em: 15 out. 2024.</li> <li>ALTUS. Sistema SCADA: entenda sua import\u00e2ncia para a ind\u00fastria Acesso em: 15 out. 2024.</li> <li>AVEVA. AVEVATM Edge - HMI and IoT Edge solution for OEMs and End Users Acesso em: 15 out. 2024.</li> <li>ELIPSE. PLATAFORMA HMI/SCADA PARA APLICA\u00c7\u00d5ES DE MISS\u00c3O CR\u00cdTICA Acesso em: 15 out. 2024.</li> <li>SCADABR. ScadaBR Acesso em: 15 out. 2024.</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/scada/tecnologia/02-scada_br/","title":"SCADA Br","text":"<p>Natureza e Origem</p> <ul> <li>Software Open Source: O ScadaBR \u00e9 um software SCADA de c\u00f3digo aberto (Open Source).</li> <li>Desenvolvimento: Foi desenvolvido a partir do software SCADA Open Source chamado Mango.</li> <li>In\u00edcio e Financiamento: O projeto foi iniciado em 2006 em colabora\u00e7\u00e3o com a Funda\u00e7\u00e3o CERTI e a UFSC (Universidade Federal de Santa Catarina). Recebeu financiamento da FINEP, SEBRAE e CNPq.</li> <li>Tecnologia: \u00c9 desenvolvido em Java. \u00c9 distribu\u00eddo em formato .war (Web application ARchive) e utiliza depend\u00eancias como Java 8 / Open JDK 8 e Tomcat 9.</li> </ul> <p>Caracter\u00edsticas T\u00e9cnicas e Acessibilidade</p> <p>O ScadaBR \u00e9 not\u00e1vel por sua acessibilidade e capacidade de integra\u00e7\u00e3o.</p> <ul> <li>Multiplataforma: Pode ser instalado em ambientes Windows ou Linux. Novos instaladores tamb\u00e9m incluem suporte para arquitetura ARM (Raspberry PI).</li> <li>Acesso Remoto via Browser: A interface de usu\u00e1rio \u00e9 acessada via navegador.</li> <li>Sem necessidade de Clientes: N\u00e3o requer a instala\u00e7\u00e3o de clientes e permite o acesso de qualquer lugar, seja por celular, tablet, notebook ou computador.</li> <li>Capacidade Ilimitada: O sistema possui views/usu\u00e1rios ilimitados e permite a utiliza\u00e7\u00e3o de tags/pontos ilimitados, al\u00e9m de possibilitar o uso de quantos drivers o usu\u00e1rio desejar.</li> <li>Comunica\u00e7\u00e3o e Protocolos: O ScadaBR \u00e9 capaz de fazer aquisi\u00e7\u00e3o de dados em mais de 20 protocolos, incluindo:<ul> <li>Modbus TCP/IP e Serial.</li> <li>OPC, DNP3, IEC.</li> <li>Serial ASCII, HTTP, entre outros.</li> </ul> </li> <li>Interfaces de Programa\u00e7\u00e3o: Oferece interfaces SOAP e REST.</li> </ul> Figura : Exemplo de tela no ScadaBr <p>Setores de Aplica\u00e7\u00e3o</p> <p>O sistema SCADABR abrange uma vasta \u00e1rea de aplica\u00e7\u00f5es, sendo adequado para controlar e supervisionar qualquer sistema:</p> <ul> <li>Setor Industrial e Predial: Automa\u00e7\u00e3o industrial/Controle de processos, Automa\u00e7\u00e3o residencial e Automa\u00e7\u00e3o predial.</li> <li>Infraestrutura: Sistemas de Energia e Saneamento b\u00e1sico. Exemplos de aplica\u00e7\u00e3o incluem monitoramento de gera\u00e7\u00e3o de energia (como em microrredes) e sistemas de \u00e1gua/reservat\u00f3rios (como a CASAN).</li> <li>Outras \u00c1reas: HVAC (Ventila\u00e7\u00e3o, Aquecimento e Ar-Condicionado), Efici\u00eancia energ\u00e9tica, IoT, Automa\u00e7\u00e3o rural/Agricultura, Aplica\u00e7\u00f5es para Redes de Sensores sem-fio e Esta\u00e7\u00f5es Meteorol\u00f3gicas.</li> <li>Pesquisa: Tamb\u00e9m \u00e9 utilizado em Pesquisa e Desenvolvimento.</li> </ul> Figura : Projeto Caracol Fonte: Projeto Caracol Figura : Scada LTS Fonte: Scada-LTS - GitHub Price Free (GPL License) Annual Maintenance Fee None # of Data Points Unlimited User Connections Unlimited Protocols All suported (no restrictions) REST API Yes Reports Yes Creating a data warehouse Optional (to order) <p>Refer\u00eancias</p> <ul> <li>SCADABR. ScadaBR Acesso em: 15 out. 2024.</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/scada/tecnologia/03-scada_br_lab/","title":"SCADA Br","text":"<p>1) Login no Scada-Br</p> <p></p> <p>2) Sele\u00e7\u00e3o de canal de fonte de dados</p> <p></p> <p>3) Propriedades do Modbus Serial</p> <p></p> <p>4) Propriedades dos Modubs Serial</p> <p></p> <p>5) Adicionando um Data points</p> <p></p> <p>6) Salvando Data points</p> <p></p> <p>7) Visulizando Data points configurados</p> <p></p> <p>8) Sinal de comunica\u00e7\u00e3o serial</p> <p></p> <p>9) M\u00faltiplos sinais de comunica\u00e7\u00e3o</p> <p></p> <p>10) Frames de envio e resposta modbus</p> <p></p> <p>Refer\u00eancias</p> <ul> <li>SCADABR. ScadaBR Acesso em: 15 out. 2024.</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"automacao/sitap/clp/sa1-operacoes_logicas/","title":"1. Opera\u00e7\u00f5es l\u00f3gicas","text":"<p>As situa\u00e7\u00f5es problema resolvidas por um CLP (Controlador L\u00f3gico Program\u00e1vel) envolvem a tradu\u00e7\u00e3o de necessidades industriais em instru\u00e7\u00f5es l\u00f3gicas que o processador executa sequencialmente durante o seu ciclo de varredura (scan). A l\u00f3gica \u00e9 a capacidade de tomar decis\u00f5es quando diversos fatores devem ser considerados para que uma a\u00e7\u00e3o (sa\u00edda) ocorra.</p> <p>Seguem algums exemplos que utilizam as fun\u00e7\u00f5es l\u00f3gicas para sua implementa\u00e7\u00e3o:</p> <p>1) Uma prensa de furar s\u00f3 deve entrar em funcionamento se uma pe\u00e7a estiver posicionada no local E o operador estiver com as duas m\u00e3os acionando chaves de partida distintas.</p> <p>2) Um motor misturador deve agitar o l\u00edquido de um tanque somente quando a temperatura E a press\u00e3o atingirem valores pr\u00e9-ajustados.</p> <p>3) O sinaleiro de um reservat\u00f3rio deve acender se o sensor de n\u00edvel baixo for ativado OU se o sensor de temperatura excessiva detectar uma falha.</p> <p>4) Em um autom\u00f3vel, a luz de teto acende se a porta do motorista OU a porta do passageiro for aberta.</p> <p>5) Um indicador de \"baixa press\u00e3o\" deve ser ligado sempre que o pressostato N\u00c3O estiver fechado (ou seja, quando a press\u00e3o cair abaixo do limite).</p> <p>6) Um sistema de seguran\u00e7a que interrompe um processo se dois sensores de proximidade cr\u00edticos forem ativados ao mesmo tempo, indicando uma colis\u00e3o iminente.</p> <p>7) Um sinaleiro de \"Sistema em Espera\" que permanece ligado apenas enquanto nenhuma das bombas (Bomba A e Bomba B) estiver em opera\u00e7\u00e3o.</p> <p>8) Controle de uma l\u00e2mpada por dois interruptores diferentes (como em um corredor); se voc\u00ea mudar o estado de qualquer um dos interruptores, a l\u00e2mpada inverte seu estado atual.</p> <p>9) Um sistema de diagn\u00f3stico que compara o estado real de chaves de cames rotativas com um padr\u00e3o desejado armazenado na mem\u00f3ria; o sistema indica \"Normal\" apenas se houver coincid\u00eancia absoluta entre os bits.</p> <p>10) Em uma linha de envasamento, SE a garrafa estiver cheia (entrada A), ENT\u00c3O a tampa deve ser prensada (sa\u00edda B).</p> <p></p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa1-operacoes_logicas/#2-desenvolvimento-do-projetoatividadetarefa","title":"2. Desenvolvimento do projeto/atividade/tarefa","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa1-operacoes_logicas/#elabore-uma-rede-network-para-cada-uma-das-logicas-e-ou-nao-nao-e-nao-ou-ou-exclusivo-e-coincidencia","title":"Elabore uma rede (Network) para cada uma das l\u00f3gicas: <code>E</code>, <code>OU</code>, <code>N\u00e3o</code>, <code>N\u00e3o-E</code>, <code>N\u00e3o-OU</code>, <code>Ou-Exclusivo</code> e <code>Coincid\u00eancia</code>.","text":"<p>Para todas as l\u00f3gicas, use as mesmas entradas <code>A</code> e <code>B</code>. </p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/","title":"1. Partida Direta de Motor","text":"<p>A partida direta de um motor \u00e9 um dos circuitos de acionamento mais comuns na ind\u00fastria, e \u00f3timo para iniciar o aprendizado conhecendo os elementos dessa tecnolgia, j\u00e1 que sua l\u00f3gica de acionamento \u00e9 bem simples. </p> <p>A Figura 1 ilustra os diagramas de pot\u00eancia e de comandos, respons\u00e1veis pela alimenta\u00e7\u00e3o trif\u00e1sica do motor com o seu acionamento utilizando botoeiras.</p> Figura 1: Diagrama de Pot\u00eancia e Comando de uma partida direta de motor Fonte: PARTIDA DIRETA DE MOTORES - COMO LIGAR? - \u00d4mega Treinamentos <p>Explica\u00e7\u00e3o detalhada sobre o acionamento n\u00e3o faz parte do escopo deste material, sendo assim, seguem indica\u00e7\u00f5es:</p> <ol> <li>Sala da El\u00e9trica</li> <li>PARTIDA DIRETA DE MOTORES - COMO LIGAR? - \u00d4mega Treinamentos</li> </ol> V\u00eddeo 1: Anima\u00e7\u00e3o de liga\u00e7\u00f5es em um comando de partida direta de motor Fonte: Comando El\u00e9trico Super F\u00e1cil (Partida Direta) - Marcos Instala\u00e7\u00e3o El\u00e9trica","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#2-desenvolvimento-do-projetoatividadetarefa","title":"2. Desenvolvimento do projeto/atividade/tarefa","text":"<p>A etapa inicial no desenvolvimento de uma atividade, tarefa ou projeto \u00e9 ter um objetivo bem definido. </p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#21-requisitos-da-solucao-componentes-de-interface-e-comportamento","title":"2.1 Requisitos da solu\u00e7\u00e3o (Componentes de interface e Comportamento)","text":"<p>Lista dos componentes de interface com suas caracter\u00edsticas e a descri\u00e7\u00e3o do comportamento que se deve atingir na solu\u00e7\u00e3o.</p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#22-planejamento-produto-final-ferramentas-materiais-e-processo","title":"2.2 Planejamento (Produto final, Ferramentas, Materiais e Processo )","text":"<p>Definir como ser\u00e1 feita a entrega: simulador, montagem de prot\u00f3tipo, montagem de circuito em painel ou PCI, etc, assim como listar os materiais e ferramentas em fun\u00e7\u00e3o do tipo de entrega. Por fim o planejamento do processo, em que deve ficar explicito como, utilizando os materiais listados e manipulando da ferramentas, chega-se ao produto final, com um encadeamento l\u00f3gico das tarefas que compoem o processo.</p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#23-solucao","title":"2.3 Solu\u00e7\u00e3o","text":"<p>Produto ou processo que atinge o objetivo proposto, atrav\u00e9s da execu\u00e7\u00e3o de seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#3-objetivo","title":"3. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, programa, em CLP para realizar uma partida direta de motor trif\u00e1sico.</p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#31-requisitos-da-solucao","title":"3.1 Requisitos da solu\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#311-componentes-de-interface","title":"3.1.1 Componentes de interface","text":"<ul> <li>Botoeira ligar: <code>S1</code>;</li> <li>Botoeira desligar: <code>S0</code>;</li> <li>Contator de acionamento: <code>K1</code>;</li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#312-comportamento","title":"3.1.2 Comportamento","text":"<ul> <li> <p>Ao pressionar <code>S1</code>:</p> <ul> <li>Ligar <code>K1</code>;</li> </ul> </li> <li> <p>Ao pressionar <code>S0</code>:</p> <ul> <li>Desligar <code>K1</code>.</li> </ul> </li> <li> <p><code>S0</code> \u00e9 mandat\u00f3rio sobre <code>S1</code>.</p> </li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#32-planejamentos","title":"3.2 Planejamentos","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#321-produto-final","title":"3.2.1 Produto final","text":"<ol> <li>Apresenta\u00e7\u00e3o de funcionamento em kit did\u00e1tico;</li> <li>Arquivo .pdf contendo:<ul> <li>declara\u00e7\u00e3o de interface f\u00edsica, entradas e sa\u00eddas com respectivos endere\u00e7os;</li> <li>programa em linguagem <code>Ladder</code>, <code>ST</code> ou <code>SFC(Grafcet)</code> contendo comportamento para a partida proposta.</li> </ul> </li> </ol>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#322-ferramentas","title":"3.2.2 Ferramentas","text":"<ol> <li>Software Master Tool IEC</li> <li>Kit did\u00e1tico: TB131 Altus</li> </ol>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#323-materiais","title":"3.2.3 Materiais","text":"<ul> <li>N\u00e3o h\u00e1!</li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#324-planejamento-do-processo","title":"3.2.4 Planejamento do processo","text":"<ul> <li>Abrir projeto a partir do modelo: <code>Modelo_DU350_DU351_v110.pro</code>;</li> <li>Acrescentar objeto POU do tipo Programa em linguagem Ladder ou ST ou SFC;</li> <li>Declarar entradas e sa\u00eddas f\u00edsicas (Mapa de Entradas e Sa\u00eddas);</li> <li>Programar a l\u00f3gica de funcionamento;</li> <li>Testar e Validar o comportamento.</li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#33-solucao","title":"3.3 Solu\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#331-mapa-de-entradas-e-saidas","title":"3.3.1 Mapa de Entradas e Sa\u00eddas","text":"Fun\u00e7\u00e3o Identificador Descri\u00e7\u00e3o Tipo Endere\u00e7o Entrada Ligar Ligar motor Bool %IX0.1 Entrada Desligar Desligar motor Bool %IX0.0 Sa\u00edda K1 Contator que aciona motor Bool %QX1.0","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#332-programa-em-linguagem-ladder","title":"3.3.2 Programa em Linguagem Ladder","text":"<p>Para imprimir o projeto, basta clicar em <code>Arquivo</code> e <code>Imprimir</code> e realizar a impress\u00e3o em arquivo .pdf. </p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa2-projeto_partida_direta_motor/#333-impressao","title":"3.3.3 Impress\u00e3o","text":"<p>Caso haja necessidade, realize ajustes na folha de impress\u00e3o. Cada software possui ajustes pr\u00f3prios. </p> <p></p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/","title":"Port\u00e3o de Garagem","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, programa de PLC, para um   porta de garagem basculante motorizada. O sistema utiliza um contator para subir a porta e outro para desc\u00ea-la, com sensores de fim de curso para detectar quando a porta est\u00e1 totalmente aberta ou fechada e bot\u00f5es para acionamento.</p> Figura 1: Exemplo de cruzamento de pedestres Fonte: Gemini <p>Para atender o objetivo solicitado, deve ser implementada uma partida direta com revers\u00e3o, que \u00e9 um sistema de acionamento de motores que combina a fun\u00e7\u00e3o b\u00e1sica de uma chave de partida direta com a capacidade de inverter o sentido de rota\u00e7\u00e3o do motor.</p> <p>Uma chave de partida direta convencional \u00e9 composta essencialmente por um contator acoplado a um rel\u00e9 de sobrecarga.</p> <p>Na vers\u00e3o com revers\u00e3o, s\u00e3o utilizados dois contatores (um para cada sentido de rota\u00e7\u00e3o, como \"subir\" e \"descer\" ou \"frente\" e \"r\u00e9\") e um rel\u00e9 de sobrecarga para prote\u00e7\u00e3o contra correntes excessivas.</p> <p>O sistema utiliza dispositivos de campo como bot\u00f5es de comando (partida, parada e bot\u00f5es espec\u00edficos para cada sentido) e, em muitos casos, chaves-limite (fim de curso) para interromper o movimento automaticamente ao atingir um ponto espec\u00edfico.</p> <p>Para que o sentido de rota\u00e7\u00e3o de um motor trif\u00e1sico seja alterado, \u00e9 necess\u00e1rio inverter duas das tr\u00eas fases de alimenta\u00e7\u00e3o (por exemplo, a fase R se torna T e a fase T se torna R).</p> <p>Os contatores de revers\u00e3o s\u00e3o instalados de forma que um deles conecte as fases na ordem normal e o outro as conecte na ordem invertida.</p> <p>O Intertravamento (Bloqueio) \u00e9 uma regra fundamental na l\u00f3gica de revers\u00e3o em que o motor deve parar completamente antes de inverter o sentido. Assim, no programa (l\u00f3gica ladder), \u00e9 essencial incluir um bloqueio ou intertravamento el\u00e9trico/l\u00f3gico, garantindo que o contator de um sentido n\u00e3o possa ser energizado enquanto o outro estiver ativo, o que evitaria um curto-circuito entre as fases. O circuito geralmente conta com um contato de selo, que mant\u00e9m o contator energizado ap\u00f3s o operador liberar o bot\u00e3o de partida.</p>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#11-requisitos-da-solucao","title":"1.1 - Requisitos da solu\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#111-componentes-de-interface","title":"1.1.1 Componentes de interface","text":"<ul> <li>S1: Bot\u00e3o Abrir;</li> <li>S0: Bot\u00e3o Fechar;</li> <li>fc1: Fim de curso de port\u00e3o aberto;</li> <li>fc2: Fim de curso de port\u00e3o fechado;</li> <li>K1: Contator que realiza a abertura do port\u00e3o;</li> <li>K2: Contator que realiza o fechamento do port\u00e3o.</li> </ul>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#112-comportamento","title":"1.1.2 Comportamento","text":"<ul> <li> <p>Condi\u00e7\u00e3o: Port\u00e3o fechado</p> <ul> <li>fc2 acionado;</li> <li>Se pressionar o \"Abrir\" o port\u00e3o deve abrir at\u00e9 atingir o fc1. </li> </ul> </li> <li> <p>Condi\u00e7\u00e3o: Port\u00e3o aberto</p> <ul> <li>fc1 acionado;</li> <li>Se pressionar o \"Fechar\" o port\u00e3o deve fechar at\u00e9 atingir o fc2.</li> </ul> </li> <li> <p>Condi\u00e7\u00e3o: Port\u00e3o abrindo</p> <ul> <li>Se pressionar o \"Fechar\" o bot\u00e3o n\u00e3o tem efeito.</li> </ul> </li> <li> <p>Condi\u00e7\u00e3o: Port\u00e3o fechando</p> <ul> <li>Se pressionar o \"Abrir\" o bot\u00e3o n\u00e3o tem efeito.</li> </ul> </li> </ul>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#2-planejamentos","title":"2 Planejamentos","text":"<p>Definir como ser\u00e1 feita a entrega:  simulador, montagem de prot\u00f3tipo, montagem de circuito em painel ou PCI, etc,  assim como listar os materiais e ferramentas em fun\u00e7\u00e3o do tipo de entrega.  Por fim o planejamento do processo, em que deve ficar explicito como,  utilizando os materiais listados e manipulando da ferramentas,  chega-se ao produto final, com um encadeamento l\u00f3gico das tarefas que compoem o processo.</p>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#21-produto-final","title":"2.1 Produto final","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#22-ferramentas","title":"2.2 Ferramentas","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#23-materiais","title":"2.3 Materiais","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#24-processo","title":"2.4 Processo","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa3-projeto_portao_diretaReversao/#3-solucao","title":"3. Solu\u00e7\u00e3o","text":"<p>Produto ou processo que atinge o objetivo proposto, atrav\u00e9s da execu\u00e7\u00e3o de seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p> <p>Bom trabalho!</p>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/","title":"Partida Estrela-Tri\u00e2ngulo","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, programa,  para um dispositivo de comando para partida Estrela-Tri\u00e2ngulo.</p> Figura 1: Diagramas de comando e pot\u00eancia da partida Estrela-Tri\u00e2ngulo Fonte: Wikipedia","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#11-requisitos-da-solucao","title":"1.1 - Requisitos da solu\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#111-componentes-de-interface","title":"1.1.1 Componentes de interface","text":"<ul> <li>Botoeira ligar: S1;</li> <li>Botoeira desligar: S0;</li> <li>Contatores de acionamento: K1, K2 e K3;</li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#112-comportamento","title":"1.1.2 Comportamento","text":"<ul> <li>Ao pressionar S1<ul> <li>Ligar K1, K2 (fechamento estrela);</li> <li>Temporizar 5 segundos</li> <li>Desligar K2 e ligar K3 (fechamento tri\u00e2ngulo).</li> </ul> </li> <li>Ao pressionar S0, em qualquer momento:<ul> <li>Desligar todos os contatores.</li> </ul> </li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#2-planejamentos","title":"2 Planejamentos","text":"","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#21-produto-final","title":"2.1 Produto final","text":"<ul> <li>Apresenta\u00e7\u00e3o de funcionamento em kit did\u00e1tico</li> <li>Arquivo .pdf contendo:<ul> <li>declara\u00e7\u00e3o de interface f\u00edsica, entradas e sa\u00eddas com respectivos endere\u00e7os;</li> <li>declara\u00e7\u00e3o de programa contendo interface e comportamento para a partida proposta.</li> </ul> </li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#22-ferramentas","title":"2.2 Ferramentas","text":"<ol> <li>Software Master Tool IEC</li> <li>Kit did\u00e1tico: TB131 Altus</li> </ol>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#23-materiais","title":"2.3 Materiais","text":"<ul> <li>N\u00e3o h\u00e1!</li> </ul>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#24-processo","title":"2.4 Processo","text":"<ol> <li>Abrir projeto a partir do modelo: <code>Modelo_DU350_DU351_v110.pro</code>;</li> <li>Acrescentar objeto POU do tipo Programa e escolher a linguagem;</li> <li>Produzir mapa de entradas e sa\u00eddas;</li> <li>Declarar entradas e sa\u00eddas f\u00edsicas;</li> <li>Programar;</li> <li>Testar aplica\u00e7\u00e3o;</li> <li>Entregar funcionamento.</li> </ol>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa4-projeto_partida_estrela_triangulo/#3-solucao","title":"3. Solu\u00e7\u00e3o","text":"<p>Produto ou processo que atinge o objetivo proposto,  atrav\u00e9s da execu\u00e7\u00e3o de seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p> <p>Bom Trabalho!</p>","tags":["CLP","Altus","TB131","Partida Estrela-Tri\u00e2ngulo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/","title":"Sem\u00e1foro","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, programa de PLC,  para um dispositivo de controle de tr\u00e1fego (sem\u00e1foro),  a ser instalado em um cruzamento de pedestre.</p> Figura 1a: Exemplo de cruzamento de pedestres Figura 1b: Sem\u00e1foro para ve\u00edculos Fonte: freepik","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#11-requisitos-da-solucao","title":"1.1 - Requisitos da solu\u00e7\u00e3o","text":"","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#111-componentes-de-interface","title":"1.1.1 Componentes de interface","text":"<ul> <li>Sinaleiros do sem\u00e1foro de ve\u00edculos (Vermelho, Amarelo, Verde);</li> <li>Sinaleiros do sem\u00e1foro de pedestres (Vermelho, Verde);</li> <li>Botoeira de passagem de pedestre;</li> </ul>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#112-comportamento","title":"1.1.2 Comportamento","text":"<ul> <li>Intervalo de tempo para o Sem\u00e1foro de Ve\u00edculos(sv):<ul> <li>Verde: 42s</li> <li>Amarelo: 3s</li> <li>Vermelho: 15s</li> </ul> </li> <li>Sem\u00e1foro de Pedestre(sp) sincronizado com o de ve\u00edculos:<ul> <li>Verde (sv) : Vermelho (sp)</li> <li>Amarelo (sv) : Vermelho (sp)</li> <li>Vermelho (sv) : Verde (sp)</li> </ul> </li> <li> <p>Piscar Vermelho (sp) 3x antes de mudar em definitivo.</p> </li> <li> <p>Bot\u00e3o pulsador para antecipar libera\u00e7\u00e3o de passagem dos pedestres:</p> <ul> <li>Se faltar mais do que 10s para o acionamento da cor amarela, reduzir para 10s.</li> <li>Se faltar menos do que 10s para o acionamento da cor amarela, manter o tempo restante.</li> </ul> </li> </ul>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#2-planejamento-do-produto-final-ferramentas-materiais-e-processo","title":"2 Planejamento do produto final, ferramentas, materiais e processo.","text":"<p>Definir como ser\u00e1 feita a entrega:  simulador, montagem de prot\u00f3tipo, montagem de circuito em painel ou PCI, etc,  assim como listar os materiais e ferramentas em fun\u00e7\u00e3o do tipo de entrega.  Por fim o planejamento do processo, em que deve ficar explicito como,  utilizando os materiais listados e manipulando da ferramentas,  chega-se ao produto final, com um encadeamento l\u00f3gico das tarefas que compoem o processo.</p>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"automacao/sitap/clp/sa5-projeto_semaforo/#3-solucao","title":"3. Solu\u00e7\u00e3o","text":"<p>Produto ou processo que atinge o objetivo proposto, atrav\u00e9s da execu\u00e7\u00e3o de seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p> <p>Bom trabalho!</p>","tags":["CLP","Altus","TB131","Semaforo"]},{"location":"dados/ad/ad00-analise_de_dados/","title":"An\u00e1lise de Dados","text":"<p>A an\u00e1lise de dados \u00e9 o processo de manipula\u00e7\u00e3o de dados atrav\u00e9s de ferramentas computacionais e estat\u00edsticas, de modo a buscar informa\u00e7\u00f5es relevantes que auxiliam \u00e0 tomada de decis\u00e3o. </p> <p>S\u00e3o basicamente quatro os tipos de an\u00e1lise de dados:</p> <ol> <li>Descritiva</li> <li>Diagn\u00f3stica</li> <li>Preditiva</li> <li>Prescritiva</li> </ol> <p>Eles s\u00e3o usadas em fun\u00e7\u00e3o do objetivo da an\u00e1lise e do conjunto de dados que se est\u00e1  trabalhando, come\u00e7ando pela avalia\u00e7\u00e3o do problema de neg\u00f3cio,  em que s\u00e3o realizadas perguntas tais como:</p> <ol> <li>O resultado da a\u00e7\u00e3o foi positivo ou negativo?</li> <li>Por que os resultados foram esses?</li> <li>Como tomar uma decis\u00e3o?</li> </ol> <p>Ap\u00f3s a defini\u00e7\u00e3o do problema que ser\u00e1 estudado,  deve-se descrever o comportamento dentro de um escopo bem definido,  diagnosticar os motivos que produziram os comportamentos.  Da\u00ed seguem etapas mais complexas, costumeiramente desenvolvidas por cientistas de dados,  que envolver processos de prever o comportamento baseado em hist\u00f3rico e  por fim prescrever/orientar a\u00e7\u00f5es para alcan\u00e7ar as metas do neg\u00f3cio.  Estas duas \u00faltimas etapas s\u00e3o mais complexas, envolvem um ferramental estat\u00edstico  mais avan\u00e7ado e t\u00e9cnicas de aprendizado de m\u00e1quina. </p> <p>A Figura 1 ilustra um fluxo para an\u00e1lise de dados,  que segue desde a an\u00e1lise descritiva at\u00e9 a prescritiva, por\u00e9m,  n\u00e3o \u00e9 necess\u00e1ria a realiza\u00e7\u00e3o de todo o fluxo de an\u00e1lise,  pois tudo depende da finalidade da an\u00e1lise. </p> Figura 1: Fluxo de an\u00e1lise de dados Fonte: Autor <p>A divis\u00e3o entre analista e cientista \u00e9 uma tend\u00eancia, n\u00e3o uma obrigatoriedade,  apenas uma separa\u00e7\u00e3o em fun\u00e7\u00e3o do n\u00edvel de aplica\u00e7\u00e3o de t\u00e9cnicas de an\u00e1lise. </p> <p>An\u00e1lise Descritiva</p> <p>Fornece um resumo simples de uma planilha de dados,  atrav\u00e9s de indicadores, gr\u00e1ficos e tabelas.  Realiza a explora\u00e7\u00e3o inicial dos dados, permitindo a compreens\u00e3o da distribui\u00e7\u00e3o,  valor central e dispers\u00e3o dos dados, al\u00e9m da presen\u00e7a de poss\u00edveis outliers.</p> <p>S\u00e3o caracter\u00edsticas da An\u00e1lise Descritiva:</p> <ol> <li>Resumo de dados:<ol> <li>Medidas de tend\u00eancia central: M\u00e9dia, Moda e Mediana;</li> <li>Medidas de dispers\u00e3o: Desvio padr\u00e3o e Vari\u00e2ncia.</li> </ol> </li> <li>Visualiza\u00e7\u00e3o de dados:<ol> <li>Rela\u00e7\u00e3o entre vari\u00e1veis.</li> </ol> </li> <li>Identifica\u00e7\u00e3o de padr\u00f5es.</li> </ol> <p>As principais ferramentas utilizadas na an\u00e1lise descritiva s\u00e3o:</p> <ol> <li>Planilhas de c\u00e1lculo: Excel, Google Sheets;</li> <li>Softwares estat\u00edsticos: SPSS, Stata;</li> <li>Softwares de visualiza\u00e7\u00e3o de dados: Tableu, Power BI;</li> <li>Linguagens de programa\u00e7\u00e3o: Python e R.</li> </ol> <p>An\u00e1lise Diagn\u00f3stica</p> <p>Busca entender os motivos ou causas por tr\u00e1s de determinado fen\u00f4meno ou resultado.  Procura responder \u00e0 pergunta \"por qu\u00ea?\", busca identificar padr\u00f5es e rela\u00e7\u00f5es  nos dados que podem explicar mudan\u00e7as ou tend\u00eancias observadas e ainda pode  envolver a considera\u00e7\u00e3o de fatores externos ou internos.</p> <p>S\u00e3o caracter\u00edsticas da an\u00e1lise diagn\u00f3stica:</p> <ol> <li>Investigativa:<ul> <li>Buscando entender as causas subjacentes de um fen\u00f4meno ou problema.</li> </ul> </li> <li>Baseada em Hip\u00f3teses:<ul> <li>Uma hip\u00f3tese \u00e9 proposta e a an\u00e1lise \u00e9 usada para testar ela. </li> </ul> </li> <li>Uso de dados hist\u00f3ricos:<ul> <li>Identificar tend\u00eancias, padr\u00f5es e rela\u00e7\u00f5es que podem explicar os resultados atuais.</li> </ul> </li> <li>An\u00e1lise Multivariada:<ul> <li>Pode envolver m\u00faltiplas vari\u00e1veis ao mesmo tempo para entender as intera\u00e7\u00f5es complexas que podem estar influenciando um resultado</li> </ul> </li> <li>Interpreta\u00e7\u00e3o cuidadosa</li> </ol> <p>As principais ferramentas utilizadas na an\u00e1lise diagn\u00f3stica s\u00e3o: </p> <ol> <li>An\u00e1lise de regress\u00e3o: Identificar a rela\u00e7\u00e3o entre vari\u00e1veis dependentes e independentes;</li> <li>An\u00e1lise de correla\u00e7\u00e3o: Determinar a rela\u00e7\u00e3o entre duas ou mais vari\u00e1veis;</li> <li>An\u00e1lise de cluster: Agrupa por caracter\u00edsticas semelhantes;</li> <li>An\u00e1lise de causa e efeito (Diagrama de Ishikawa): Proporciona uma vis\u00e3o ampla e identifica\u00e7\u00e3o de poss\u00edveis causas de um problema.</li> </ol> <p>An\u00e1lise Preditiva</p> <p>An\u00e1lise estat\u00edstica que tem como objetivo prever resultados futuros com base em  dados hist\u00f3ricos e t\u00e9cnicas de modelagem. O processo geralmente envolve a coleta de dados,  o desenvolvimento de um modelo estat\u00edstico e  a previs\u00e3o de resultados futuros com  base nesse modelo. Esses modelos podem ser simples, envolvendo apenas algumas vari\u00e1veis,  ou extremamente complexos, envolvendo muitas vari\u00e1veis e rela\u00e7\u00f5es interdependentes.</p> <p>S\u00e3o caracter\u00edsticas da an\u00e1lise preditiva:</p> <ol> <li>Baseada em modelos: Estat\u00edsticos e de Machine Learning.</li> <li>Usa hist\u00f3rico de dados: Treinamento dos modelos.</li> <li>Multivari\u00e1vel: Consideram a intera\u00e7\u00e3o entre muitas vari\u00e1veis para previs\u00f5es.</li> <li>Preditiva, mas n\u00e3o infal\u00edvel: Sempre h\u00e1 um grau de incerteza. </li> <li>Orientada para a a\u00e7\u00e3o: Resultados orientam a tomada de decis\u00e3o.</li> </ol> <p>As principais ferramentas utilizadas na an\u00e1lise preditiva s\u00e3o:</p> <ol> <li>Python: Juntamente com bibliotecas como Pandas, NumPy, Sci-kit Learn</li> <li>R: An\u00e1lise estat\u00edstica e gr\u00e1ficos, principalmente no meio acad\u00eamico e pesquisa.</li> <li>SAS: Statistical Analysis System, muito usado em setores financeiro e sa\u00fade.</li> <li>SPSS: Software de f\u00e1cil usabilidade e com ampla gama de ferramentas dispon\u00edveis.</li> <li>Excel: Aplicado quando n\u00e3o se requer t\u00e9cnicas estat\u00edsticas avan\u00e7adas. </li> </ol> <p>An\u00e1lise Prescritiva</p> <p>Fornece recomenda\u00e7\u00f5es sobre o que deve ser feito, utilizando t\u00e9cnicas avan\u00e7adas  que levam em considera\u00e7\u00e3o uma variedade de cen\u00e1rios e poss\u00edveis resultados,  para ajudar os tomadores de decis\u00e3o a entender as implica\u00e7\u00f5es de diferentes cursos de a\u00e7\u00e3o. </p> <p>S\u00e3o caracter\u00edsticas da an\u00e1lise prescritiva:</p> <ol> <li>Recomenda\u00e7\u00f5es de a\u00e7\u00e3o;</li> <li>Considera\u00e7\u00e3o de diferentes cen\u00e1rios;</li> <li>Otimiza\u00e7\u00e3o de opera\u00e7\u00f5es;</li> <li>Aux\u00edlio \u00e0 tomada de decis\u00e3o;</li> <li>Adapta\u00e7\u00e3o a mudan\u00e7as nas condi\u00e7\u00f5es: pode incorporar novos dados \u00e0 medida que se tornem dispon\u00edveis.</li> </ol> <p>As principais ferramentas da an\u00e1lise prescritiva s\u00e3o:</p> <ol> <li>Softwares de modelagem: Python, R, SAS, SPSS</li> <li>Ferramentas de otimiza\u00e7\u00e3o: Gurobi, CPLEX</li> <li>Ferramentas de simula\u00e7\u00e3o: Simul8, AnyLogic</li> <li>Ferramentas de visualiza\u00e7\u00e3o de dados: Tableau, Power BI</li> <li>Plataformas de machine learning: Azure ML, Amazon SageMaker</li> </ol> <p>Exemplo de an\u00e1lise preditiva: </p> <p>Kaggle - Forecasting Future Passengers w/ PyCaret</p>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ad/ad01-ambiente_desen/","title":"Ferramentas","text":"","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ad/ad01-ambiente_desen/#ferramentas-para-analise-de-dados-e-machine-learning","title":"Ferramentas para An\u00e1lise de Dados e Machine Learning","text":"<p>Linguagem de Programa\u00e7\u00e3o</p> <p>A linguagem de programa\u00e7\u00e3o mais comum para a an\u00e1lise de dados \u00e9 Python. De f\u00e1cil aprendizado, vers\u00e1til e com vasta diversidade de bibliotecas para as mais diversas aplica\u00e7\u00f5es. </p> <p>A instala\u00e7\u00e3o pode ser realizada baixando o instalador diretamente do site oficial Python.org.</p> <p>Outra forma de instalar o python \u00e9 atrav\u00e9s do gerenciador de instala\u00e7\u00e3o winget via <code>Powershell</code>:</p> <pre><code>winget install Python.Python.3.13\n</code></pre> <p>No momento da elabora\u00e7\u00e3o deste material, a vers\u00e3o corrente do Python \u00e9 a 3.13. </p> <p>Python Installer Package - PIP</p> <p>Instalador de pacotes python, geralmente j\u00e1 vem na instala\u00e7\u00e3o padr\u00e3o do <code>Python</code> e seu modo de uso ser\u00e1 abordado superficialmente, apenas na aplica\u00e7\u00e3o do que for necess\u00e1rio;</p> <p>Como o pr\u00f3prio nome descreve, a ferramenta <code>pip</code> serve para realizar a instala\u00e7\u00e3o de pacotes indexados no reposit\u00f3rio de software para python o Python Package Index - PyPI.</p> <p>Como exemplo de utiliza\u00e7\u00e3o comum, para a instala\u00e7\u00e3o do framework <code>Pandas</code>para manipula\u00e7\u00e3o de dataframes, temos:</p> <pre><code>pip install pandas\n</code></pre> <p>Virtual Environment - venv</p> <p><code>venv</code> \u00e9 um m\u00f3dulo que suporta a cria\u00e7\u00e3o de ambientes virtuais isolados, de forma simples e pr\u00e1tica. O ambiente criado \u00e9 para ser descart\u00e1vel e facilmente recri\u00e1vel em um outro local. </p> <p>\u00c9 criado sobre a instala\u00e7\u00e3o Python existente. </p> <pre><code># Criando um ambiente virtual \npython -m venv nome-venv\n\n\n# Ativando o ambiente virtual\n\n# Linux\nsource nome-venv/bin/activate\n\n# Windows\nnome-venv\\Scripts\\activate\n</code></pre> <p>Jupyter notebook</p> <p>O Jupyter \u00e9 um projeto de c\u00f3digo aberto sem fins lucrativos, nascido em 2014, que busca oferecer suporte \u00e0 ci\u00eancia de dados de forma interativa e \u00e0 computa\u00e7\u00e3o cient\u00edfica em todas as linguagens de programa\u00e7\u00e3o. </p> <p>Existem algumas interfaces para o Jupyter, como o <code>JupyterLab</code>, <code>Voil\u00e0</code>  e o cl\u00e1ssico <code>Jupyter Notebook</code>.</p> <p>Instalando o Jupyter Notebook via pip:</p> <pre><code>pip install notebook\n</code></pre> <p>Executando o Jupyter notebook:</p> <pre><code>jupyter notebook\n</code></pre>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ad/ad01-ambiente_desen/#criando-um-ambiente-de-desenvolvimento","title":"Criando um Ambiente de Desenvolvimento","text":"<p>Para a cria\u00e7\u00e3o de um ambiente de desenvolvimento \u00e9 necess\u00e1rio que o Python esteja instalado no computador, bem como o Jupyter Notebook.</p> <p>0) Criar/Acessar o diret\u00f3rio do projeto. </p> <pre><code>PS C:\\Users\\...\\projeto&gt; \n</code></pre> <p>1) Criando o ambiente virtual </p> <pre><code>python -m venv venv_projeto\n</code></pre> <p>2) Acessando o ambiente virtual </p> <pre><code>venv_projeto\\Scripts\\activate\n</code></pre> <p>Ap\u00f3s o acesso ao ambiente virtual, no in\u00edcio do prompt aparece entre par\u00eanteses o nome da venv:</p> <pre><code>(venv_projeto) PS C:\\Users\\...\\projeto&gt; \n</code></pre> <p>Obs: Para sair do ambiente de desenvolvimento (venv), basta executar o comando <code>deactivate</code>:</p> <pre><code>(venv_projeto) PS C:\\Users\\...\\projeto&gt; deactivate\nPS C:\\Users\\...\\projeto&gt;\n</code></pre> <p>3) Instalando kernel para Jupyter Notebook </p> <pre><code>pip install ipykernel\n</code></pre> <p>4) Adicionando o ambiente virtual \u00e0 lista de kernels do Jupyter Notebook</p> <pre><code>python -m ipykernel install --user --name=venv_projeto\n</code></pre> <p>Obs: Quando o kernel n\u00e3o for mais necess\u00e1rio, pelo fim do desenvolvimento do projeto, por exemplo, pode-se excluir este kernel da lista no Jupyter Notebook:</p> <pre><code>jupyter-kernelspec uninstall venv_projeto\n</code></pre> <p>5) Executando o Jupyter notebook</p> <pre><code>jupyter notebook\n</code></pre> <p>6) O Jupyter Notebook ser\u00e1 aberto no navegador em <code>localhost:8888\\tree</code></p> <p></p> <p>7) Para criar um <code>notebook</code>, clique em <code>File</code>, <code>New</code> e selecione <code>Notebook</code>:</p> <p></p> <p>8) Selecione o kernel deste projeto, dentro da lista dispon\u00edvel:</p> <p></p> <p>9) Verifique no canto superior direito que o kernel selecinado foi carregado:</p> <p></p> <p>O ambiente est\u00e1 pronto para o projeto ser desenvolvido. </p>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ad/ad01-ambiente_desen/#google-colab","title":"Google Colab","text":"","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml01-ia_ml_dl/","title":"Intelig\u00eancia Artificial","text":"<p>A proposta inicial para o termo <code>Intelig\u00eancia Artificial</code> foi elaborada em uma  confer\u00eancia de um projeto de pesquisa de ver\u00e3o da Universidade de Dartmouth,  no ano de 1956 com a participa\u00e7\u00e3o dos cientistas e matem\u00e1ticos,  como ilustrado na capa do relat\u00f3rio na Figura 1,  John McCarthy (Organizador), Marvin Minsky, Nathaniel Rochester e Claude Shannon. </p> Figura 1 : Uma proposta para o projeto de pesquisa de ver\u00e3o de Dartmouth sobre intelig\u00eancia artificial Fonte: Artificial Intelligence Coined at Dartmouth <p>A hip\u00f3tese proposta foi a de que  \"toda caracter\u00edstica do aprendizado ou qualquer outra caracter\u00edstica da intelig\u00eancia pode,  em princ\u00edpio, ser t\u00e3o precisamente descrita, que uma m\u00e1quina pode ser feita para simul\u00e1-la\".  Nasceu assim uma nova \u00e1rea de pesquisa, a Intelig\u00eancia Artificial (IA). </p> <p>Ainda na d\u00e9cada de 60 foram desenvolvidos o primeiro chatbot ELIZA,  que imitava um profissional de psican\u00e1lise, e Shakey, um rob\u00f4 que unia mobilidade,  fala e certa autonomia de a\u00e7\u00e3o. </p> <p>O per\u00edodo compreendido entre meados dos anos 70 e in\u00edcio dos 80,  ficou conhecido como <code>Inverno da Intelig\u00eancia Artificial</code>,  por ter havido pouco desenvolvimento da \u00e1rea. </p> <p>Nos anos 80 foram desenvolvidas t\u00e9cnicas que permitiram produzir sistemas especialistas,  capazes de produzir resultados interessantes em tarefas espec\u00edficas.  Nasce a aprendizagem de m\u00e1quina (Machine Learning - ML).</p> <p>O aprendizado de m\u00e1quina - machine learning - \u00e9 um conjunto de t\u00e9cnicas para usar  algoritmos que analisam dados e 'aprendem' com eles, de modo a tomar uma decis\u00e3o baseado  nessa 'experi\u00eancia'. Desta forma, no lugar de escrever c\u00f3digos para realizar uma tarefa,  o algoritmo \u00e9 treinado com um certo volume de dados significativos para poder,  ap\u00f3s o treinamento, realizar a tarefa baseado no que foi 'aprendido'. </p> <p>V\u00e1rias t\u00e9cnicas de machine learning surgiram para cumprir objetivos espec\u00edficos,  como a aprendizagem por \u00e1rvore de decis\u00e3o, programa\u00e7\u00e3o l\u00f3gica indutiva, agrupamento,  aprendizagem por refor\u00e7o, redes bayesianas, entre outras. </p> <p>Uma das melhores aplica\u00e7\u00f5es ocorreu com a vis\u00e3o computacional,  mesmo utilizando muitos c\u00f3digos manuais para cumprir com o seu objetivo,  como a utiliza\u00e7\u00e3o de filtros de detec\u00e7\u00e3o de bordas,  filtros para detec\u00e7\u00e3o de formas e classificadores para reconhecer caracteres.  Partindo o resultados desses classificadores, algoritmos conferem sentido \u00e0s imagens e  determinam se \u00e9 o objeto procurado ou n\u00e3o. </p> Figura 2: Linha do tempo das t\u00e9cnicas de intelig\u00eancia artificial Fonte: Qual \u00e9 a Diferen\u00e7a entre Intelig\u00eancia Artificial, Machine Learning e Deep Learning? 10 de mar\u00e7o de 2021 por Michael Copeland - Blog NVIDIA) <p>Geoffrey Hinton, da Universidade de Toronto prop\u00f4s uma t\u00e9cnica denominada de Rede Neural,  que utiliza o conceitos biol\u00f3gicos de neur\u00f4nios e suas conex\u00f5es,  al\u00e9m de dire\u00e7\u00f5es de propaga\u00e7\u00e3o de dados para criar uma rede com camadas de processamento.  Essa t\u00e9cnica somente se tornou relevante a partir da disponibilidade das  Unidade de Processamento Gr\u00e1ficos (GPUs). Assim, em 2012, Andrew Ng, no Google,  fez o reconhecimento de gatos utilizando milhares de v\u00eddeos do Youtube para treinar a sua rede,  desenvolvida com uma maior quantidade de neur\u00f4nios e camadas, tornando eficaz o seu uso,  chamando essa t\u00e9cnica de Rede Profunda - Deep Learning. </p> <p>A Figura 3 ilustra uma rede neural com quatro camadas, sendo uma camada de entrada,  uma camada de sa\u00edda e duas camadas ocultas, neste exemplo.  Redes neurais profundas apresentam mais n\u00f3s, e mais camadas,  o que confere uma maior complexidade. </p> Figura 3: Exemplo de representa\u00e7\u00e3o de Rede Neural Fonte: A Friendly Introduction to [Deep] Neural Networks - August 23, 2021 - Kathrin Melcher - KNIME <p>N\u00edveis de t\u00e9cnicas e ferramentas</p> <p>A intelig\u00eancia artificial tornou-se um termo muito amplo,  e abarca um grande conjunto de ferramentas, incluindo <code>Machine Learning</code> e <code>Deep Learning</code>,  como ilustrado na Figura 4. Sua aplica\u00e7\u00e3o, da mesma forma,  \u00e9 muito vasta e est\u00e1 cada vez mais presente no cotidiano das empresas nos mais diversos  segmentos, tais como setor financeiro, industrial, comercial, cient\u00edficos,  entre outros, em aplica\u00e7\u00f5es como a filtragem de spam, an\u00e1lise de cr\u00e9dito,  diagn\u00f3stico m\u00e9dico, reconhecimento facial, recomenda\u00e7\u00f5es, chatbots, an\u00fancios direcionados, etc.</p> <p>Para trabalhar com tomada de decis\u00e3o baseada em dados,  profissionais cada vez mais especializados s\u00e3o demandados.  De in\u00edcio foram adaptados profissionais como estat\u00edsticos e programadores,  at\u00e9 a difus\u00e3o de profissionais como Cientistas de Dados,  que simplificadamente executam a fus\u00e3o das duas \u00e1reas, aplicando t\u00e9cnicas estat\u00edsticas  para realizar an\u00e1lises de dados, atrav\u00e9s de ferramentas de inform\u00e1tica ou  linguagens de programa\u00e7\u00e3o, de modo a produzir an\u00e1lises preditivas.  Conhecer a \u00e1rea de an\u00e1lise/neg\u00f3cio tamb\u00e9m \u00e9 fundamental para a qualidade do resultado. </p> <p>A Figura 4 ilustra a \u00e1rea de ci\u00eancia de dados interseccionando todos os n\u00edveis de ferramentas,  podendo executar tarefas que necessitem de t\u00e9cnicas de intelig\u00eancia artificial,  machine learning ou mesmo de deep learning. </p> Figura 4: Ferramentas de um Cientista de Dados Fonte: Qual a Diferen\u00e7a Entre Cientista de Dados e Engenheiro de Machine Learning? 31 de Outubro de 2024 - Data Science Academy <p>Com o aumento da demanda de trabalho, as equipes que trabalham com dados v\u00e3o se  especializando e produzindo novos cargos, como Engenheiro de dados e Engenheiro de  Machine Learning. Enquanto o primeiro \u00e9 o respons\u00e1vel por todo o processo de  transporte de dados, desde sua aquisi\u00e7\u00e3o, limpeza, armazenamento e  disponibiliza\u00e7\u00e3o dos dados para serem analisados pelos algoritmos e a entrega dos  resultados aos gestores do setor ou da empresa.  J\u00e1 o Engenheiro de Machine Learning \u00e9 respons\u00e1vel por escolher e implementar a melhor  t\u00e9cnica a ser utilizada para resolver os problemas propostos. </p> <p>A Figura 5 ilustra a busca do termo <code>Engenheiro de Machine Learning</code> no Google trends,  mostrando os pa\u00edses em que tal termo \u00e9 mais buscado bem como seu incr\u00edvel crescimento,  haja visto que uma d\u00e9cada atr\u00e1s essa demanda n\u00e3o existia. </p> Figura 5: Busca por Engenheiro de Machine Learning Fonte: Google Trends <p>A intelig\u00eancia artificial \u00e9 cada vez mais presente e tem perspectiva de um  crescimento ainda maior para os pr\u00f3ximos anos, o que garante a necessidade de  conhecer e aprender ferramentas que possam servir de apoio a sua \u00e1rea de trabalho,  seja ela qual for, mas em especial aten\u00e7\u00e3o no setor industrial e educacional,  setor ao qual estamos ligados. </p> <p>Refer\u00eancias e complementos</p> <ol> <li>Artificial Intelligence Coined at Dartmouth</li> <li>Qual \u00e9 a Diferen\u00e7a entre Intelig\u00eancia Artificial, Machine Learning e Deep Learning? 10 de mar\u00e7o de 2021 por Michael Copeland - Blog NVIDIA)</li> <li>A hist\u00f3ria da intelig\u00eancia artificial - TecMundo</li> <li>O que \u00e9 aprendizado de m\u00e1quina (ML)? - IBM</li> <li>A Friendly Introduction to [Deep] Neural Networks - August 23, 2021 - Kathrin Melcher - KNIME</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/","title":"Aprendizado de M\u00e1quina - Machine Learning","text":"<p>Aprendizado de m\u00e1quina (Machine Learning - ML) pode ser definida como: \"aplica\u00e7\u00e3o e ci\u00eancia de algoritmos que transformam grandes volumes de dados em conhecimento\".</p> <p>ML \u00e9 ent\u00e3o uma alternativa mais eficiente para a extra\u00e7\u00e3o de conhecimento dos dados, melhorando o desempenho de modelos preditivos e as tomadas de decis\u00e3o baseadas neles.</p>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/#os-tres-tipos-de-aprendizado-de-maquina","title":"Os Tr\u00eas Tipos de Aprendizado de M\u00e1quina","text":"<p>S\u00e3o tr\u00eas as sub\u00e1reas principais, ou mais comuns para a divis\u00e3o da \u00e1rea de ML, cada uma adequada a diferentes tipos de tarefas:</p> <ul> <li> <p>Aprendizado Supervisionado: O objetivo principal \u00e9 aprender um modelo a partir de dados de treinamento rotulados, permitindo fazer previs\u00f5es sobre dados futuros ou n\u00e3o vistos. Ele se divide em:</p> <ul> <li>Classifica\u00e7\u00e3o: Focada em prever r\u00f3tulos de classes categ\u00f3ricas e discretas (ex: identificar se um e-mail \u00e9 spam ou n\u00e3o).</li> <li>Regress\u00e3o: Envolve a predi\u00e7\u00e3o de desfechos cont\u00ednuos com base em vari\u00e1veis explicativas (ex: prever o pre\u00e7o de uma casa ou a nota de um exame).</li> </ul> </li> <li> <p>Aprendizado N\u00e3o Supervisionado: Lida com dados n\u00e3o rotulados ou de estrutura desconhecida, permitindo explorar os dados para extrair informa\u00e7\u00f5es significativas sem a guia de uma vari\u00e1vel alvo conhecida. Suas t\u00e9cnicas principais s\u00e3o:</p> <ul> <li>Agrupamento (Clustering): T\u00e9cnica explorat\u00f3ria que organiza informa\u00e7\u00f5es em subgrupos (clusters) com base na similaridade, sem conhecimento pr\u00e9vio de suas associa\u00e7\u00f5es.</li> <li>Redu\u00e7\u00e3o de Dimensionalidade: Frequentemente utilizada no pr\u00e9-processamento para remover ru\u00eddo, economizar espa\u00e7o de armazenamento e comprimir dados em um subespa\u00e7o de menor dimens\u00e3o, mantendo a maior parte da informa\u00e7\u00e3o relevante.</li> </ul> </li> <li> <p>Aprendizado por Refor\u00e7o: Busca desenvolver um sistema (agente) que melhora seu desempenho com base em intera\u00e7\u00f5es com o ambiente. O feedback n\u00e3o \u00e9 o r\u00f3tulo correto, mas uma medida de qu\u00e3o bem a a\u00e7\u00e3o foi executada atrav\u00e9s de uma fun\u00e7\u00e3o de recompensa, permitindo o aprendizado por tentativa e erro, como em motores de xadrez.</p> </li> </ul> Figura: Principais tipos de aprendizado de m\u00e1quina Fonte: Danish Khan: What are the types of Machine Learning?","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/#terminologia-e-notacao","title":"Terminologia e Nota\u00e7\u00e3o","text":"<ul> <li>Dataset: Conjunto de dados ou cole\u00e7\u00e3o organizada de informa\u00e7\u00f5es relacionadas sobre um tema espec\u00edfico.</li> <li>Amostras (Samples): Cada observa\u00e7\u00e3o ou linha no conjunto de dados.</li> <li>Caracter\u00edsticas (Features): As medi\u00e7\u00f5es ou colunas do dataset (atributos).</li> <li>Nota\u00e7\u00e3o: Segue-se a conven\u00e7\u00e3o de representar amostras como linhas em uma matriz de caracter\u00edsticas \\(\\mathbf{X}\\) e os r\u00f3tulos de classe como um vetor \\(\\mathbf{y}\\). O sobrescrito \\((i)\\) refere-se \u00e0 \\(i\\)-\u00e9sima amostra de treinamento, e o subscrito \\(j\\) refere-se \u00e0 \\(j\\)-\u00e9sima dimens\u00e3o.</li> </ul> Figura: Terminologia Fonte: RASCHKA, 2015","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/#fluxo-de-trabalho-para-sistemas-de-ml","title":"Fluxo de Trabalho para Sistemas de ML","text":"<p>Um roteiro t\u00edpico para a constru\u00e7\u00e3o de modelos preditivos \u00e9 dividido em tr\u00eas fases cr\u00edticas:</p> <ol> <li>Pr\u00e9-processamento: Considerado um dos passos mais cruciais, isso inclui a extra\u00e7\u00e3o de caracter\u00edsticas, escalonamento para desempenho ideal e a divis\u00e3o aleat\u00f3ria do dataset em conjuntos de treinamento (para treinar e otimizar o modelo) e teste (para avalia\u00e7\u00e3o final).</li> <li>Treinamento e Sele\u00e7\u00e3o de Modelo: Dado que diferentes algoritmos possuem vieses inerentes, \u00e9 essencial comparar v\u00e1rios modelos para selecionar o melhor. Utiliza-se a valida\u00e7\u00e3o cruzada para estimar o desempenho de generaliza\u00e7\u00e3o e t\u00e9cnicas de otimiza\u00e7\u00e3o de hiperpar\u00e2metros para ajustar o modelo.</li> <li>Avalia\u00e7\u00e3o: Ap\u00f3s selecionar um modelo ajustado no conjunto de treinamento, utiliza-se o conjunto de teste para estimar o erro de generaliza\u00e7\u00e3o. Se satisfeito com o desempenho, o modelo pode ser usado para prever dados futuros.</li> </ol> Figura: Fluxo de trabalho para construir um modelo de aprendizado de m\u00e1quina Fonte: RASCHKA, 2015","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/#o-ecossistema-python","title":"O Ecossistema Python","text":"<p>Python \u00e9 a linguagem mais popular para ci\u00eancia de dados: ele permite focar nas ideias e colocar conceitos em a\u00e7\u00e3o rapidamente.  As principais bibliotecas para o fluxo de trabalho de ML s\u00e3o:</p> <ul> <li>NumPy e SciPy:  opera\u00e7\u00f5es vetorizadas r\u00e1pidas;</li> <li>Scikit-learn: a biblioteca de ML mais popular e acess\u00edvel;</li> <li>Pandas: manipula\u00e7\u00e3o de dados tabulares;</li> <li>Matplotlib: visualiza\u00e7\u00e3o de dados em formato gr\u00e1fico.</li> </ul>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-intro/#referencias","title":"Refer\u00eancias","text":"<ol> <li>RASCHKA, Sebastian. Python Machine Learning: unlock deeper insights into machine learning with this vital guide to cutting-edge predictive analytics. Birmingham: Packt Publishing, 2015</li> <li>Danish Khan: What are the types of Machine Learning?  https://python.plainenglish.io/what-are-the-types-of-machine-learning-540b15dc467f Acesso em 15/01/2026</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml02-ml/","title":"Aprendizado de M\u00e1quina - Machine Learning","text":"<p>O aprendizado de m\u00e1quina (machine Learning) ou aprendizado autom\u00e1tico, deriva da engenharia com a ci\u00eancia da computa\u00e7\u00e3o, evoluindo de estudos de reconhecimento de padr\u00f5es e da teoria do aprendizado computacional em intelig\u00eancia artificial.</p> <p>A sua defini\u00e7\u00e3o foi estabelecida por Arthur Samuel em 1959 como: </p> <p>\"campo de estudo que d\u00e1 aos computadores a habilidade de aprender sem serem explicitamente programados\".</p> <p>O aprendizado de m\u00e1quina \u00e9 o estudo e a constru\u00e7\u00e3o de algoritmos que, utilizando dados, realizam previs\u00f5es e aprendem com os pr\u00f3prios erros. Estes algoritmos recebem amostras a partir das entradas do modelo, de modo a realizar previs\u00f5es e tomadas de decis\u00f5es guiadas pelos dados e n\u00e3o por instru\u00e7\u00f5es programadas. </p> <p>O aprendizado de m\u00e1quina, utiliza o racioc\u00ednio indutivo para produzir os seus resultados, diferenciando-se da intelig\u00eancia artificial, que pode al\u00e9m disso, utilizar o racioc\u00ednio dedutivo.</p> <p>Machine Learning \u00e9 a arte de programar computadores que aprendem atrav\u00e9s de dados.</p> <p>Modelos</p> <p>Um modelo \u00e9 uma representa\u00e7\u00e3o de um objeto ou sistema. Pode ser f\u00edsico (prot\u00f3tipo, maquete) ou abstrato (express\u00e3o matem\u00e1tica, diagrama, descri\u00e7\u00e3o).</p> <p>Na engenharia ou na ci\u00eancia de dados, os modelos simulam a mudan\u00e7a de comportamento mediante a varia\u00e7\u00e3o de seus par\u00e2metros de funcionamento.</p> <p>Algoritmo</p> <p>Um algoritmo \u00e9 uma sequ\u00eancia finita de a\u00e7\u00f5es execut\u00e1veis que tem como objetivo a solu\u00e7\u00e3o de um determinado problema. </p> <p>Programa\u00e7\u00e3o tradicional X Aprendizado de m\u00e1quina</p> Programa\u00e7\u00e3o Tradicional Aprendizado de M\u00e1quina 1. Seleciona exemplos  2. Encontra alguns padr\u00f5es  3. Escreve as regras  4. Testa o algoritmo 1. Seleciona exemplos 2. Encontra alguns padr\u00f5es 3. Extrai as caracter\u00edsticas 4. Treina o algoritmo de ML 5. Testa o algoritmo de ML <p>Hist\u00f3rico de desenvolvimento</p> D\u00e9cada Aprendizado Altoritmo Aplica\u00e7\u00e3o 60 Supervisionado KNN - K Nearest Neighbors Linear Regression Reconhecimento de padr\u00f5es  An\u00e1lises preditivas 70 N\u00e3o Supervisionado K-means  Redes Neurais Aritificiais  Aprende sem o uso de r\u00f3tulos nos treinos 80 Ensemble learning Decision Tree Aumento significativo na precis\u00e3o dos modelos de ML 00/10 Big Data  Capacidade Computacional  Redes neurais profundas  Cloud Computing  Processamento Paralelo <p>Aplica\u00e7\u00f5es de Aprendizado de M\u00e1quina</p> <ol> <li>Identifica\u00e7\u00e3o de defeitos em imagens de cameras.</li> <li>Detec\u00e7\u00e3o de tumores em imagens m\u00e9dicas.</li> <li>Dete\u00e7\u00e3o de objetos em imagens.</li> <li>Classifica\u00e7\u00e3o de not\u00edcias automaticamente.</li> <li>Atribui\u00e7\u00e3o de sentimentos as not\u00edcias.</li> <li>Remo\u00e7\u00e3o de coment\u00e1rios, artigos ou v\u00eddeos ofensivos.</li> <li>Resumo de longos textos.</li> <li>Cria\u00e7\u00e3o de chatbot e assistentes pessoais.</li> <li>Previs\u00e3o de faturamento.</li> <li>Elasticidade de pre\u00e7o.</li> <li>Reconhecimento facial e de voz.</li> <li>Detec\u00e7\u00e3o de fraude de cart\u00e3o de cr\u00e9dito.</li> <li>Segmenta\u00e7\u00e3o de clientes</li> <li>Recomenda\u00e7\u00e3o de produtos</li> </ol> <p>Tipos de Aprendizado</p> <p>Os 4 principais tipos de aprendizagem s\u00e3o:</p> <ol> <li>Aprendizado Supervisionado</li> <li>Aprendizado N\u00e3o-Supervisionado</li> <li>Aprendizado Semi-Supervisionado</li> <li>Aprendizado por Refor\u00e7o</li> </ol> <p>No aprendizado supervisionado, o conjunto de dados para treinamento utiliza um r\u00f3tulo que identifica a caracter\u00edstica observada, usada para o treinamento do algor\u00edtmo e separa\u00e7\u00e3o dos dados em classes.</p> <p>A aprendizagem supervisionada resolve, basicamente, problemas de Classifica\u00e7\u00e3o e Regress\u00e3o.</p> <p>Tarefa de classifica\u00e7\u00e3o</p> <p>Quando o conjunto de treinamento possui o r\u00f3tulo do fen\u00f4meno observado como uma vari\u00e1vel discreta, dizemos que \u00e9 um problema de classifica\u00e7\u00e3o, ou seja, o algoritmo precisa aprender a classificar os exemplos do conjunto, atrav\u00e9s da interpreta\u00e7\u00e3o de suas caracter\u00edsticas, em r\u00f3tulos ou classes.</p> Figura 1: Classifica\u00e7\u00e3o Fonte: Data Hackers - Medium <p>Vari\u00e1veis discretas s\u00e3o usadas para medir caracter\u00edsticas que podem assumir apenas um n\u00famero finito cont\u00e1vel de valores e, assim, somente fazem sentido valores inteiros. Por exemplo, n\u00famero de filhos, n\u00famero de bact\u00e9rias por litro de leite, n\u00famero de cigarros fumados por dia e etc.</p> <p>Tarefa de regress\u00e3o</p> <p>Quando o conjunto de treinamento possui o r\u00f3tulo do fen\u00f4meno observado como uma vari\u00e1vel real ou cont\u00ednua, como o sal\u00e1rio e o peso, por exemplo. Nesse tipo de tarefa, o algoritmo tenta ajustar um novo ponto, ao conjunto de pontos do conjunto de dados, de modo que apresente a menor dist\u00e2ncia poss\u00edvel dos pontos do conjunto de dados. Por exemplo, peso, sal\u00e1rio, n\u00famero de vendas, pre\u00e7o do produto, propens\u00e3o de compra, n\u00famero de dias at\u00e9 a primeira venda acontecer, etc</p> Figura 2: Regress\u00e3o linear Fonte: Dicion\u00e1rio Financeiro <p>Algoritmos de Aprendizado de M\u00e1quina: Classifica\u00e7\u00e3o</p> <ol> <li>K-Nearest Neighbors</li> <li>Naive Bayes</li> <li>Light Gradient Boost Machine ( LGBM )</li> <li>Categorical Boost ( CatBoost )</li> <li>Logistic Regression</li> <li>Support Vector Machine ( SVM )</li> <li>Decision Tree</li> <li>Random Forests</li> <li>Neural Networks</li> </ol> <p>Algoritmos de Aprendizado de M\u00e1quina: Regress\u00e3o</p> <ol> <li>Linear Regression</li> <li>Polinomial Regression</li> </ol> <p>Refer\u00eancias</p> <ol> <li>Machine Learning 1959: Uma Vis\u00e3o Hist\u00f3rica do Machine Learning - Awari</li> <li>Introdu\u00e7\u00e3o ao Machine Learning: Conceitos B\u00e1sicos - Elaine Cec\u00edlia Gatto - Portal Embarcados</li> <li>O v\u00eddeo para entender Intelig\u00eancia Artificial de verdade - Infinitamente</li> <li>A ideia que causou o nascimento da Intelig\u00eancia Artificial - Infinitamente</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-fundamento_classificacao/","title":"Fundamentos dos Algoritmos de Classifica\u00e7\u00e3o","text":"<p>As origens hist\u00f3ricas do aprendizado de m\u00e1quina podem ser tra\u00e7adas at\u00e9 a d\u00e9cada de 1940, quando os pesquisadores come\u00e7aram a estudar como os c\u00e9rebros humanos processam informa\u00e7\u00f5es. Uma das primeiras abordagens foi o modelo de McCulloch-Pitts (MCP), proposto por Warren McCulloch e Walter Pitts em 1943. Este modelo simplificou o funcionamento de uma c\u00e9lula nervosa como um port\u00e3o l\u00f3gico bin\u00e1rio, onde a sa\u00edda era determinada pela soma ponderada das entradas.</p>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-fundamento_classificacao/#o-algoritmo-perceptron","title":"O Algoritmo Perceptron","text":"<ul> <li>Origem e Funcionamento: Alguns anos ap\u00f3s o modelo McCulloch-Pitts, Frank Rosenblatt em 1957, prop\u00f4s o perceptron, que introduziu uma regra de aprendizado capaz de ajustar automaticamente os coeficientes de peso aplicados \u00e0s caracter\u00edsticas de entrada para decidir se um neur\u00f4nio deve \"disparar\" ou n\u00e3o.</li> <li>Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o: O algoritmo utiliza uma fun\u00e7\u00e3o de degrau unit\u00e1rio (Heaviside) para converter a entrada l\u00edquida em uma sa\u00edda bin\u00e1ria (-1 ou 1).</li> <li>Converg\u00eancia: O perceptron s\u00f3 tem garantia de converg\u00eancia se as duas classes forem linearmente separ\u00e1veis e a taxa de aprendizado for suficientemente pequena.</li> </ul>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-fundamento_classificacao/#neuronios-lineares-adaptativos-adaline","title":"Neur\u00f4nios Lineares Adaptativos (Adaline)","text":"<ul> <li>Melhoria em rela\u00e7\u00e3o ao Perceptron: O Adaline, proposto por Widrow e Hoff, diferencia-se por atualizar os pesos com base em uma fun\u00e7\u00e3o de ativa\u00e7\u00e3o linear cont\u00ednua, e n\u00e3o em uma fun\u00e7\u00e3o de degrau bin\u00e1ria.</li> <li>Otimiza\u00e7\u00e3o e Fun\u00e7\u00e3o de Custo: Ele introduz o conceito crucial de fun\u00e7\u00e3o de custo, especificamente a Soma dos Erros Quadrados (SSE), que \u00e9 minimizada durante o treinamento.</li> <li>Gradiente Descendente: Para encontrar os pesos que minimizam o custo, o Adaline utiliza o algoritmo de gradiente descendente, que acompanha a derivada da fun\u00e7\u00e3o de custo at\u00e9 atingir um m\u00ednimo local ou global.</li> </ul>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-fundamento_classificacao/#tecnicas-de-otimizacao-avancadas","title":"T\u00e9cnicas de Otimiza\u00e7\u00e3o Avan\u00e7adas","text":"<ul> <li>Escalonamento de Caracter\u00edsticas: Algoritmos baseados em gradiente, como o Adaline, operam de forma muito mais eficiente quando os dados passam por padroniza\u00e7\u00e3o (standardization), garantindo que as caracter\u00edsticas estejam em escalas compar\u00e1veis.</li> <li>Gradiente Descendente Estoc\u00e1stico (SGD): Para lidar com grandes volumes de dados onde o gradiente descendente em lote seria caro demais, o autor apresenta o SGD, que atualiza os pesos incrementalmente ap\u00f3s cada amostra de treinamento.</li> <li>Aprendizado Online: O SGD permite o aprendizado online, onde o modelo pode ser treinado e atualizado em tempo real \u00e0 medida que novos dados chegam.</li> </ul>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-fundamento_classificacao/#referencias","title":"Refer\u00eancias","text":"<ol> <li>RASCHKA, Sebastian. Python Machine Learning: unlock deeper insights into machine learning with this vital guide to cutting-edge predictive analytics. Birmingham: Packt Publishing, 2015</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml03-matriz_confusao/","title":"Matriz de confus\u00e3o","text":"<p>A Matriz de confus\u00e3o \u00e9 uma ferramenta para medir a performance de uma algoritmo.</p> <p>Exemplo</p> # 1 2 3 4 5 6 7 8 9 10 11 12 Diag. 1 1 1 1 1 1 1 1 0 0 0 0 Pred. 0 0 1 1 1 1 1 1 1 0 0 0 Figura 1: Matriz de Confus\u00e3o Fonte: Wikipedia <ul> <li>True Positive : Classifica\u00e7\u00e3o correta da classe positiva</li> <li>True Negative : Classifica\u00e7\u00e3o correta da classe negativa</li> <li>False Positive : Classifica\u00e7\u00e3o errada da classe positiva</li> <li>False Negative : Classifica\u00e7\u00e3o errada da class negativa</li> </ul> Figura 2: Classifica\u00e7\u00e3o de elementos e matriz de confus\u00e3o Fonte: Modificado de Wikipedia <p>Acur\u00e1cia</p> \\[ Acur\u00e1cia = \\frac{TP+TN}{P+N} \\] <p>Precis\u00e3o</p> \\[ Precis\u00e3o = \\frac{TP}{TP+FP} \\] <p>Recall</p> \\[ Recall = \\frac{TP}{TP+FN} \\]","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml04-knn/","title":"Nearest Neighbors - KNN (K-vizinhos mais pr\u00f3ximos)","text":"<p>O KNN \u00e9 um algoritmo de Machine Learning da classe de aprendizado supervisionado. </p> <p>Ele pode ser utilizado para resolver problemas de classifica\u00e7\u00e3o e de regress\u00e3o.</p> <p>KNN: Premissas</p> <p>A proximidade entre duas evid\u00eancias de um fen\u00f4meno observado, pode ser representada por uma medida de dist\u00e2ncia.</p> <p>Objetos similares est\u00e3o pr\u00f3ximos uns aos outros, portanto, as caracter\u00edsticas precisam ser num\u00e9ricas. Assim, \u00e9 calculada a dist\u00e2ncia entre um ponto sem r\u00f3tulo e todos os seus K vizinhos mais pr\u00f3ximos, e o r\u00f3tulo que possuir o maior n\u00famero de vizinhos \u00e9 atribu\u00eddo ao ponto. </p> <p>O melhor K \u00e9 obtido testando valores diferentes e calculando o erro do algoritmo. O algoritmo que apresentar o menor erro, possui o melhor K.</p> <p>Exemplos de uso</p> <ul> <li>Sistemas de recomenda\u00e7\u00e3o: Dado um filme, encontre os K filmes mais similares;</li> <li>Classifica\u00e7\u00e3o de not\u00edcias: Dada uma not\u00edcia, em qual categoria ela se encaixa?</li> <li>Classifia\u00e7\u00e3o de cliente: Dado um novo cliente, qual o grupo ele pertence dado o seu perfil?</li> <li>Sistema de busca: Dada uma nova consulta, quais not\u00edcias podem ser retornadas?</li> </ul> <p>Vantagens</p> <ol> <li>O KNN \u00e9 f\u00e1cil de entender e simples de explicar o seu funcionamento.</li> <li>N\u00e3o h\u00e1 a necessidade de construir um modelo, ajustar v\u00e1rios par\u00e2metros ou assumir premissas adicionais.</li> <li>O KNN \u00e9 vers\u00e1til. Ele pode ser usando para resolver problemas de classifica\u00e7\u00e3o, regress\u00e3o e busca.</li> </ol> <p>Desvantagens</p> <ol> <li>O KNN se tornar significativamente devagar quanto mais o n\u00famero de exemplos e/ou preditores aumenta. Com o aumento da dimensionalidade dos dados atrav\u00e9s das colunas, o c\u00e1lculo da dist\u00e2ncia fica mais demorado.</li> <li>Em alta dimensionalidade, a dist\u00e2ncia entre os pontos podem ser distorcidas. Os mesmos pontos podem se aproximar ou se distanciar dependendo da quantidade de colunas na tabela e isso pode alterar os r\u00f3tulos. O que foi classificado como A, pode ser reclassificado como B.</li> </ol> <p>Processo de treino em problema de classifica\u00e7\u00e3o</p> <ol> <li>Carregue os dados</li> <li>Defina o n\u00famero K vizinhos mais pr\u00f3ximos.</li> <li>Para cada exemplo sem r\u00f3tulo:<ol> <li>Calcule a dist\u00e2ncia entre o ponto sem r\u00f3tulo e todos os outros pontos rotulados do conjunto de dados.</li> <li>Encontre o K pontos mais pr\u00f3ximos.</li> <li>Identifique os r\u00f3tulos de cada um dos K vizinhos mais pr\u00f3ximos.</li> <li>Calcule a \u201cmoda\u201d dos K vizinhos mais pr\u00f3ximos.</li> <li>Classifique o ponto sem r\u00f3tulo com a moda de seus k vizinhos mais pr\u00f3ximos</li> </ol> </li> </ol> <p>C\u00e1lculo de Dist\u00e2ncia</p> <p>Dados dois pontos \\(P\\) e \\(Q\\) localizados, respectivamente, nas coordenadas \\((P_x,P_y)\\) e \\((Q_x,Q_y)\\).</p> <ul> <li>Dist\u00e2ncia Euclidiana: \\( d = \\sqrt{ (P_x-Q_x)^2 + (P_y-Q_y)^2 } \\)</li> <li>Dist\u00e2ncia de Manhattan: \\( d = |P_x-Q_x| + |P_y-Q_y| \\)</li> <li>Dist\u00e2ncia de Mahallanobis: \\( d= \\sqrt{ \\frac{(P_x-Q_x)^2 + (P_y-Q_y)^2}{ \\sigma_{xy}^2} } \\)</li> </ul> <p>Exemplo de Aplica\u00e7\u00e3o Simples</p> <p>Objetivo: Desenvolver uma an\u00e1lise simples utilizando o classificar KNN (K Nearest Neighbors). </p> <ul> <li>Dado um plano cartesiano, produzir um conjunto de pontos coordenados (x,y) aleat\u00f3rios, somente no quadrante I, sendo os valores de x e y dentro do intervalo de 0 a 100;</li> <li>Classificar os pontos em dois grupos (GrupoA e GrupoB). O segmento de reta diagonal, da origem (0,0) at\u00e9 o ponto (100,100), separa os grupos;</li> <li>Executar o treinamento do classificador KNN com os dados aleat\u00f3rios;</li> <li>Produzir novos dados aleat\u00f3rios;</li> <li>Fazer a classifica\u00e7\u00e3o com esses novos dados;</li> <li>Produzir m\u00e9trica de performance do algor\u00edtmo/classificador.</li> </ul> <p>Etapas:</p> <ol> <li>Instala\u00e7\u00e3o e importa\u00e7\u00e3o de bibliotecas;</li> <li>Dataset de treino;</li> <li>Aplicar uma regra de classifica\u00e7\u00e3o;</li> <li>Exibir os dados;</li> <li>Treinar o classificador KNN;</li> <li>Produzir a predi\u00e7\u00e3o;</li> <li>Produzir m\u00e9tricas de avalia\u00e7\u00e3o (Acur\u00e1cia, Precis\u00e3o e Recall);</li> <li>Carregar dados de teste;</li> <li>Produzir predi\u00e7\u00e3o;</li> <li>Produzir m\u00e9tricas de avalia\u00e7\u00e3o (Acur\u00e1cia, Precis\u00e3o e Recall).</li> </ol> <p>1. Instala\u00e7\u00e3o e importa\u00e7\u00e3o de bibliotecas <pre><code># Instala\u00e7\u00e3o de bibliotecas\n!pip install pandas\n!pip install scikit-learn\n!pip install matplotlib\n!pip install random\n</code></pre></p> <pre><code># importa\u00e7\u00e3o de bibliotecas\nimport pandas as pd\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn import metrics as mt\nimport matplotlib.pyplot as plt\nimport random\n</code></pre> <p>2. Dataset de treino</p> <p>Neste exemplo de estudo, \u00e9 criado um dataframe com 30 linhas e duas colunas (x e y).</p> <p><pre><code>df = pd.DataFrame(index=range(30), columns=['x', 'y'])\ndf\n</code></pre> </p> <p>Cada uma das linhas recebe valores aleat\u00f3rios para x e y, dentro de um intevalor 0..100.</p> <pre><code>df['x'] = df.apply(lambda x: random.randint(0, 100), axis=1)\ndf['y'] = df.apply(lambda x: random.randint(0, 100), axis=1)\ndf\n</code></pre> <p></p> <p>Plotando o resultado dos pontos coordenados aleat\u00f3rios.</p> <pre><code>plt.plot( df.x, df.y, 'r.' )\nplt.show()\n</code></pre> <p></p> <p>3. Aplicar uma regra de classifica\u00e7\u00e3o</p> <ul> <li>Separar o dataframe em dois grupos:<ul> <li>GrupoA: se valor de x &lt; y</li> <li>GrupoB: se valor de x &gt;= y</li> </ul> </li> </ul> <pre><code>df['Categoria'] = df.apply( lambda x: \"GrupoA\" if x['x'] &lt; x['y'] else \"GrupoB\", axis = 1)\ndf\n</code></pre> <p></p> <p>4. Exibir os dados</p> <p>Filtrando somente elementos do <code>GrupoA</code> em <code>grA</code> somente elementos do <code>GrupoB</code> em <code>grB</code>.</p> <pre><code>grA = df.loc[df.Categoria.values=='GrupoA']\ngrB = df.loc[df.Categoria.values=='GrupoB']\n</code></pre> <p>Plotando os dois grupos, com marcadores diferentes para observar as suas localiza\u00e7\u00f5es.</p> <pre><code>plt.plot( grA.x, grA.y, 'rx' )\nplt.plot( grB.x, grB.y, 'b.' )\nplt.show()\n</code></pre> <p></p> <p>Obs: Exemplo meramente ilustrativo, pois, para cada execu\u00e7\u00e3o do passo 2, novos valores s\u00e3o gerados, produzindo um resultado diferente. </p> <p>5. Treinar o classificador KNN</p> <p>Selecionando as caracter\u00edsticas (features) a serem usadas no treinamento.</p> <pre><code>features = ['x','y']\nlabel = ['Categoria']\n</code></pre> <p>Em label, temos o r\u00f3tulo da coluna de resultado de refer\u00eancia para o treinamento.</p> <p>Separando os dados de treino, <code>x_train</code> para as caracter\u00edsticas e <code>y_train</code> para os r\u00f3tulos. <pre><code>x_train = df.loc[:,features]\ny_train = df.loc[:,label].values.ravel()\n</code></pre></p> <p>Visualizando dados de treino.</p> <pre><code>x_train\n</code></pre> <p></p> <pre><code>y_train\n</code></pre> <p></p> <p>Treinamento do algoritmo KNN.</p> <pre><code>knn_classifier = KNeighborsClassifier( n_neighbors = 8 )\nknn_classifier.fit( x_train, y_train )\n</code></pre> <p>6. Produzir a predi\u00e7\u00e3o</p> <p>Uma predi\u00e7\u00e3o \u00e9 gerada utilizando os mesmos dados de treinamento. <pre><code>y_pred = knn_classifier.predict( x_train )\n</code></pre></p> <p>Inclus\u00e3o de dados de predi\u00e7\u00e3o no dataframe de dados.</p> <p><pre><code>df['Predicao'] = y_pred\ndf\n</code></pre> </p> <p>7. Produzir m\u00e9tricas de avalia\u00e7\u00e3o (Acur\u00e1cia, Precis\u00e3o e Recall)</p> <p>Para a Matriz Confus\u00e3o, s\u00e3o inseridos como par\u00e2metros os r\u00f3tulos de treinamento e os valores de predi\u00e7\u00e3o produzidos pelo classificador treinado.</p> <p><pre><code>mt.confusion_matrix( y_train, y_pred )\n</code></pre> </p> <p>Acur\u00e1cia</p> <pre><code>mt.accuracy_score( y_train, y_pred )\n</code></pre> <pre><code>0.8666666666666667\n</code></pre> <p>Precis\u00e3o <pre><code>mt.precision_score( y_train, y_pred, average=\"binary\", pos_label='GrupoA' )\n</code></pre> <pre><code>0.8\n</code></pre></p> <p>Recall</p> <p><pre><code>mt.recall_score( y_train, y_pred, average='binary', pos_label='GrupoA' )\n</code></pre> <pre><code>0.8\n</code></pre></p> <p>8. Carregar dados de teste</p> <pre><code>dftest = pd.DataFrame(index=range(100), columns=['x', 'y'])\n</code></pre> <pre><code>dftest['x'] = dftest.apply(lambda x: random.randint(0, 100), axis=1)\ndftest['y'] = dftest.apply(lambda x: random.randint(0, 100), axis=1)\ndftest\n</code></pre> <p></p> <p><pre><code>plt.plot( dftest.x, dftest.y, 'r*' )\nplt.show()\n</code></pre> </p> <p>9. Produzir predi\u00e7\u00e3o</p> <p>Previs\u00e3o das observa\u00e7\u00f5es</p> <p><pre><code>y_pred = knn_classifier.predict( dftest[['x','y']] )\n</code></pre> <pre><code>dftest['Predicao'] = y_pred\ndftest\n</code></pre></p> <p></p> <pre><code>dftest['Categoria'] = dftest.apply( lambda x: \"GrupoA\" if x['x'] &lt; x['y'] else \"GrupoB\", axis = 1)\ndftest\n</code></pre> <p></p> <p>10. Produzir m\u00e9tricas de avalia\u00e7\u00e3o (Acur\u00e1cia, Precis\u00e3o e Recall)</p> <p>Para a Matriz Confus\u00e3o, s\u00e3o inseridos como par\u00e2metros os r\u00f3tulos dos dados e os valores de predi\u00e7\u00e3o produzidos pelo classificador treinado.</p> <p><pre><code>mt.confusion_matrix( dftest['Categoria'], dftest['Predicao'] )\n</code></pre> <pre><code>array([[46,  5],\n       [ 3, 46]])\n</code></pre></p> <p>Acur\u00e1cia</p> <p><pre><code>mt.accuracy_score( dftest['Categoria'], dftest['Predicao'] )\n</code></pre> <pre><code>0.92\n</code></pre></p> <p>Precisao <pre><code>mt.precision_score( dftest['Categoria'], dftest['Predicao'], average=\"binary\", pos_label='GrupoA' )\n</code></pre> <pre><code>0.9387755102040817\n</code></pre></p> <p>Recall <pre><code>mt.recall_score( dftest['Categoria'], dftest['Predicao'], average='binary', pos_label='GrupoA' )\n</code></pre> <pre><code>0.9019607843137255\n</code></pre></p> <p>Sele\u00e7\u00e3o dos pontos classificados como <code>True Positive</code>. <pre><code>tp = dftest.loc[ (dftest.Categoria.values=='GrupoA') &amp; (dftest.Predicao.values=='GrupoA') ]\ntp\n</code></pre> </p> <p>Sele\u00e7\u00e3o dos pontos classificados como <code>True Negative</code>. <pre><code>tn = dftest.loc[ (dftest.Categoria.values=='GrupoB') &amp; (dftest.Predicao.values=='GrupoB') ]\ntn\n</code></pre></p> <p></p> <p>Sele\u00e7\u00e3o dos pontos classificados como <code>False Positive</code>. <pre><code>fp = dftest.loc[ (dftest.Categoria.values=='GrupoB') &amp; (dftest.Predicao.values=='GrupoA') ]\nfp\n</code></pre></p> <p></p> <p>Sele\u00e7\u00e3o dos pontos classificados como <code>False Negative</code>. <pre><code>fn = dftest.loc[ (dftest.Categoria.values=='GrupoA') &amp; (dftest.Predicao.values=='GrupoB') ]\nfn\n</code></pre></p> <p></p> <p>Plotando dados classificados de modo a destacar os pontos classificados incorretamente.</p> <pre><code>plt.plot(dftest.index, dftest.index, 'g-');\nplt.plot(tp.x, tp.y, 'r.');\nplt.plot(tn.x, tn.y, 'b.');\nplt.plot(fp.x, fp.y, 'rx');\nplt.plot(fn.x, fn.y, 'bx');\nplt.show()\n</code></pre> <p></p> <p>Exemplo no Kaggle</p> <ul> <li>knn-CreditCardLimitClassification</li> </ul> <p>Refer\u00eancias</p> <ol> <li>O que \u00e9: Dist\u00e2ncia de Mahalanobis - Aprenda estat\u00edstica F\u00e1cil</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml05-regressao_linear/","title":"Regress\u00e3o linear","text":"<p>A regress\u00e3o linear, encontra, atrav\u00e9s de t\u00e9cnicas estat\u00edsticas, a rela\u00e7\u00e3o entre vari\u00e1veis, que no contexto de Machine Learning, significa a rela\u00e7\u00e3o entre atributos e r\u00f3tulo.</p> <p>Como exemplo, temos a tabela a seguir com a rela\u00e7\u00e3o simplificada entre a massa de ve\u00edculos e a efici\u00eancia no consumo de combust\u00edvel. </p> kg km/l 1588 7.74 1674 6.45 1560 7.74 1556 6.88 1969 6.45 2005 6.02 1075 10.32 <p>Ao plotarmos um gr\u00e1fico utilizando os dados da tabela, obtemos o seguinte resultado:</p> Figura 1: Rela\u00e7\u00e3o Massa x Efici\u00eancia em ve\u00edculos Fonte: Adaptado de Regress\u00e3o linear - Google <p>Com isso, o objetivo \u00e9 tra\u00e7ar uma reta que represente os pontos com o menor erro poss\u00edvel, de modo a permitir a extrapola\u00e7\u00e3o de resultados mediante valores que n\u00e3o est\u00e3o na tabela inicial. A Figura 2 ilustra a reta de predi\u00e7\u00e3o. </p> Figura 2: Rela\u00e7\u00e3o Massa x Efici\u00eancia em ve\u00edculos com reta de predi\u00e7\u00e3o Fonte: Adaptado de Regress\u00e3o linear - Google <p>Equa\u00e7\u00e3o de regress\u00e3o linear</p> <p>Em termos alg\u00e9bricos, o modelo \u00e9 definido como </p> \\[y = mx + b\\] <p>em que:</p> <ul> <li>\\(y\\) \u00e9 o valor em km por litro que queremos prever;</li> <li>\\(m\\) \u00e9 a inclina\u00e7\u00e3o da linha, coeficiente angular;</li> <li>\\(x\\) \u00e9 o valor de entrada, neste caso a massa em kg;</li> <li>\\(b\\) \u00e9 a intersec\u00e7\u00e3o com o eixo y.</li> </ul> <p>No aprendizado de m\u00e1quina, escrevemos a equa\u00e7\u00e3o de um modelo de regress\u00e3o linear da seguinte maneira:</p> \\[y' = b + w . x\\] <ul> <li>\\(y'\\) \u00e9 o r\u00f3tulo previsto, ou seja, a sa\u00edda;</li> <li>\\(b\\) \u00e9 o vi\u00e9s (bias) do modelo, \u00e9 um par\u00e2metro calculado durante o treinamento e representa o mesmo conceito da intersec\u00e7\u00e3o de <code>y</code> na equa\u00e7\u00e3o alg\u00e9brica de uma linha;</li> <li>\\(w\\) \u00e9 o peso do elemento. O peso \u00e9 o mesmo conceito da inclina\u00e7\u00e3o da reta na equa\u00e7\u00e3o alg\u00e9brica de uma linha. O peso tamb\u00e9m \u00e9 um par\u00e2metro do modelo calculado durante o treinamento;</li> <li>\\(x\\) \u00e9 um recurso, ou seja, a entrada.</li> </ul> <p>Para uma modelagem com um n\u00famero maior de recursos, ou seja, entradas, como no exemplo, al\u00e9m da massa, poder\u00edamos ter a acelera\u00e7\u00e3o, o n\u00famero de cilindros, a pot\u00eancia, etc, a equa\u00e7\u00e3o ficaria algo como:</p> \\[y' = b + w_1 x_1 + w_2 x_2 + w_3 x_3 + w_4 x_4\\] <p>Sendo os valores de <code>x</code> correspondente as grandezas de entrada e os valors de <code>w</code>, respectivos coefici\u00eantes gerados no treimento. </p> <p>Calculando os coeficientes <code>b</code> e <code>w</code></p> <p>1) Calcular a m\u00e9dia dos valores de <code>x</code> e <code>y</code>:</p> \\[ \\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x_i \\qquad \\qquad \\bar{y} = \\frac{1}{N} \\sum_{i=1}^{N} y_i\\] <pre><code>mean_x = np.mean(data['X'])\nmean_y = np.mean(data['Y'])\n</code></pre> <p>2) Calcular a vari\u00e2ncia populacional para as s\u00e9ries <code>x</code> e <code>y</code>:</p> \\[\\sigma^2_x = \\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\qquad \\qquad \\qquad \\sigma^2_y = \\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\bar{y})^2\\] <pre><code>var_x = np.var(data['X'])\nvar_y = np.var(data['Y'])\n</code></pre> <p>3) Calcular a covari\u00e2ncia entre as s\u00e9ries de dados <code>x</code> e <code>y</code>:</p> \\[cov_{xy} = \\sigma_{xy} = \\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y}) =  \\frac{\\sum_{i=1}^{N} (x_i . y_i) }{N} - {\\bar{x}.\\bar{y}}\\] <pre><code>def covariance(x, y):\n    mean_x = np.mean(x)\n    mean_y = np.mean(y)\n    covar = 0.0\n    for i in range(len(x)):\n        covar += (x[i] - mean_x) * (y[i] - mean_y)\n    return covar/len(x)\n</code></pre> <pre><code>def covariance(x,y):\n  mean_x = np.mean(x)\n  mean_y = np.mean(y)\n  covar = 0.0\n  for i in range(len(x)):\n    covar += x[i]*y[i]\n  return (covar/len(x)) - mean_x * mean_y\n</code></pre> <p>4) Calcular os coeficientes <code>w</code> e <code>b</code>:</p> \\[ w = \\frac{ cov_{xy} }{\\sigma^2_x} \\] <pre><code>w = covar_xy / var_x\n</code></pre> \\[ b = \\bar{y} - w.\\bar{x} \\] <pre><code>b = mean_y - w * mean_x\n</code></pre> <p>Atividade mediada</p> <p>Objetivo:  Encontrar os coeficientes de uma reta que melhor ilustra os pontos do exemplo da Figura 2.</p> <p>Utilizando o Google Colab, execute o c\u00f3digo a seguir:</p> <p>1) Carregar o arquivo de dados (dataset) diretamente do seu computador clicando no bot\u00e3o <code>Upload to session storage</code>, conforme indicado na Figura 3:</p> Figura 3: Carregando um arquivo para \u00e1rea de armazenamento em nuvem Fonte: Autor <p>2) Importar as bibliotecas utilizados no projeto:</p> <pre><code># Biblioteca para manipula\u00e7\u00e3o de conjunto de dados, incluindo arquivos .csv\nimport pandas as pd\n\n# Biblioteca para calculo cient\u00edfico e algebra linear\nimport numpy as np\nimport math\n\n# Bibliotecas para visualiza\u00e7\u00e3o de dados\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n</code></pre> <p>3) Carregar a tabela de dados para a vari\u00e1vel <code>data</code>:</p> <pre><code>data = pd.read_csv('carro_eficiencia.csv')\ndata.info()\n</code></pre> <p>4) Exibir os dados:</p> <pre><code>print(data.columns)\ndata.head(10)\n</code></pre> <p>5) Plotar os dados:</p> <pre><code>fig = px.scatter(x = data['kg'], y=data['km_l'])\nfig.update_layout(title = 'Efici\u00eancia x massa do ve\u00edculo', title_x=0.5, xaxis_title= \"Massa do ve\u00edculo [kg]\", yaxis_title=\"Efici\u00eancia [km/l]\", height = 500, width = 700)\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>6) Estimar os coeficientes de <code>b</code> e <code>w</code>, de forma emp\u00edrica:</p> <pre><code>b = 0.0\nw = 1.0\n\nprint(f'Coeficientes:\\n b: {b} \\n w: {w} \\n \\n y = b + w.x')\n</code></pre> <p>7) Carregar as vari\u00e1veis <code>x</code> e <code>y</code> para facilitar o plot dos dados e calcular <code>y_pred</code> com base nos par\u00e2metros definidos anteriormente. </p> <pre><code>x       = data['kg'].values.copy()\ny       = data['km_l'].values\ny_pred  = b + w * x\n\nprint(f'x: {x}')\nprint(f'\\n\\ny: {y}')\nprint(f'\\n\\ny_hat: {y_pred}')\n</code></pre> <p>8) Plotar dados reais e reta de predi\u00e7\u00e3o:</p> <pre><code>fig = go.Figure()\nfig.add_trace(go.Scatter(x=data['kg'], y=data['km_l'],  name='train',       mode='markers',       marker_color='rgba(152, 0, 0, .8)'))\nfig.add_trace(go.Scatter(x=data['kg'], y=y_pred,        name='prediction',  mode='lines+markers', marker_color='rgba(0, 152, 0, .8)'))\n\nfig.update_layout(title = f'Correla\u00e7\u00e3o de efici\u00eancia pela massa dos ve\u00edculos',title_x=0.5, xaxis_title= \"Massa do ve\u00edculo\", yaxis_title=\"Efici\u00eancia\")\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>Caso a reta n\u00e3o esteja, visualmente ajustada aos pontos, retorne e ajuste os valores de <code>b</code> e <code>w</code>.</p> <p>Exerc\u00edcio: Conjunto de dados de seguros sueco</p> <p>O conjunto de dados chamado <code>Auto Insurance in Sweden</code>  (Seguro Autom\u00f3vel na Su\u00e9cia) e envolve a previs\u00e3o do pagamento total de todas as reivindica\u00e7\u00f5es em milhares de <code>Swedish Krona</code> (Coroas suecas) (y) dado o n\u00famero total de reclama\u00e7\u00f5es (x).</p> <p>Isso significa que, para um novo n\u00famero de reclama\u00e7\u00f5es (x), poderemos prever o pagamento total (y).</p> <p>Elabore uma equa\u00e7\u00e3o de predi\u00e7\u00e3o para o conjunto de dados de seguros suecos.</p> <p>Refer\u00eancias</p> <ol> <li>Regress\u00e3o Linear</li> <li>Kaggle</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml06-k_means/","title":"K-Means Clustering (Clusteriza\u00e7\u00e3o - Agrupamento)","text":"<p>O algoritmo de Lloyd, mais conhecido como K-means, \u00e9 um algoritmo n\u00e3o supervisionado que busca padr\u00f5es para agrupar os elementos, ou seja, produzir clusters, ou grupos com caracter\u00edsticas similares.</p> <p>Cada um desses grupos \u00e9 representado por um centr\u00f3ide, que \u00e9 o ponto m\u00e9dio entre os pontos do grupo.</p> <p>Tomando um exemplo simplificado do gr\u00e1fico de quantidade de compras por volume de produtos comprados, a visualiza\u00e7\u00e3o destes tr\u00eas grupos \u00e9 f\u00e1cil, o que n\u00e3o ocorre em conjunto de dados reais com tanta facilidade. </p> <p></p> <p>A etapa inicial do agrupamento (clusteriza\u00e7\u00e3o) consiste em definir o n\u00famero de centr\u00f3ides que desejamos utilizar. Neste caso tr\u00eas (3). Eles s\u00e3o dispostos em posi\u00e7\u00f5es aleat\u00f3rios inicialmente. </p> <p></p> <p>Em seguida s\u00e3o calculadas as dist\u00e2ncias de cada ponto para todos os centr\u00f3ides, e o ponto recebe uma classifica\u00e7\u00e3o inicial do centr\u00f3ide mais pr\u00f3ximo. </p> <p></p> <p>Em seguida, os centr\u00f3ides s\u00e3o reposicionados de modo a se localizarem na posi\u00e7\u00e3o central em rela\u00e7\u00e3o aos pontos do seu agrupamento. </p> <p></p> <p>Seguem ciclos de c\u00e1lculo das dist\u00e2ncia de cada ponto para os centr\u00f3ides novamente, sendo que alguns pontos trocaram de grupo por estarem, agora, mais pr\u00f3ximos de outro centr\u00f3ide. </p> <p></p> <p>Este ciclo se repete at\u00e9 que n\u00e3o haja mudan\u00e7a de pontos de agrupamentos. </p> <p></p> <p>Como resultado final do algoritmo, temos os tr\u00eas grupos de clientes em uma loja de com\u00e9rcio eletr\u00f4nico, que podem ser classificados com os seguintes perfis: </p> <ul> <li>o grupo de clientes que compram com pouca frequ\u00eancia e poucos produtos;</li> <li>o grupo de clientes que compram com uma frequ\u00eancia maior com um pouco mais de produtos em seus carrinhos;</li> <li>o grupo de clientes mais valioso, pois s\u00e3o aqueles que possuem um frequ\u00eancia de compra alta e compram muitos produtos. </li> </ul> Intera\u00e7\u00e3o do centr\u00f3ide no processo de clusteriza\u00e7\u00e3o Fonte: Prof. JH <p>Vantagens</p> <ul> <li>Simples entender e aplicar;</li> <li>Eficiente computacionalmente, permitindo trabalhar com grande quantidade de dados.</li> </ul> <p>Desvantagens</p> <ul> <li>Especificar o n\u00famero de clusters previamente;</li> <li>Para obter boa performance, os clusters devem ser esf\u00e9ricos e densos.</li> </ul> <p>Atividade mediada</p> <p>Objetivo: Compreender o uso do algoritmo K-Means e definir o n\u00famero de K agrupamentos. </p> <p>1) Utilize o Google Colab ou jupyter notebook;</p> <p>2) Carregar o arquivo de dados: cluster_data.csv;</p> <p>3) Importar bibliotecas:</p> <pre><code>import pandas as pd\nfrom sklearn.cluster import KMeans\nfrom sklearn import metrics\nimport matplotlib.pyplot as plt\n</code></pre> <p>4) Carregar dataset:</p> <pre><code>data = pd.read_csv('cluster_data.csv')\ndata\n</code></pre> <p>5) Selecionar as caracter\u00edsticas para a vari\u00e1vel x:</p> <pre><code>x = data.loc[:,['Feature 1', 'Feature 2']]\nx\n</code></pre> <p>6) Plotar os dados:</p> <pre><code>fig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'])\nplt.show()\n</code></pre> <p>7) Aplicar o algoritmo K-Means com n\u00famero de clusters = 2:</p> <pre><code>kmeans2 = KMeans(n_clusters=2).fit(x)\n</code></pre> <p>8) Exibir os r\u00f3tulos de agrupamento:</p> <pre><code>kmeans2.labels_\n</code></pre> <p>9) Plotar 2 agrupamentos:</p> <pre><code>fig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'], c=kmeans2.labels_)\nplt.show()\n</code></pre> <p>10) Plotar 3 agrupamentos:</p> <pre><code>kmeans3 = KMeans(n_clusters=3).fit(x)\nkmeans3.labels_\nfig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'], c=kmeans3.labels_)\nplt.show()\n</code></pre> <p>11) Plotar 4 agrupamentos:</p> <pre><code>kmeans4 = KMeans(n_clusters=4).fit(x)\nkmeans4.labels_\nfig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'], c=kmeans4.labels_)\nplt.show()\n</code></pre> <p>12) Plotar 5 agrupamentos:</p> <pre><code>kmeans5 = KMeans(n_clusters=5).fit(x)\nkmeans5.labels_\nfig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'], c=kmeans5.labels_)\nplt.show()\n</code></pre> <p>13) Plotar 6 agrupamentos:</p> <pre><code>kmeans6 = KMeans(n_clusters=6).fit(x)\nkmeans6.labels_\nfig, ax = plt.subplots()\nax.scatter(x['Feature 1'], x['Feature 2'], c=kmeans6.labels_)\nplt.show()\n</code></pre> <p>14) Percorrendo diferentes valores de K:</p> <pre><code>valores_k = [] \ninercias =  []\n\nfor i in range(1,15):\n  kmeans = KMeans(n_clusters=i, random_state=0).fit(x)\n  valores_k.append(i)\n  inercias.append(kmeans.inertia_)\n\nfig, ax = plt.subplots()\nax.plot(valores_k, inercias)\nplt.show()\n</code></pre> <p>15) Plotar agrupamentos de k=2 e k=3:</p> <pre><code>fig, ax = plt.subplots(ncols=2, figsize=(15,6))\nax[0].scatter(x['Feature 1'], x['Feature 2'], c=kmeans2.labels_)\nax[1].scatter(x['Feature 1'], x['Feature 2'], c=kmeans3.labels_)\nplt.show()\n</code></pre> <p>16) Coeficiente Silhueta para K=2:</p> <pre><code>metrics.silhouette_score(x, kmeans2.labels_)\n</code></pre> <p>17) Coeficiente Silhueta para K=3:</p> <pre><code>metrics.silhouette_score(x, kmeans3.labels_)\n</code></pre> <p>18) Percorrendo diferentes valores de K:</p> <pre><code>valores_k = []\ns = [] \n\nfor i in range(2,15):\n  kmeans = KMeans(n_clusters=i,random_state=0).fit(x)\n  valores_k.append(i)\n  s.append(metrics.silhouette_score(x, kmeans.labels_))\n</code></pre> <p>19) Plotar silhueta para diferentes valores de K <pre><code>fig, ax = plt.subplots()\nax.plot(valores_k, s)\nplt.show()\n</code></pre></p> <p>Refer\u00eancias</p> <ol> <li>O que \u00e9 agrupamento k-means? - IBM</li> <li>Entendendo Clusters e K-Means - Igor Felcam - Medium</li> <li>Scikit learn</li> <li>K means Clustering \u2013 Introduction - geeksforgeeks</li> <li>Como funciona o algoritmo K-Means? - ComunidadeDS</li> <li>Introdu\u00e7\u00e3o ao algoritmo k-means - IA Expert Academy</li> <li>Scikit learn - Clustering</li> <li>Algoritmo K-Means. Passo a passo, com anima\u00e7\u00e3o e c\u00e1lculos! - Prof. JH</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml07-rede_neural/","title":"Rede Neural","text":"<p>Rede Neural \u00e9 um modelo computacional, ou seja, uma representa\u00e7\u00e3o de uma rede baseada no comportamento de um neur\u00f4nio biol\u00f3gico.</p> <p></p> <ul> <li>\\(x_0, x_1, x_2, ..., x_n\\): Sinais de entrada;</li> <li>\\(w_0, w_1, w_2, ... w_n\\): Weight (Peso);</li> <li>\\(\\Sigma\\): Somat\u00f3rio dos sinais de entrada;</li> <li>\\(\\varphi\\): Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o. Opera\u00e7\u00e3o de n\u00e3o linearidade;</li> <li>\\(y\\): Sa\u00edda.</li> </ul> <p>A conex\u00e3o entre v\u00e1rios neur\u00f4nios, organizados em camadas, formam uma rede neural.</p> <p></p> <p>Quando a quantidade de camadas aumenta, surge o termo Deep Learning.</p> <p>O treinamento de um modelo de machine learning consiste em produzir um algoritmo, fornecer valores de entrada e valores de sa\u00edda, de modo que o algoritmo ajuste adequadamente os pesos da rede at\u00e9 que o resultado seja satisfat\u00f3rio. </p> <p></p>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml07-rede_neural/#_1","title":"Rede Neural","text":"<p>C\u00f3digo de exemplo</p> Importa\u00e7\u00e3o de bibliotecas<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n</code></pre> Criando o dataset<pre><code>def get_linear_curve(x, w, b=0, noise_scale=0):\n  return w*x + b + noise_scale*np.random.randn(x.shape[0])\n\nx = np.arange(0, 40.1, 2)\ny = get_linear_curve(x, 1.8, 32, noise_scale=2.5)\n\nplt.scatter(x, y)\nplt.ylabel('\u00b0F', fontsize=20)\nplt.xlabel('\u00b0C', fontsize=20)\n</code></pre> Construindo o modelo: Fun\u00e7\u00e3o forward<pre><code># inputs: Entradas\n# w: weight - peso\n# b: bias - vi\u00e9s\n\ndef forward(inputs, w=1.0, b=0):\n  return w*inputs + b\n</code></pre> <p>Construindo o modelo: Fun\u00e7\u00e3o Erro Quadr\u00e1tico M\u00e9dio<pre><code># mse: Mean Square Error - Erro Quadr\u00e1tico M\u00e9dio\n# y: valores reais\n# ym: valores do modelo\n\ndef mse(y, ym):\n  return (y-ym)**2\n</code></pre> Construindo o modelo: Fun\u00e7\u00e3o de retroalimenta\u00e7\u00e3o<pre><code># inputs: Entradas\n# outputs: Valores de sa\u00edda calculados\n# target: Valores de sa\u00edda reais\n# w: weight - peso\n# b: bias - vi\u00e9s\n# lr: learning rate - taxa de aprendizagem\n\ndef backpropagation(inputs, outputs, targets, w, b, lr):\n  w -= lr*(-2*inputs*(targets-outputs)).mean()\n  b -= lr*(-2*(targets-outputs)).mean()\n\n  return w, b\n</code></pre></p> Construindo o modelo: Fun\u00e7\u00e3o de ajuste dos par\u00e2metros<pre><code># inputs: Entradas\n# target: Valores reais\n# w: weight - peso\n# b: bias - vi\u00e9s\n# epochs: \u00e9pocas - qtd de itera\u00e7\u00f5es\n# lr: learning rate - taxa de aprendizagem\n\ndef model_fit(inputs, target, w, b, epochs = 200, lr = 0.001):\n\n  for epoch in range(epochs):\n\n    outputs = forward(inputs, w, b)\n    loss = np.mean(mse(target, outputs))\n    w, b = backpropagation(inputs, outputs, target, w, b, lr)\n\n    if (epoch+1) % (epochs/10) == 0:\n      print(f'Epoch: [{(epoch+1)}/{epochs}] Loss: [{loss:.4f}]')\n\n  return w, b\n</code></pre> Utilizando o modelo<pre><code># Inicializa\u00e7\u00e3o\n\nw = np.random.randn(1)\nb = np.zeros(1)\n\nw, b = model_fit(x, y, w, b, epochs=20000, lr=0.0008)\nprint(f'w: {w[0]:.3f}, b: {b[0]:.3f}')\n</code></pre> Plotando: Resultado x Valores reais<pre><code>plt.scatter(x, y)\nplt.plot(x, get_linear_curve(x, w, b),'g', lw=3)\n</code></pre> <p>Refer\u00eancias</p> <ol> <li>The Perceptron: A probabilistic Model for information storage and organization in the brain | F. Rosembratt</li> <li>O que \u00e9 Rede Neural Artificial e como funciona | Pesquisador de IA explica | IA Descomplicada</li> <li>Redes Neurais - Introdu\u00e7\u00e3o \u00e0s Redes Neurais - UniVESP</li> <li>Redes Neurais Artificiais</li> <li>O que \u00e9 uma rede neural? - IBM</li> <li>Neur\u00f4nios e Redes Neurais Artificiais - Blog do Nei</li> <li>Introdu\u00e7\u00e3o completa a Redes Neurais em Python utilizando Tensorflow/Keras - Pedro Didier</li> <li>Redes Neurais e Machine Learning | Nerdologia Tech</li> <li>Rede neural do zero em Python: Modelo b\u00e1sico | Machine Learning para humanos</li> <li>ep13 Treino, teste e valida\u00e7\u00e3o | C\u00e9rebro Eletr\u00f4nico IFSP</li> <li>APRENDA REDES NEURAIS EM PYTHON - TEORIA E PR\u00c1TICA | Intelig\u00eancia Mil Grau</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ml08-fuzzy/","title":"Rede Neural","text":"<p>Refer\u00eancias</p> <ol> <li>Fuzzy Logic: Definition, Meaning, Examples, and History</li> <li>Fuzzy Logic in AI Explained for Beginners | Fuzzy Logic in Artificial Intelligence | Scaler</li> <li> Fuzzy Logic in Artificial Intelligence | Introduction to Fuzzy Logic &amp; Membership Function | Edureka</li> <li>What Is Fuzzy Logic? | Fuzzy Logic, Part 1 - MATLAB</li> <li>PID vs. Other Control Methods: What's the Best Choice</li> <li></li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"dados/ml/ans/ml05-regressao_linear/","title":"Regress\u00e3o linear - Atividade mediada","text":"<p>Objetivo:  Encontrar os coeficientes de uma reta que melhor ilustra os pontos do exemplo da Figura 1.</p> Figura 1: Rela\u00e7\u00e3o Massa x Efici\u00eancia em ve\u00edculos com reta de predi\u00e7\u00e3o Fonte: Adaptado de Regress\u00e3o linear - Google <p>Utilizando o Google Colab, execute o c\u00f3digo a seguir:</p> <p>Carregue o arquivo de dados diretamente do seu computador clicando no bot\u00e3o <code>Upload to session storage</code>, conforme indicado na Figura 2:</p> Figura 2: Carregando um arquivo para \u00e1rea de armazenamento em nuvem Fonte: Autor <p>1) O dataset utilizado pode ser baixado aqui.</p> <p>2) Importando as bibliotecas:</p> <pre><code># Biblioteca para manipula\u00e7\u00e3o de conjunto de dados, incluindo arquivos .csv\nimport pandas as pd\n\n# Biblioteca para calculo cient\u00edfico e algebra linear\nimport numpy as np\nimport math\n\n# Bibliotecas para visualiza\u00e7\u00e3o de dados\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n</code></pre> <p>3) Realizando a leitura da tabela de dados para a vari\u00e1vel <code>data</code>:</p> <pre><code>data = pd.read_csv('carro_eficiencia.csv')\ndata.info()\n</code></pre> <p>4) Exibindo os dados:</p> <pre><code>print(data.columns)\ndata.head(10)\n</code></pre> <p>5) Plotando os dados:</p> <pre><code>fig = px.scatter(x = data['kg'], y=data['km_l'])\nfig.update_layout(title = 'Efici\u00eancia x massa do ve\u00edculo', title_x=0.5, xaxis_title= \"Massa do ve\u00edculo [kg]\", yaxis_title=\"Efici\u00eancia [km/l]\", height = 500, width = 700)\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>6) Calculando coeficientes <code>b</code> e <code>w</code>, de forma estat\u00edstica:</p> <pre><code>mean_x = np.mean(data['kg'])\nmean_y = np.mean(data['km_l'])\n\nvar_x = np.var(data['kg'])\nvar_y = np.var(data['km_l'])\n\n\nprint('x stats: mean= %.3f   variance= %.3f' % (mean_x, var_x))\nprint('y stats: mean= %.3f   variance= %.3f' % (mean_y, var_y))\n\n\n# Calcula a covari\u00e2ncia entre x e y\ndef covariance(x, y):\n    mean_x = np.mean(x)\n    mean_y = np.mean(y)\n    covar = 0.0\n    for i in range(len(x)):\n        covar += (x[i] - mean_x) * (y[i] - mean_y)\n    return covar/len(x)\n\n\ncovar_xy = covariance(data['kg'], data['km_l'])\nprint(f'Cov(kg,km_l): {covar_xy}')\n\n\nw = covar_xy / var_x\nb = mean_y - w1 * mean_x\n\nprint(f'Coeficientes:\\n b: {b}  w: {w} \\n \\n y = b + w.x')\n</code></pre> <p>7) Carregando vari\u00e1veis <code>x</code> e <code>y</code> para facilitar plot dos dados e calculando <code>y_pred</code> com base nos par\u00e2metros definidos anteriormente:</p> <pre><code>x       = data['kg'].values.copy()\ny       = data['km_l'].values\ny_pred  = b + w * x\n\nprint(f'x: {x}')\nprint(f'\\n\\ny: {y}')\nprint(f'\\n\\ny_hat: {y_pred}')\n</code></pre> <p>8) Plotando dados reais e reta de predi\u00e7\u00e3o:</p> <pre><code>fig = go.Figure()\nfig.add_trace(go.Scatter(x=data['kg'], y=data['km_l'],  name='train',       mode='markers',       marker_color='rgba(152, 0, 0, .8)'))\nfig.add_trace(go.Scatter(x=data['kg'], y=y_pred,        name='prediction',  mode='lines+markers', marker_color='rgba(0, 152, 0, .8)'))\n\nfig.update_layout(title = f'Correla\u00e7\u00e3o de efici\u00eancia pela massa dos ve\u00edculos',title_x=0.5, xaxis_title= \"Massa do ve\u00edculo\", yaxis_title=\"Efici\u00eancia\")\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>Exerc\u00edcio: Conjunto de dados de seguros sueco</p> <p>O conjunto de dados chamado <code>Auto Insurance in Sweden</code> (Seguro Autom\u00f3vel na Su\u00e9cia) e envolve a previs\u00e3o do pagamento total de todas as reivindica\u00e7\u00f5es em milhares de <code>Swedish Krona</code> (Coroas suecas) (y) dado o n\u00famero total de reclama\u00e7\u00f5es (x).</p> <p>Isso significa que, para um novo n\u00famero de reclama\u00e7\u00f5es (x), poderemos prever o pagamento total (y).</p> <p>Elabora uma equa\u00e7\u00e3o de predi\u00e7\u00e3o para o conjunto de dados de seguros suecos.</p> <p>1) O dataset utilizado pode ser baixado aqui.</p> <p>2) Importando as bibliotecas:</p> <pre><code># Biblioteca para manipula\u00e7\u00e3o de conjunto de dados, incluindo arquivos .csv\nimport pandas as pd\n\n# Biblioteca para calculo cient\u00edfico e algebra linear\nimport numpy as np\nimport math\n\n# Bibliotecas para visualiza\u00e7\u00e3o de dados\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\n</code></pre> <p>3) Realizando a leitura da tabela de dados para a vari\u00e1vel <code>data</code>:</p> <pre><code>data = pd.read_csv('swedish_insurance.csv')\ndata.info()\n</code></pre> <p>4) Exibindo os dados:</p> <pre><code>print(data.columns)\ndata.head(10)\n</code></pre> <p>5) Plotando os dados:</p> <pre><code>fig = px.scatter(x = data['X'], y=data['Y'])\nfig.update_layout(title = 'Previs\u00e3o de pagamento de Seguros de Autom\u00f3vel na Su\u00e9cia', title_x=0.5, xaxis_title= \"N\u00fam. de Reclama\u00e7\u00f5es\", yaxis_title=\"Pagamento Total [kr]\", height = 500, width = 700)\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>6) Calculando coeficientes <code>b</code> e <code>w</code>, de forma estat\u00edstica:</p> <pre><code># M\u00e9dia\nmean_x = np.mean(data['X'])\nmean_y = np.mean(data['Y'])\n\n# Vari\u00e2ncia \nvar_x = np.var(data['X'])\nvar_y = np.var(data['Y'])\n\n\nprint('x stats: mean= %.3f   variance= %.3f' % (mean_x, var_x))\nprint('y stats: mean= %.3f   variance= %.3f' % (mean_y, var_y))\n\n\n# Fun\u00e7\u00e3o para c\u00e1lculo da covari\u00e2ncia entre x e y\ndef covariance(x,y):\n  mean_x = np.mean(x)\n  mean_y = np.mean(y)\n  covar = 0.0\n  for i in range(len(x)):\n    covar += x[i]*y[i]\n  return (covar/len(x)) - mean_x * mean_y\n\n\n# Covari\u00e2ncia entre x e y\ncovar_xy = covariance(data['X'], data['Y'])\nprint(f'Cov(x,y): {covar_xy}')\n\n# C\u00e1lculo dos coefici\u00eantes w e b\nw = covar_xy / var_x\nb = mean_y - w * mean_x\n\nprint(f'Coeficientes:\\n b: {b}  w: {w} \\n \\n y = b + w.x\\n\\n')\nprint(f'y = {b:.3f} + {w:.3f} * x')\n</code></pre> <p>7) Carregando vari\u00e1veis <code>x</code> e <code>y</code> para facilitar plot dos dados e calculando <code>y_pred</code> com base nos par\u00e2metros definidos anteriormente:</p> <pre><code>x       = data['X'].values.copy()\ny       = data['Y'].values\ny_pred  = b + w * x\n\nprint(f'x: {x}')\nprint(f'\\n\\ny: {y}')\nprint(f'\\n\\ny_hat: {y_pred}')\n</code></pre> <p>8) Plotando dados reais e reta de predi\u00e7\u00e3o:</p> <pre><code>fig = go.Figure()\nfig.add_trace(go.Scatter(x=data['X'], y=data['Y'],  name='train',       mode='markers',       marker_color='rgba(152, 0, 0, .8)'))\nfig.add_trace(go.Scatter(x=data['X'], y=y_pred,     name='prediction',  mode='lines+markers', marker_color='rgba(0, 152, 0, .8)'))\n\nfig.update_layout(title = f'Previs\u00e3o de pagamento de Seguros de Autom\u00f3vel na Su\u00e9cia',title_x=0.5, xaxis_title= \"N\u00fam. Reclama\u00e7\u00f5es\", yaxis_title=\"Pagamento [kr]\")\nfig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)\nfig.show()\n</code></pre> <p>Refer\u00eancias</p> <ol> <li>Regress\u00e3o Linear</li> <li>Kaggle</li> </ol>","tags":["Ci\u00eancia de Dados","Intelig\u00eancia Artificial","Aprendizado de M\u00e1quina"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/","title":"1. Sa\u00edda Digital","text":"","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#saida-digital-digital-output","title":"Sa\u00edda Digital - Digital Output","text":"<p>Uma sa\u00edda digital \u00e9 o recurso que permite ao microcontrolador interagir com o mundo externo, enviando sinais que possuem apenas dois estados poss\u00edveis: ligado ou desligado. No ecossistema Arduino, isso significa que a tens\u00e3o em um pino configurado como sa\u00edda ser\u00e1 alternada entre o n\u00edvel l\u00f3gico alto (HIGH), correspondente a 5V (ou 3,3V dependendo do modelo), e o n\u00edvel l\u00f3gico baixo (LOW), correspondente a 0V ou terra (GND).</p> <p>Para configurar e usar uma sa\u00edda digital, segue-se o procedimento abaixo:</p>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#1-configuracao-funcao-setup","title":"1. Configura\u00e7\u00e3o (Fun\u00e7\u00e3o <code>setup</code>)","text":"<p>Antes de utilizar um pino, voc\u00ea deve configur\u00e1-lo, para que ele funcione como uma sa\u00edda. Isso \u00e9 feito atrav\u00e9s da fun\u00e7\u00e3o <code>pinMode(pin, mode)</code>, que deve ser executada dentro da fun\u00e7\u00e3o <code>setup()</code>.</p> <ul> <li>Par\u00e2metros <ul> <li>pin: Pino do arduino a ser configurado, no Uno de 0 a 13;</li> <li>mode: <code>INPUT</code>, <code>OUTPUT</code> ou <code>INPUT_PULLUP</code>;</li> </ul> </li> <li>Sintaxe: <code>pinMode(pino, OUTPUT);</code></li> <li>Exemplo: <code>pinMode(13, OUTPUT);</code> define o pino 13 como sa\u00edda.</li> <li>Nota t\u00e9cnica: Internamente, esse comando escreve o valor '1' no bit correspondente do registrador de dire\u00e7\u00e3o de dados (DDRx) do microcontrolador.</li> </ul>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#2-uso-funcao-loop","title":"2. Uso (Fun\u00e7\u00e3o <code>loop</code>)","text":"<p>Ap\u00f3s a configura\u00e7\u00e3o, voc\u00ea controla o estado do pino usando a fun\u00e7\u00e3o <code>digitalWrite()</code>, que define se o dispositivo conectado receber\u00e1 ou n\u00e3o energia.</p> <ul> <li>Sintaxe: <code>digitalWrite(pino, HIGH);</code> para aplicar tens\u00e3o (5V) e ligar o componente.</li> <li>Sintaxe: <code>digitalWrite(pino, LOW);</code> para aplicar a tens\u00e3o (0V) e desligar o componente.</li> </ul> <p>No lugar das defini\u00e7\u00f5es <code>HIGH</code> e <code>LOW</code> podem ser usados os valores <code>1</code> e <code>0</code>, respectivamente. </p> <ul> <li>Sintaxe: <code>digitalWrite(pino, 1);</code> para aplicar tens\u00e3o (5V) e ligar o componente.</li> <li>Sintaxe: <code>digitalWrite(pino, 0);</code> para aplicar a tens\u00e3o (0V) e desligar o componente.</li> </ul>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#consideracoes-praticas-e-eletricas","title":"Considera\u00e7\u00f5es Pr\u00e1ticas e El\u00e9tricas","text":"<ul> <li>Pinos Dispon\u00edveis: O Arduino Uno possui 14 pinos digitais (0 a 13). Recomenda-se evitar o uso dos pinos 0 e 1, pois s\u00e3o utilizados para a comunica\u00e7\u00e3o serial com o computador.</li> <li>Capacidade de Corrente: Cada pino pode fornecer ou drenar uma corrente de at\u00e9 40 mA (sendo recomendado manter-se em 20 mA para seguran\u00e7a), o que \u00e9 suficiente para acender um LED diretamente, desde que se utilize um resistor limitador para n\u00e3o queimar o componente.</li> <li>Atividade Blink: O exemplo mais comum de uso \u00e9 o programa \"Blink\", que alterna o estado de um LED entre HIGH e LOW em intervalos de tempo definidos pela fun\u00e7\u00e3o <code>delay(ms)</code>.</li> </ul> <p>Ao conectar cargas que exijam correntes maiores, como motores ou l\u00e2mpadas de corrente alternada, a sa\u00edda digital deve ser conectada a um circuito de interface, como um transistor, rel\u00e9 ou driver de corrente.</p>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#blink-ou-pisca-led","title":"Blink ou Pisca LED","text":"<p>A atividade Pisca LED ou Blink \u00e9 considerada o \"Hello World!\" dos sistemas embarcados e microcontroladores. Ela consiste em um programa b\u00e1sico cujo \u00fanico objetivo \u00e9 fazer um LED piscar em uma frequ\u00eancia determinada, servindo como a primeira prova de conceito para verificar se o hardware, o compilador e o processo de grava\u00e7\u00e3o est\u00e3o funcionando corretamente.</p> <p>A l\u00f3gica fundamental dessa atividade segue um ciclo de quatro passos executados dentro de um la\u00e7o infinito:</p> <ol> <li>Ligar o LED, aplicando o n\u00edvel l\u00f3gico alto no pino em que o LED est\u00e1 ligado.</li> <li>Aguardar um tempo, geralmente 1 segundo ou 500 ms.</li> <li>Desligar o LED, aplicar n\u00edvel l\u00f3gico baixo no pino do LED.</li> <li>Aguardar novamente o tempo antes de reiniciar o ciclo.</li> </ol>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#formas-de-implementacao","title":"Formas de Implementa\u00e7\u00e3o","text":"<p>Dependendo da plataforma e linguagem utilizada, a implementa\u00e7\u00e3o varia:</p> <ul> <li>No Arduino (Linguagem Wiring/C++): \u00c9 o exemplo mais popular, dispon\u00edvel nativamente na IDE. Utiliza as fun\u00e7\u00f5es <code>pinMode()</code> para configurar o pino como sa\u00edda, <code>digitalWrite()</code> para alterar o estado e <code>delay()</code> para as pausas.</li> <li>Em Linguagem C (AVR-GCC): O programador utiliza macros para manipula\u00e7\u00e3o direta de bits nos registradores (como <code>set_bit</code> e <code>clr_bit</code>) e bibliotecas de utilit\u00e1rios de tempo, como a <code>&lt;util/delay.h&gt;</code>.</li> <li>Em Assembly: \u00c9 a forma mais complexa e pr\u00f3xima do hardware, onde o programador utiliza instru\u00e7\u00f5es de baixo n\u00edvel (como <code>SBI</code> para ativar e <code>CBI</code> para limpar bits) e cria sub-rotinas de atraso decrementando valores em registradores de trabalho.</li> </ul> <p>A implementa\u00e7\u00e3o do Blink como c\u00f3digo introduz um conceito vital nos sistemas embarcados: o loop infinito. Diferente de programas de computador de uso geral que t\u00eam um fim, o software de um sistema embarcado deve rodar continuamente enquanto o dispositivo estiver ligado ou at\u00e9 que sofra um reset. Sem esse la\u00e7o de repeti\u00e7\u00e3o, o LED mudaria de estado apenas uma vez e o hardware permaneceria in\u00fatil.</p> <p>Seguem algumas montagens de circuito pisca LED em simuladores:</p> Figura: Montagem de pisca LED no TinkerCad Fonte: Autor Pisca LED em liga\u00e7\u00e3o do pino como fonte (Source) Pisca LED em liga\u00e7\u00e3o do pino como dreno (Sink)","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#codigo-fonte","title":"C\u00f3digo Fonte","text":"<pre><code>void setup()\n{\n    pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop()\n{\n    digitalWrite(LED_BUILTIN, HIGH);  \n    delay(1000); \n    digitalWrite(LED_BUILTIN, LOW);\n    delay(1000); \n}\n</code></pre>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno01-digital_output/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Arduino Builtin Examples - Blink</li> </ol>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/","title":"2. Entrada Digital","text":"","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/#entrada-digital-digital-input","title":"Entrada Digital - Digital Input","text":"<p>Uma entrada digital \u00e9 uma interface que permite ao microcontrolador ler e interpretar sinais bin\u00e1rios vindos do ambiente externo. Esses sinais possuem apenas dois estados poss\u00edveis: ligado ou desligado, representados logicamente como '1' (HIGH) e '0' (LOW). No contexto el\u00e9trico, o n\u00edvel LOW corresponde geralmente a 0V (GND), enquanto o n\u00edvel HIGH corresponde \u00e0 tens\u00e3o de alimenta\u00e7\u00e3o do circuito, como 5V ou 3,3V.</p> <p>Para utilizar uma entrada digital, \u00e9 necess\u00e1rio seguir passos de configura\u00e7\u00e3o tanto em hardware quanto em software:</p>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/#1-configuracao-funcao-setup","title":"1. Configura\u00e7\u00e3o (Fun\u00e7\u00e3o <code>setup</code>)","text":"<p>No Arduino Uno, existem 14 pinos digitais (0 a 13) que podem ser usados como entradas. Pinos anal\u00f3gicos (A0 a A5) tamb\u00e9m podem ser configurados para funcionar como entradas digitais. Recomenda-se evitar o uso dos pinos 0 e 1, pois s\u00e3o reservados para a comunica\u00e7\u00e3o serial USB.</p> <p>Antes de utilizar um pino, voc\u00ea deve configur\u00e1-lo, para que ele funcione como uma entrada. Isso \u00e9 feito atrav\u00e9s da fun\u00e7\u00e3o <code>pinMode(pin, mode)</code>, que deve ser executada dentro da fun\u00e7\u00e3o <code>setup()</code>.</p> <ul> <li>Par\u00e2metros <ul> <li>pin: Pino do arduino a ser configurado, no Uno de 0 a 13;</li> <li>mode: <code>INPUT</code> ou <code>INPUT_PULLUP</code>;</li> </ul> </li> <li>Sintaxe: <code>pinMode(pino, INPUT);</code> ou <code>pinMode(pino, INPUT_PULLUP);</code></li> <li>Exemplo: <code>pinMode(8, INPUT);</code> define o pino 8 como entrada.</li> <li>Nota t\u00e9cnica: Internamente, esse comando escreve o valor '0' no bit correspondente do registrador de dire\u00e7\u00e3o de dados (DDRx) do microcontrolador.</li> </ul>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/#2-uso-funcao-loop","title":"2. Uso (Fun\u00e7\u00e3o <code>loop</code>)","text":"<p>Ap\u00f3s a configura\u00e7\u00e3o, voc\u00ea pode ler o estado do pino usando a fun\u00e7\u00e3o <code>digitalRead(pin)</code>, que retorna o valor HIGH ou LOW, respectivamente <code>1</code> ou <code>0</code>. </p> <ul> <li>Sintaxe: <code>digitalRead(pino);</code> para ler o estado l\u00f3gico do pino.</li> </ul>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/#3-consideracoes-praticas-e-eletricas","title":"3. Considera\u00e7\u00f5es Pr\u00e1ticas e El\u00e9tricas","text":"<p>Um pino configurado como entrada n\u00e3o deve ficar \"flutuando\" (desconectado), pois ru\u00eddos podem causar leituras inst\u00e1veis. Por isso, utilizam-se resistores de pull-up (conectando ao VCC) ou pull-down (conectando ao GND). O microcontrolador ATmega328 possui resistores de pull-up internos que podem ser habilitados via software para simplificar o circuito.</p> <p>Ao usar bot\u00f5es mec\u00e2nicos, ocorre o fen\u00f4meno do bounce (trepida\u00e7\u00e3o dos contatos), que pode ser interpretado como m\u00faltiplos acionamentos r\u00e1pidos. Para corrigir isso, implementa-se o debounce via software, inserindo um pequeno atraso (delay) ap\u00f3s a detec\u00e7\u00e3o do sinal para aguardar a estabiliza\u00e7\u00e3o mec\u00e2nica.</p>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/arduino/uno02-digital_input/#referencias","title":"Refer\u00eancias","text":"<ol> <li> <p>ANDERSON, Rick; CERVO, Dan. Pro Arduino: Arduino Expert Topics and Techniques. New York: Apress, 2013.</p> </li> <li> <p>ATMEL. ATmega328P: 8-bit AVR Microcontroller with 4/8/16/32K Bytes In-System Programmable Flash. Rev. 8161D. [S. l.], 2009.</p> </li> <li> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> </li> <li> <p>MARGOLIS, Michael. Arduino Cookbook. 2. ed. [S. l.]: O'Reilly Media, 2012.</p> </li> <li> <p>MARWEDEL, Peter. Embedded System Design: Embedded Systems Foundations of Cyber-Physical Systems, and the Internet of Things. 4. ed. Dortmund: Springer Nature, 2021.</p> </li> <li> <p>PEREA, Francis. Arduino Essentials. Birmingham: Packt Publishing, 2015.</p> </li> <li> <p>PURDUM, Jack. Beginning C for Arduino: Learn C Programming for the Arduino and Compatible Microcontrollers. New York: Apress, 2012.</p> </li> <li> <p>RUSSELL, David J. Introduction to Embedded Systems: Using ANSI C and the Arduino Development Environment. [S. l.]: Morgan &amp; Claypool, 2010.</p> </li> <li> <p>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. Austin: [s. n.], 2014. v. 1.</p> </li> </ol>","tags":["Arduino UNO"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/","title":"00 - Ferramentas de Desenvolvimento","text":"","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#1-ferramentas-de-desenvolvimento","title":"1. Ferramentas de Desenvolvimento","text":"Componente Modelo Descri\u00e7\u00e3o Microcontrolador AVR - ATMega328P Plataforma Arduino Uno como interface IDE MPLabX Ambiente de Desenvolvimento Integrado - Instala\u00e7\u00e3o Compilador XC8 Instala\u00e7\u00e3o Editor de c\u00f3digo VSCode Zed Notepad++ notepad++ v8.7.7 Construtor de projeto Makefile No Linux: Ferramenta nativa  No Windows:  Power Shell<code>winget install Chocolatey.Chocolatey</code>  Power Shell Admin:  <code>choco install make</code> Gravador do AVR AVRDudess ZakKemble/AVRDUDESS/v2.18 Simulador eletr\u00f4nico SimulIDE Power Shell<code>winget install SimulIDE.SimulIDE</code> Versionamento git Power Shell<code>winget install --id Git.Git -e --source winget</code>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#2-projeto-avr-pisca-led","title":"2. Projeto - AVR Pisca LED","text":"<p>O primeiro programa para dispositivos embarcados, costuma ser um programa para piscar um LED, que serve para testar as ferramentas de compila\u00e7\u00e3o e grava\u00e7\u00e3o, verificando sua integridade e capacidade de execu\u00e7\u00e3o.</p> <p>Este projeto cont\u00e9m um programa m\u00ednimo para piscar um LED na plataforma Arduino Uno, por\u00e9m o seu desenvolvimento se d\u00e1 com a utiliza\u00e7\u00e3o e programa\u00e7\u00e3o do microcontrolador de forma direta, sem a utiliza\u00e7\u00e3o do que chamamos framework Arduino.</p> <p>Para testar a integridade das ferramentas de desenvolvimento aqui utilizadas, no seu computador, siga os passos: </p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#21-baixar-o-projeto-do-servidor-git-codeberg-ou-github","title":"2.1 Baixar o projeto do servidor git (Codeberg ou Github)","text":"<p>2.1.1 No terminal (Windows Power Shell), crie um diret\u00f3rio para armazenar os projetos:</p> <pre><code>mkdir projetos\n</code></pre> <p>2.1.2 Acesso o diret\u00f3rio criado: </p> <pre><code>cd projetos\n</code></pre> <p>2.1.3 Clone o projeto de teste:</p> <p>Github: <pre><code>git clone https://github.com/JoseWRPereira/avr_pisca_led.git\n</code></pre></p> <p>ou</p> <p>Codeberg: <pre><code>git clone https://codeberg.org/JoseWRPereira/avr_pisca_led.git\n</code></pre></p> <p>2.1.4 Acesse o diret\u00f3rio do projeto baixado: </p> <p><pre><code>cd avr_pisca_led\n</code></pre> 2.1.5 Resumo </p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#22-abrir-os-arquivos-de-edicao","title":"2.2 Abrir os arquivos de edi\u00e7\u00e3o","text":"<p>2.2.1 \u00c9 poss\u00edvel abrir o notepad++ com os arquivos .c e .h que houverem no diret\u00f3rio corrente, executando o seguinte comando:  <pre><code>make notepad\n</code></pre></p> <p>2.2.2 V\u00e1 em <code>Arquivo</code>, <code>Abrir...</code> e abra o arquivo <code>makefile.mak</code>. </p> <p>2.2.3 Verifique o local e a vers\u00e3o do compilador conforme ilustra\u00e7\u00e3o. </p> <p>2.2.4 Resumo </p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#23-verificar-a-porta-de-comunicacao-para-gravacao","title":"2.3 Verificar a porta de comunica\u00e7\u00e3o para grava\u00e7\u00e3o","text":"<p>2.3.1 Conecte o Arduino ao conector USB e verifique qual foi a porta alocada para ele: <code>Gerenciador de Dispositivos</code> e a aba <code>Portas(COM e LPT)</code> </p> <p></p> <p>2.3.2 Se necess\u00e1rio ajuste na linha 1 do <code>makefile.mak</code> com a porta de conex\u00e3o com o seu Arduino.</p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#24-compilar-e-gravar-o-projeto","title":"2.4 Compilar e gravar o projeto","text":"<p>2.4.1 Se todos os programas estiverem instalados e nos locais apontados no <code>makefile.mak</code>, ent\u00e3o:</p> <p>2.4.1.1 Para compilar o projeto execute:  </p> <pre><code>make\n</code></pre> <p>2.4.1.2 Para fazer o a grava\u00e7\u00e3o do bin\u00e1rio no microcontrolador(ATmega328P) do Arduino.</p> <pre><code>make flash\n</code></pre> <p>2.4.2 Resumo </p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#25-criando-um-circuito-no-simulide","title":"2.5 Criando um circuito no SimulIDE","text":"<p>2.5.1 Para criar um projeto no SimulIDE, basta abrir o software, e inserir os componentes.</p> <p>2.5.2 Para inserir um componente basta clicar sobre ele, na barra de ferramentas, e arrast\u00e1-lo at\u00e9 a \u00e1rea de trabalho, soltando-o na posi\u00e7\u00e3o desejada.</p> <p>2.5.3 Inserir:</p> <ul> <li>Componentes &gt; Microcontroladores &gt; Arduino &gt; Uno</li> <li>Componentes &gt; Passivos &gt; Resistors &gt; Resistor</li> <li>Componentes &gt; Sa\u00eddas &gt; Leds &gt; LED</li> <li>Componentes &gt; Fontes &gt; Terra (0 V)</li> </ul> <p>2.5.4 Ap\u00f3s inserir todos os componentes na \u00e1rea de trabalho, posicione-os de forma que o circuito fique leg\u00edvel e bem organizado. </p> <ul> <li>Girar: Para girar um componente, basta clicar com o bot\u00e3o direito sobre o elemento, e escolher uma das op\u00e7\u00f5es de girar ou inverter.</li> </ul> <p>5.5 A ferramenta de linha \u00e9 acionada ao posicionar o cursor sobre um terminal de componente, clicando sobre ele, \u00e9 iniciada uma linha de conex\u00e3o, que pode ser estendida, seguindo a orienta\u00e7\u00e3o vertical ou horizontal at\u00e9 o ponto de conex\u00e3o de destino. </p> <p>2.5.6 Resumo  </p>","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr00-devTools/#26-simulacao-de-pisca-led","title":"2.6 Simula\u00e7\u00e3o de Pisca LED","text":"","tags":["Sistemas Embarcados","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/","title":"01 - Entrada/Sa\u00edda Digital","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#entradasaida-digital-digital-inputoutput","title":"Entrada/Sa\u00edda Digital - Digital Input/Output","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#1-saidas-digitais","title":"1. Sa\u00eddas Digitais","text":"<p>Uma sa\u00edda digital \u00e9 um recurso fundamental de um sistema embarcado que permite ao microcontrolador interagir com elementos externos, enviando sinais que possuem apenas dois estados l\u00f3gicos poss\u00edveis: o estado \"ligado\" (on) e o estado \"desligado\" (off). Esses estados s\u00e3o representados, respectivamente, pelos valores bin\u00e1rios '1' e '0'.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#11-representacao-eletrica-e-niveis-logicos","title":"1.1 Representa\u00e7\u00e3o El\u00e9trica e N\u00edveis L\u00f3gicos","text":"<p>Os valores l\u00f3gicos de uma sa\u00edda digital s\u00e3o traduzidos em n\u00edveis de tens\u00e3o espec\u00edficos:</p> <ul> <li>N\u00edvel L\u00f3gico Baixo (0 ou LOW): Corresponde geralmente a 0V (terra ou ground).</li> <li>N\u00edvel L\u00f3gico Alto (1 ou HIGH): Corresponde \u00e0 tens\u00e3o de alimenta\u00e7\u00e3o do circuito, geralmente 5V ou 3,3V.</li> <li>Estado de Alta Imped\u00e2ncia (Z): Representa uma sa\u00edda \"desconectada\" eletricamente, onde o pino n\u00e3o drena nem fornece corrente consider\u00e1vel.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#12-capacidade-eletrica-e-restricoes","title":"1.2 Capacidade El\u00e9trica e Restri\u00e7\u00f5es","text":"<p>As sa\u00eddas digitais possuem limita\u00e7\u00f5es f\u00edsicas que devem ser respeitadas para n\u00e3o danificar o componente:</p> <ul> <li>Limite de Corrente: Cada pino pode fornecer ou receber uma corrente limitada. No caso do ATmega328, o limite \u00e9 de 40 mA por pino, sendo recomendado manter-se em torno de 20 mA para opera\u00e7\u00e3o segura.</li> <li>Drivers Externos: Quando a carga a ser controlada exige mais corrente do que a sa\u00edda pode fornecer (como motores ou rel\u00e9s), \u00e9 necess\u00e1rio utilizar circuitos de interface, como chaves transistorizadas ou CIs de pot\u00eancia como o ULN2003.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#13-funcoes-alternativas","title":"1.3 Fun\u00e7\u00f5es Alternativas","text":"<p>Muitos pinos de sa\u00edda podem ser multiplexados para servir como sa\u00eddas de perif\u00e9ricos internos espec\u00edficos, como:</p> <ul> <li>USART: O pino TXD (transmiss\u00e3o de dados seriais) \u00e9 for\u00e7ado como sa\u00edda sempre que o transmissor est\u00e1 habilitado;</li> <li>PWM: Pinos de compara\u00e7\u00e3o de sa\u00edda (como OC0A, OC1A) enviam sinais de modula\u00e7\u00e3o por largura de pulso para controle de pot\u00eancia;</li> <li>SPI: O pino MOSI atua como a sa\u00edda de dados do mestre na comunica\u00e7\u00e3o serial perif\u00e9rica .</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#14-aplicacoes-comuns","title":"1.4 Aplica\u00e7\u00f5es Comuns","text":"<p>As sa\u00eddas digitais s\u00e3o usadas para controlar uma vasta gama de perif\u00e9ricos, incluindo:</p> <ul> <li>LEDs: Atuando como sinalizadores visuais.</li> <li>Displays: Acionando displays de 7 segmentos ou m\u00f3dulos LCD.</li> <li>Transistores: Para o chaveamento de Reles, Sinaleiros, Motores CC entre outros. </li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#2-entradas-digitais","title":"2. Entradas Digitais","text":"<p>Uma entrada digital \u00e9 o recurso de um sistema embarcado que permite ao microcontrolador ler estados bin\u00e1rios do mundo f\u00edsico. Diferente de um sinal anal\u00f3gico, que \u00e9 cont\u00ednuo, o sinal digital possui apenas dois estados claramente definidos: ligado ou desligado, representados logicamente como '1' e '0'.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#21-representacao-eletrica","title":"2.1 Representa\u00e7\u00e3o El\u00e9trica","text":"<p>Os estados l\u00f3gicos de uma entrada digital s\u00e3o traduzidos por n\u00edveis de tens\u00e3o el\u00e9trica:</p> <ul> <li>N\u00edvel L\u00f3gico Baixo (LOW / 0): Geralmente correspondente a 0V (GND).</li> <li>N\u00edvel L\u00f3gico Alto (HIGH / 1): Geralmente correspondente \u00e0 tens\u00e3o de alimenta\u00e7\u00e3o, como 5V ou 3,3V.</li> <li>Limiares de Tens\u00e3o: Para evitar incertezas, os microcontroladores definem faixas de toler\u00e2ncia. Por exemplo, em alguns sistemas de 3,3V, tens\u00f5es entre 2V e 5V s\u00e3o interpretadas como HIGH, enquanto entre 0V e 1,3V s\u00e3o consideradas LOW.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#22-estado-de-alta-impedancia-hi-z","title":"2.2 Estado de Alta Imped\u00e2ncia (Hi-Z)","text":"<p>Quando um pino \u00e9 configurado como entrada, ele se comporta como uma alta imped\u00e2ncia. Isso significa que o pino atua como se estivesse eletricamente \"desconectado\", permitindo que um dispositivo externo (como um sensor ou bot\u00e3o) controle a tens\u00e3o no pino com facilidade, sem que o microcontrolador interfira nesse sinal.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#23-pinos-flutuantes-e-resistores-de-pull-uppull-down","title":"2.3 Pinos Flutuantes e Resistores de Pull-up/Pull-down","text":"<p>Um pino de entrada nunca deve ser deixado \"flutuando\" (sem conex\u00e3o definida), pois ru\u00eddos eletromagn\u00e9ticos podem causar leituras err\u00e1ticas. Para garantir estabilidade, utilizam-se resistores:</p> <ul> <li>Pull-up: Conecta o pino ao VCC, mantendo-o em n\u00edvel HIGH por padr\u00e3o at\u00e9 que um sinal externo o leve ao GND.</li> <li>Pull-down: Conecta o pino ao GND, mantendo-o em n\u00edvel LOW at\u00e9 que um sinal externo o leve ao VCC.</li> <li>Pull-ups Internos: Microcontroladores modernos, como o ATmega328P, possuem resistores de pull-up internos que podem ser ativados via software, simplificando o circuito externo.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#24-configuracao-e-leitura","title":"2.4 Configura\u00e7\u00e3o e Leitura","text":"<p>No contexto de arquiteturas como a do AVR, o gerenciamento \u00e9 feito por registradores espec\u00edficos:</p> <ul> <li>Configura\u00e7\u00e3o: Deve-se escrever o valor '0' no bit correspondente do registrador DDR (Data Direction Register). No Arduino, usa-se <code>pinMode(pino, INPUT)</code>.</li> <li>Leitura: O estado f\u00edsico do pino \u00e9 lido atrav\u00e9s do registrador PIN (Port Input Pins). No Arduino, utiliza-se a fun\u00e7\u00e3o <code>digitalRead(pino)</code>, que retorna HIGH ou LOW.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#25-desafios-praticos-o-bounce","title":"2.5 Desafios Pr\u00e1ticos: O Bounce","text":"<p>Ao usar entradas digitais com componentes mec\u00e2nicos (como bot\u00f5es), ocorre o fen\u00f4meno do bounce (trepida\u00e7\u00e3o). Devido ao contato f\u00edsico met\u00e1lico, o sinal oscila rapidamente entre 0 e 1 antes de estabilizar. Para evitar que o microcontrolador interprete isso como m\u00faltiplos cliques, \u00e9 necess\u00e1rio implementar t\u00e9cnicas de debounce via software (atrasos) ou hardware (filtros).</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#26-aplicacoes-comuns","title":"2.6 Aplica\u00e7\u00f5es Comuns","text":"<p>As entradas digitais s\u00e3o usadas para interagir uma vasta gama de perif\u00e9ricos, incluindo:</p> <ul> <li>Bot\u00f5es e Chaves T\u00e1cteis: Utilizados para a\u00e7\u00f5es simples como ligar/desligar um acionamento ou processo;</li> <li>Teclados Matriciais: Empregados quando h\u00e1 necessidade de inserir dados complexos, como em controles de acesso por senha num\u00e9rica ou calculadoras, permitindo ler v\u00e1rias teclas com poucos pinos de I/O;</li> <li>Sensores e fins de curso: Detectam a presen\u00e7a de um objeto a ser contato, por exemplo, ou o momento de finalizar uma movimenta\u00e7\u00e3o.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#3-configuracao-e-funcionamento-interno","title":"3. Configura\u00e7\u00e3o e Funcionamento Interno","text":"<p>Em microcontroladores como o ATmega328P (usado no Arduino), o comportamento de um pino como sa\u00edda digital \u00e9 gerenciado por registradores de mem\u00f3ria internos:</p> <ul> <li>DDRx (Data Direction Register): \u00c9 o registrador de dire\u00e7\u00e3o; para configurar um pino como sa\u00edda, o programador deve escrever o valor '1' no bit correspondente deste registrador.</li> <li>PORTx (Data Register): Uma vez configurado como sa\u00edda, a escrita neste registrador define o estado do pino. Escrever <code>1</code> coloca o pino em n\u00edvel alto (VCC) e escrever <code>0</code> coloca-o em n\u00edvel baixo (0V).</li> <li>PINx (Port Input Pins): \u00c9 o registrador exclusivo de leitura. Ao acess\u00e1-lo, o microcontrolador l\u00ea o estado atual do buffer de entrada, que reflete se a tens\u00e3o no pino \u00e9 alta (1) ou baixa (0) no exato momento da leitura.</li> </ul> <p>No ambiente Arduino, essas opera\u00e7\u00f5es s\u00e3o simplificadas pelas fun\u00e7\u00f5es <code>pinMode(pino, OUTPUT)</code> para configura\u00e7\u00e3o, <code>digitalWrite(pino, valor)</code> para o acionamento e <code>digitalRead(pino)</code> para a leitura.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#51-ddr-data-direction-register","title":"5.1 DDR (Data Direction Register)","text":"<p>O DDR \u00e9 o registrador de dire\u00e7\u00e3o de dados. Sua fun\u00e7\u00e3o exclusiva \u00e9 configurar se um pino espec\u00edfico se comportar\u00e1 como uma entrada ou como uma sa\u00edda.</p> <ul> <li>Configura\u00e7\u00e3o como Sa\u00edda: Escreve-se o valor l\u00f3gico '1' no bit correspondente do DDR. Isso habilita um buffer (tri-state) que conecta internamente o registrador de dados ao pino f\u00edsico.</li> <li>Configura\u00e7\u00e3o como Entrada: Escreve-se o valor l\u00f3gico '0' no bit correspondente. Isso desabilita o buffer de sa\u00edda, permitindo que um dispositivo externo controle a tens\u00e3o no pino com seguran\u00e7a.</li> <li>Equival\u00eancia no Arduino: Configurar o DDR \u00e9 o equivalente direto de usar a fun\u00e7\u00e3o <code>pinMode(pino, OUTPUT)</code> ou <code>pinMode(pino, INPUT)</code>.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#52-port-data-register","title":"5.2 PORT (Data Register)","text":"<p>O PORT \u00e9 o registrador de dados, utilizado para definir o estado l\u00f3gico enviado para o pino ou para configurar recursos internos, dependendo da dire\u00e7\u00e3o definida no DDR. Sua fun\u00e7\u00e3o \u00e9 dual:</p> <ul> <li>Quando o pino \u00e9 Sa\u00edda (DDR = 1):<ul> <li>Escrever '1' no bit do PORT coloca o pino em n\u00edvel l\u00f3gico alto (5V ou VCC).</li> <li>Escrever '0' no bit do PORT coloca o pino em n\u00edvel l\u00f3gico baixo (0V ou GND).</li> <li>Equival\u00eancia no Arduino: \u00c9 o equivalente a usar <code>digitalWrite(pino, HIGH)</code> ou <code>digitalWrite(pino, LOW)</code>.</li> </ul> </li> <li>Quando o pino \u00e9 Entrada (DDR = 0):<ul> <li>Escrever '1' no bit do PORT habilita o resistor de pull-up interno para aquele pino. Esse resistor garante um n\u00edvel l\u00f3gico est\u00e1vel quando nada est\u00e1 conectado ao pino.</li> <li>Escrever '0' desabilita o pull-up, deixando o pino em estado de alta imped\u00e2ncia (flutuante).</li> </ul> </li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#53-pin-port-input-pins","title":"5.3 PIN (Port Input Pins)","text":"<p>o registrador PINx \u00e9 utilizado para ler o estado l\u00f3gico atual dos pinos f\u00edsicos do microcontrolador.</p> <ul> <li>Leitura Exclusiva: Na maioria das opera\u00e7\u00f5es, o PINx funciona como um registrador de leitura exclusiva</li> <li>Recurso de Toggle (Invers\u00e3o): Uma caracter\u00edstica espec\u00edfica de arquiteturas AVR mais modernas (como o ATmega328P) \u00e9 que escrever o valor l\u00f3gico '1' em um bit do registrador PINx resulta na invers\u00e3o autom\u00e1tica (toggle) do bit correspondente no registrador de dados PORTx, alternando seu estado entre alto e baixo sem a necessidade de uma opera\u00e7\u00e3o de leitura-modifica\u00e7\u00e3o-escrita complexa.</li> </ul> <p>Internamente, cada bit do registrador PINx possui um hardware de sincroniza\u00e7\u00e3o composto por latches. Isso \u00e9 necess\u00e1rio para evitar o fen\u00f4meno da metaestabilidade, garantindo que o valor lido seja est\u00e1vel mesmo que o sinal externo mude no momento da amostragem do clock interno. Devido a esse hardware de sincroniza\u00e7\u00e3o, existe um atraso de aproximadamente um ciclo de clock para que o dado f\u00edsico chegue ao registrador interno. Por essa raz\u00e3o, se o c\u00f3digo realizar uma leitura do PINx imediatamente ap\u00f3s uma altera\u00e7\u00e3o no DDRx ou PORTx, \u00e9 recomendado assim inserir uma instru\u00e7\u00e3o NOP (nenhuma opera\u00e7\u00e3o) para dar tempo ao hardware de sincronizar o valor correto.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#54-organizacao-e-grupos","title":"5.4 Organiza\u00e7\u00e3o e Grupos","text":"<p>Esses registradores s\u00e3o organizados em grupos (portas) de at\u00e9 8 bits, onde cada bit controla um pino f\u00edsico espec\u00edfico. No ATmega328P, os grupos comuns s\u00e3o:</p> <ul> <li>DDRB / PORTB / PINB: Controlam os pinos digitais 8 a 13 do Arduino.</li> <li>DDRC / PORTC / PINC: Controlam os pinos A0 a A5 do Arduino.</li> <li>DDRD / PORTD / PIND: Controlam os pinos digitais 0 a 7 do Arduino.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#55-resumo-de-funcionamento","title":"5.5 Resumo de Funcionamento","text":"DDR (bit n) PORT (bit n) Modo do Pino Descri\u00e7\u00e3o 0 0 Entrada Alta imped\u00e2ncia (entrada simples). 0 1 Entrada Entrada com resistor de pull-up ativado. 1 0 Sa\u00edda Sa\u00edda em n\u00edvel baixo (0V). 1 1 Sa\u00edda Sa\u00edda em n\u00edvel alto (5V). <p>Manipular esses registradores diretamente \u00e9 uma t\u00e9cnica avan\u00e7ada que permite alterar o estado de at\u00e9 8 pinos simultaneamente com uma \u00fanica linha de c\u00f3digo, o que \u00e9 muito mais r\u00e1pido do que usar fun\u00e7\u00f5es individuais da IDE Arduino.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#56-registradores-port-ddr-e-pin","title":"5.6 Registradores PORT, DDR e PIN","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#57-circuito-geral-dos-pinos-de-entrada-e-saida","title":"5.7 Circuito geral dos pinos de entrada e sa\u00edda","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#58-acionamento-do-circuito-de-entrada-e-saida-em-funcao-do-comando","title":"5.8 Acionamento do circuito de entrada e sa\u00edda em fun\u00e7\u00e3o do comando","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#6-programando","title":"6. Programando","text":"<p>Segue exemplo de uma aplica\u00e7\u00e3o de pisca led condicionado a uma entrada digital. </p> Fun\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Entrada 8 14 PB0 Sa\u00edda 12 18 PB4 Sa\u00edda 13 19 PB5 <pre><code>#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;PINB0))\n        {\n            PORTB |= (1&lt;&lt;PORTB4);\n            PORTB &amp;= ~(1&lt;&lt;PORTB5);\n            _delay_ms(500);\n            PORTB ^= (1&lt;&lt;PORTB4 | 1&lt;&lt;PORTB5);\n            _delay_ms(500);\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;PORTB4);\n            PORTB &amp;= ~(1&lt;&lt;PORTB5);\n        }\n    }\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#61-configurando-entradas-e-saidas","title":"6.1 Configurando Entradas e Sa\u00eddas","text":"<p>Para a configura\u00e7\u00e3o das entradas e sa\u00eddas, \u00e9 necess\u00e1rio que sejam definidos os pinos para cada fun\u00e7\u00e3o da interface na aplica\u00e7\u00e3o. </p> <p>A configura\u00e7\u00e3o dos pinos pode ser realizada de forma unit\u00e1ria ou atrav\u00e9s de uma escrita \u00fanica em cada registrador, configurando todos os pinos representados por ele de uma s\u00f3 vez.</p> <p>Para a configura\u00e7\u00e3o individual de pinos, \u00e9 necess\u00e1rio usar o seguinte padr\u00e3o de ligar um bit ou zer\u00e1-lo:</p> <p>Para ligar (setar) um bit dentro de um registrador: <pre><code>  registrador |= (1&lt;&lt;numero_do_bit);\n</code></pre></p> <p>Para zerar (resetar) um bit dentro de um registrador: <pre><code>  registrador &amp;= ~(1&lt;&lt;numero_do_bit);\n</code></pre> Sendo o <code>numero_do_bit</code> um valor de <code>0</code> a <code>7</code>, ou ainda, podem-ser utilizados os <code>defines</code> declarados na biblioteca, como: <code>PINB0</code> que corresponde ao <code>0</code>, <code>PINB1</code> correpondente ao <code>1</code> e assim por diante. Da mesma forma para os PORT e o DDR: <code>PORTB0</code>, <code>PORTB1</code>,..., e <code>DDRB0</code>, <code>DDRB1</code>, ... </p> <p>Para configurar um pino como entrada, \u00e9 necess\u00e1rio zerar o respectivo bit do registrador <code>DDRx</code> e ligar ou desligar o Resistor de Pull-up interno pelo registrador <code>PORTx</code>.</p> <p>No exemplo, temos que configurar o <code>PB0</code> como entrada. Assim, s\u00e3o utilizados os registradores <code>DDRB</code> para a dire\u00e7\u00e3o de entrada e o <code>PORTB</code> para desabilitar o Resistor de Pull-Up interno, pois no exemplo, \u00e9 utilizado um resistor de Pull-Up externo. <pre><code>    // Configura\u00e7\u00e3o das Entradas\n  DDRB &amp;= ~(1&lt;&lt;0);      // PB0 &lt;- 0\n  PORTB &amp;= ~(1&lt;&lt;0);     // PB0 Pull-up OFF\n</code></pre></p> <p>Ainda no exemplo, temos que configurar e inicializar os pinos de sa\u00edda: PB4 e PB5. Da mesma forma, s\u00e3o utilizados os registradores <code>DDRB</code> para configura\u00e7\u00e3o de sa\u00edda e <code>PORTB</code> para acionar um n\u00edvel l\u00f3gico no pino do microcontrolador.</p> <pre><code>    // Configura\u00e7\u00e3o das Sa\u00eddas\n  DDRB |= (1&lt;&lt;4);       // PB4 &lt;- 1\n  DDRB |= (1&lt;&lt;5);       // PB4 &lt;- 1\n    // Inicializa\u00e7\u00e3o do estado l\u00f3gico dos pinos\n  PORTB &amp;= ~(1&lt;&lt;4);      // PB4 &lt;- 0\n  PORTB &amp;= ~(1&lt;&lt;5);      // PB5 &lt;- 0\n</code></pre> <p>Note que a fun\u00e7\u00e3o do registrador <code>PORTx</code> depende da configura\u00e7\u00e3o do registrador <code>DDRx</code>.</p> <p>No nosso exemplo, todos os pinos utilizados pertencem ao mesmo PORT, assim, \u00e9 poss\u00edvel realizar a configura\u00e7\u00e3o dos tr\u00eas elementos todos de uma \u00fanica vez:</p> <p>O bit 0 (PB0) deve ser configurado como entrada (E) e os bits 4 e 5 (PB4 e PB5) devem ser configurados como sa\u00eddas (S).</p> <pre><code>  // Configura\u00e7\u00e3o do registrador de dire\u00e7\u00e3o de dados (Entrada / Sa\u00edda)\n\n  // DDRx = 0b--SS---E;\n\n  // Onde:\n  //      0b: Nota\u00e7\u00e3o que indica n\u00famero com nota\u00e7\u00e3o bin\u00e1ria.\n  //      E: Entradas (0)\n  //      S: Sa\u00edda (1)\n  //      -: Bit n\u00e3o utilizado.\n\n  // Reescrevendo com os valores adequados no Registrador dos pinos PB0, PB4 e PB5:\n\n  // DDRB = 0b--11---0;\n\n  // Os pinos n\u00e3o utilizados (-) devem ser configurados como entradas (0):\n\n  DDRB = 0b00110000;\n</code></pre> <p>Ap\u00f3s a configura\u00e7\u00e3o do <code>DDRx</code> \u00e9 a vez do <code>PORTx</code>.</p> <pre><code>  // Configura\u00e7\u00e3o de resistor de pull-up para entradas e estado l\u00f3gico para as sa\u00eddas.\n\n  // PORTB = 0b--SS---E;\n  // Onde:\n  //      E: Entradas (0)\n  //      S: Sa\u00edda (1)\n  //      -: Bit n\u00e3o utilizado.\n\n  // Como os bits n\u00e3o utilizados s\u00e3o entradas:\n\n  // PORTB = 0bEESSEEEE;\n\n  // Desligando os resistores de pull-up internos:\n\n  // PORTB = 0b00SS0000;\n\n  // Desligando o estado l\u00f3gico das sa\u00eddas PB4 e PB5:\n\n  PORTB = 0b00000000;\n</code></pre> <p>Os valores carregados nos registradores s\u00e3o costumeiramente notados com valores em hexadecimal:</p> <pre><code>  DDRB  = 0x30;\n  PORTB = 0x00;\n</code></pre> <p>Qualquer forma de configura\u00e7\u00e3o pode ser utilizada, tanto um bit por vez quanto a escrita integral dos registradores, anotados com valores em bin\u00e1rio, decimal ou hexadecimal.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Controladores/avr_atmega328p/avr01-digital_io/#62-resumo-da-configuracao-dos-pinos-no-atmega328p","title":"6.2 Resumo da configura\u00e7\u00e3o dos pinos no ATmega328P","text":"<pre><code>///////////////////////////////////////////////////////////////////////////////\n//  Registradores de configura\u00e7\u00e3o e manipula\u00e7\u00e3o de dados nos pinos\n//\n//        DDRxn   :   Data Direction Register\n//        PORTxn  :   Data Register\n//        PINxn   :   Input Pin Address\n//\n//        ===================\n//        x |        n\n//        ===================\n//        B | 7 6 5 4 3 2 1 0\n//        C |   6 5 4 3 2 1 0\n//        D | 7 6 5 4 3 2 1 0\n//        E |         3 2 1 0\n//        ===================\n//\n//  Configura\u00e7\u00e3o e Manipula\u00e7\u00e3o de dados nos pinos\n//\n//        DDRxn = 1;          // Output\n//            {\n//                PORTxn = 1; //          High\n//                PORTxn = 0; //          Low\n//            }\n//\n//        DDRxn = 0;          // Input\n//            {\n//                PORTxn = 0; //          Pull-Up Resistor OFF\n//                PORTxn = 1; //          Pull-Up Resistor ON\n//                {\n//                    (PINxn == 1)    //  ON\n//                    (PINxn == 0)    //  OFF\n//                }\n//            }\n//        \n////////////////////////////////////////////////////////////////////////////////\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/PCI/KiCad/1-KiCad/","title":"1 - KiCad","text":"","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#_2","title":"1 - KiCad","text":"<p>O KiCad \u00e9 um pacote de software livre e de c\u00f3digo aberto voltada para a automa\u00e7\u00e3o de design eletr\u00f4nico (EDA). Ele oferece ferramentas completas para a cria\u00e7\u00e3o de circuitos eletr\u00f4nicos, incluindo captura de esquemas, simula\u00e7\u00e3o de circuitos integrados, layout de placas de circuito impresso (PCB), renderiza\u00e7\u00e3o 3D e exporta\u00e7\u00e3o de dados para fabrica\u00e7\u00e3o. O software \u00e9 multiplataforma, funcionando em Linux, Windows e macOS.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#fluxo-de-trabalho-do-kicad","title":"Fluxo de Trabalho do KiCad","text":"<p>O fluxo de trabalho no KiCad \u00e9 centralizado em um Gerenciador de Projetos que integra os diversos componentes do software. Diferente de vers\u00f5es muito antigas, onde era necess\u00e1rio gerar arquivos de \"netlist\" manualmente para passar do esquema para a PCB, as vers\u00f5es modernas realizam essa integra\u00e7\u00e3o de forma direta.</p> <p>O processo t\u00edpico envolve:</p> <ol> <li>Edi\u00e7\u00e3o do Esquema: Utiliza-se o Editor de Esquemas para desenhar o circuito usando s\u00edmbolos (resistores, microcontroladores, etc.) de bibliotecas preexistentes.</li> <li>Simula\u00e7\u00e3o: \u00c9 poss\u00edvel realizar simula\u00e7\u00f5es de circuitos (via Ngspice) diretamente no editor de esquemas para verificar o comportamento el\u00e9trico.</li> <li>Layout da PCB: No Editor de PCB, o design \u00e9 transformado em um layout f\u00edsico, posicionando as footprints (pegadas) dos componentes e tra\u00e7ando as conex\u00f5es de cobre.</li> <li>Gera\u00e7\u00e3o de Arquivos de Sa\u00edda: O processo de plotagem gera os arquivos necess\u00e1rios para a fabrica\u00e7\u00e3o, como arquivos Gerber, brocas de perfura\u00e7\u00e3o e listas de materiais (BOM).</li> </ol>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#informacoes-relevantes","title":"Informa\u00e7\u00f5es Relevantes","text":"<ul> <li>Componentes Adicionais: A su\u00edte inclui ferramentas como: <ul> <li>GerbView: visualizador de arquivos Gerber.</li> <li>PCB Calculator: para c\u00e1lculos de largura de trilha e espa\u00e7amento el\u00e9trico.</li> <li>Bitmap2Component: converte imagens em s\u00edmbolos ou footprints.</li> </ul> </li> <li>Gerenciamento de Biblioteca: O KiCad possui bibliotecas vastas de s\u00edmbolos, footprints e modelos 3D, al\u00e9m de editores dedicados para que o usu\u00e1rio crie seus pr\u00f3prios componentes.</li> <li>Compatibilidade de Arquivos: O software \u00e9 retrocompat\u00edvel, abrindo arquivos de vers\u00f5es anteriores. Entretanto, uma vez que um arquivo \u00e9 salvo em uma vers\u00e3o principal nova (como a 9.0), ele n\u00e3o poder\u00e1 mais ser aberto por vers\u00f5es anteriores.</li> <li>Interface de Usu\u00e1rio: O comportamento \u00e9 baseado em \"ferramentas\" (modos de opera\u00e7\u00e3o). A tecla Esc \u00e9 usada universalmente para cancelar a\u00e7\u00f5es ou retornar \u00e0 ferramenta de sele\u00e7\u00e3o padr\u00e3o.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#principais-etapas-do-projeto-eletronico","title":"Principais etapas do projeto eletr\u00f4nico","text":"","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#1-esquematico-schematic","title":"1. Esquem\u00e1tico (Schematic)","text":"<p>O esquem\u00e1tico \u00e9 uma cole\u00e7\u00e3o de uma ou mais p\u00e1ginas (folhas) que cont\u00eam os desenhos do circuito eletr\u00f4nico.</p> <ul> <li>S\u00edmbolos: Nele, voc\u00ea utiliza s\u00edmbolos para representar elementos do circuito, que podem ser componentes f\u00edsicos (como resistores e microcontroladores) ou conceitos n\u00e3o f\u00edsicos (como terminais de energia ou terra).</li> <li>Conex\u00f5es: Os s\u00edmbolos possuem pinos, que s\u00e3o os pontos de conex\u00e3o interligados por fios no desenho.</li> <li>Funcionalidade: No Editor de Esquem\u00e1ticos do KiCad, al\u00e9m de desenhar o circuito, \u00e9 poss\u00edvel realizar simula\u00e7\u00f5es integradas (via SPICE) e gerar listas de materiais (BOM).</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#2-layout-pcb","title":"2. Layout (PCB)","text":"<p>O layout (ou placa de circuito impresso - PCB) \u00e9 o documento de design que representa a implementa\u00e7\u00e3o f\u00edsica do esquem\u00e1tico.</p> <ul> <li>Footprints: No layout, os s\u00edmbolos do esquem\u00e1tico s\u00e3o substitu\u00eddos por footprints (pegadas), que definem o espa\u00e7o f\u00edsico e os pads (\u00e1reas de cobre) onde os componentes ser\u00e3o soldados na placa real.</li> <li>Roteamento: \u00c9 nesta etapa que se definem as trilhas de cobre, o empilhamento de camadas (padstacks) e as vias de conex\u00e3o entre elas.</li> <li>Fabrica\u00e7\u00e3o: O Editor de PCB \u00e9 usado para gerar os arquivos de sa\u00edda necess\u00e1rios para a produ\u00e7\u00e3o da placa, como arquivos Gerber ou o formato ODB++.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#3-visualizador-3d-3d-viewer","title":"3. Visualizador 3D (3D Viewer)","text":"<p>O 3D Viewer \u00e9 a ferramenta de renderiza\u00e7\u00e3o 3D integrada ao KiCad, que permite visualizar a placa antes de ela ser fabricada.</p> <ul> <li>Modelagem Detalhada: Ele exibe modelos 3D dos componentes montados sobre a placa, permitindo uma inspe\u00e7\u00e3o visual do design f\u00edsico.</li> <li>Exporta\u00e7\u00e3o: O sistema de renderiza\u00e7\u00e3o 3D do KiCad permite exportar o design em diversos formatos para uso em outros softwares de engenharia.</li> <li>Precis\u00e3o: Vers\u00f5es recentes (como a 9.0) melhoraram o suporte para exibir detalhes finos de cobre e oferecem mais controle sobre quais dados s\u00e3o inclu\u00eddos na visualiza\u00e7\u00e3o e exporta\u00e7\u00e3o do modelo.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/1-KiCad/#referencias","title":"Refer\u00eancias","text":"<p>KICAD. Homepage. Dispon\u00edvel em: https://www.kicad.org/. Acesso em: 24 fev. 2026.</p> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> <p>TAVARES, Rodrigo. Curso de Projeto de PCB com KiCAD. YouTube. [s. d.]. Playlist (26 v\u00eddeos). Dispon\u00edvel em: https://www.youtube.com/playlist?list=PL8kCnofYYWZrkhUis1svLGux1tjYNJy2Z. Acesso em: 24 fev. 2026.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/2-Novo_Projeto/","title":"Criando um novo projeto vazio","text":"<p>1) Abra o software KiCad.</p> <p></p> <p>2) No menu <code>Arquivo</code>, clique em <code>Novo projeto...        Ctrl+N</code></p> <p>2.1) Selecione o local e defina um nome para o projeto. </p> <p></p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/2-Novo_Projeto/#referencias","title":"Refer\u00eancias","text":"<p>KICAD. Homepage. Dispon\u00edvel em: https://www.kicad.org/. Acesso em: 24 fev. 2026.</p> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> <p>TAVARES, Rodrigo. Curso de Projeto de PCB com KiCAD. YouTube. [s. d.]. Playlist (26 v\u00eddeos). Dispon\u00edvel em: https://www.youtube.com/playlist?list=PL8kCnofYYWZrkhUis1svLGux1tjYNJy2Z. Acesso em: 24 fev. 2026.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/3-Esquematico/","title":"Esquem\u00e1tico - Inserindo componentes e montando circuitos","text":"<p>1) Abra o esquem\u00e1tico do projeto.</p> <p>O esquem\u00e1tico, ou diagrama esquem\u00e1tico, do projeto \u00e9 o local em que o circuito eletr\u00f4nico \u00e9 representado atrav\u00e9s de seus s\u00edmbolos gr\u00e1ficos padronizados, bem como suas interconex\u00f5es de modo que realizem suas funcionalidades espec\u00edficas.</p> <p>Para a elabora\u00e7\u00e3o de uma placa de circuito impresso (PCI), o diagrama esquem\u00e1tico \u00e9 a etapa inicial, base para a constru\u00e7\u00e3o da etapa seguinte que consiste no posicionamento f\u00edsico dos componentes na elabora\u00e7\u00e3o do leiaute (layout). </p> <p>1) Abrir esquem\u00e1tico do projeto </p> <p>1.1) Clique duplo no arquivo com o nome do projeto e extens\u00e3o <code>.kicad_sch</code>.</p> <p>1.2) Mantenha a sele\u00e7\u00e3o recomendada para c\u00f3pia da biblioteca global de s\u00edmbolos.</p> <p>1.3) Clique em <code>OK</code></p> <p></p> <p>2) Adicionar s\u00edmbolos</p> <p>2.1) Clique em <code>Posicionar</code> e em seguida <code>Posicionar s\u00edmbolos</code> ou no \u00edcone correspondente, conforme imagem ou use o atalho <code>A</code>;</p> <p>2.2) A primeira vez que esta op\u00e7\u00e3o for executada, uma janela solicitando o carregamento de biblioteca e feita, mantenha a op\u00e7\u00e3o recomendada e confirme. </p> <p></p> <p>2.3) Digite no campo de pesquisa o componente desejado</p> <p>Se for inserir mais de uma unidade do mesmo componente, selecione a op\u00e7\u00e3o <code>Posicione c\u00f3pias repetidas</code></p> <p></p> <p>2.4) Inserir componentes no esquem\u00e1tico</p> <p>Insira os componentes no esquem\u00e1tico e use as ferramentas de lupa, rota\u00e7\u00e3o e espelhamento para melhor posicionar os componentes no circuito. </p> <p></p> <p>2.5) Conecte os terminais dos componentes com linhas clicando no terminal de origem e no de destino. </p> <p></p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/KiCad/3-Esquematico/#referencias","title":"Refer\u00eancias","text":"<p>KICAD. Homepage. Dispon\u00edvel em: https://www.kicad.org/. Acesso em: 24 fev. 2026.</p> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> <p>TAVARES, Rodrigo. Curso de Projeto de PCB com KiCAD. YouTube. [s. d.]. Playlist (26 v\u00eddeos). Dispon\u00edvel em: https://www.youtube.com/playlist?list=PL8kCnofYYWZrkhUis1svLGux1tjYNJy2Z. Acesso em: 24 fev. 2026.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/","title":"1 - PCI/PCB","text":"","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#placa-de-circuito-impresso-pci","title":"Placa de Circuito Impresso - PCI","text":"<p>Uma PCI (Placa de Circuito Impresso) ou PCB (Printed Circuit Board) \u00e9 a base f\u00edsica e o suporte onde reside todo o hardware eletr\u00f4nico de um dispositivo ou sistema.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#1-composicao-e-funcao","title":"1. Composi\u00e7\u00e3o e Fun\u00e7\u00e3o","text":"<ul> <li>Materiais: As PCIs s\u00e3o geralmente fabricadas em folhas finas de fibra de vidro (ou fenolite em vers\u00f5es mais simples).</li> <li>Caminhos El\u00e9tricos: O circuito el\u00e9trico \u00e9 \"impresso\" na placa na forma de trilhas de cobre, que t\u00eam a fun\u00e7\u00e3o de transportar os sinais el\u00e9tricos entre os diversos componentes conectados.</li> <li>Conex\u00e3o de Componentes: Todos os componentes eletr\u00f4nicos que formam o sistema s\u00e3o fixados \u00e0 placa por meio de soldagem, uso de soquetes ou outros mecanismos de conex\u00e3o.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#2-elementos-do-projeto","title":"2. Elementos do Projeto","text":"<ul> <li>Pads: S\u00e3o \u00e1reas de cobre destinadas \u00e0 soldagem dos terminais dos componentes.</li> <li>Vias: Pequenos furos revestidos de cobre usados para realizar conex\u00f5es el\u00e9tricas entre diferentes camadas da placa (por exemplo, ligar uma trilha da face superior \u00e0 face inferior).</li> <li>Trilhas: A largura das trilhas deve ser dimensionada de acordo com a corrente el\u00e9trica que ir\u00e1 percorr\u00ea-las para garantir a durabilidade e o funcionamento correto.</li> <li>Silkscreen: \u00c9 a parte impressa (geralmente em branco) que cont\u00e9m legendas, numera\u00e7\u00e3o de componentes e nomes de pinos para facilitar a montagem e manuten\u00e7\u00e3o.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#3-tipos-de-montagem-e-camadas","title":"3. Tipos de Montagem e Camadas","text":"<ul> <li>PTH (Plated/Pin Through-Hole): Componentes cujos terminais atravessam furos na placa para serem soldados no lado oposto.</li> <li>SMD (Surface Mount Device): Componentes soldados diretamente sobre a superf\u00edcie da placa, permitindo a miniaturiza\u00e7\u00e3o dos circuitos.</li> <li>Camadas: As placas podem ser de face simples (cobre em apenas um lado), dupla face (cobre em ambos os lados) ou multicamadas (multi-layer), que funcionam como um \"sandu\u00edche\" de circuitos para sistemas mais complexos.</li> </ul>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#4-importancia-do-design","title":"4. Import\u00e2ncia do Design","text":"<p>Um bom projeto de PCI n\u00e3o foca apenas na est\u00e9tica, mas segue regras rigorosas de compatibilidade eletromagn\u00e9tica para assegurar que o hardware se comporte conforme o esperado e resista a interfer\u00eancias. Softwares profissionais s\u00e3o utilizados para converter diagramas esquem\u00e1ticos em layouts f\u00edsicos de placas. Como principais ferramentas podemos citar o Altium Designer, Cadence OrCAD/Allegro, Autodesk Eagle, Ares (Proteus), EasyEDA e KiCad.</p> <p>Nota sobre a sigla PCI: Al\u00e9m de significar Placa de Circuito Impresso, em contextos de arquitetura de computadores, PCI tamb\u00e9m se refere ao barramento Peripheral Component Interconnect, um padr\u00e3o de comunica\u00e7\u00e3o s\u00edncrono usado para conectar placas de expans\u00e3o (como placas de v\u00eddeo ou som) \u00e0 placa-m\u00e3e. PCB \u00e9 o acr\u00f4nimo de Printed Circuit Board, em portugu\u00eas Placa de Circuito Impresso (PCI).</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#5-fluxo-do-projeto-para-pcb","title":"5. Fluxo do projeto para PCB","text":"<ol> <li>Prot\u00f3tipo</li> <li>Esquem\u00e1tico</li> <li>Desenho PCB</li> <li>Produ\u00e7\u00e3o</li> </ol>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/PCI/Tecnologia/1-PCI/#referencias","title":"Refer\u00eancias","text":"<p>KICAD. Homepage. Dispon\u00edvel em: https://www.kicad.org/. Acesso em: 24 fev. 2026.</p> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> <p>TAVARES, Rodrigo. Curso de Projeto de PCB com KiCAD. YouTube. [s. d.]. Playlist (26 v\u00eddeos). Dispon\u00edvel em: https://www.youtube.com/playlist?list=PL8kCnofYYWZrkhUis1svLGux1tjYNJy2Z. Acesso em: 24 fev. 2026.</p>","tags":["KiCad","PCI","PCB"]},{"location":"digitais/Perifericos/dio01-led/","title":"1. LED","text":"","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Perifericos/dio01-led/#led-light-emitting-diode-diodo-emissor-de-luz","title":"LED - Light-Emitting Diode - Diodo Emissor de Luz","text":"<p>Um LED (Light Emitting Diode) \u00e9 um dispositivo semicondutor (diodo) composto por dois terminais, um anodo e um catodo, que tem a propriedade de emitir luz (f\u00f3tons) quando percorrido por uma corrente el\u00e9trica. Ele \u00e9 constru\u00eddo a partir da jun\u00e7\u00e3o de dois materiais, um do tipo P e outro do tipo N, organizados de forma a permitir o fluxo de eletricidade em apenas uma dire\u00e7\u00e3o.</p> <p>A luz \u00e9 produzida quando o LED est\u00e1 em polariza\u00e7\u00e3o direta, o que acontece quando a tens\u00e3o no anodo \u00e9 mais positiva que no catodo por uma diferen\u00e7a m\u00ednima chamada tens\u00e3o direta (forward voltage). O brilho resultante depende diretamente da pot\u00eancia el\u00e9trica aplicada e, como a tens\u00e3o do LED permanece aproximadamente constante enquanto ele est\u00e1 ativo, o controle da intensidade luminosa \u00e9 realizado atrav\u00e9s do ajuste da corrente.</p> <p>No desenvolvimento de sistemas embarcados, \u00e9 fundamental observar os seguintes conceitos t\u00e9cnicos:</p> <ul> <li>Necessidade de Resistor: Quando um LED entra em condu\u00e7\u00e3o, ele se torna um curto-circuito quase perfeito; por isso, \u00e9 obrigat\u00f3rio utilizar um resistor em s\u00e9rie para limitar a corrente e evitar que o componente seja danificado ou \"queime\".</li> <li> <p>C\u00e1lculo de Prote\u00e7\u00e3o: O valor do resistor limitador \u00e9 obtido pela Lei de Ohm: </p> <p>\\(R = \\frac{(V_s - V_f)}{I}\\), </p> <p>onde \\(V_s\\) \u00e9 a tens\u00e3o da fonte (como os 5V de um Arduino), \\(V_f\\) \u00e9 a tens\u00e3o direta do LED (cerca de 1,8V para um LED vermelho comum) e \\(I\\) \u00e9 a corrente desejada (geralmente entre 10mA e 20mA).</p> </li> <li> <p>Polaridade: O LED \u00e9 um componente polarizado; o anodo (+) \u00e9 normalmente o terminal mais longo e o catodo (-) possui um chanfro ou lado chato no corpo pl\u00e1stico do componente.</p> </li> <li> <p>Aplica\u00e7\u00f5es: Em projetos com microcontroladores, os LEDs atuam como atuadores simples, servindo como indicadores visuais de estado do sistema, monitores de processamento (heartbeat) ou emissores de sinais infravermelhos em controles remotos.</p> </li> <li> <p>Variedades: Existem ainda LEDs multicoloridos (RGB), que integram elementos de cores prim\u00e1rias em um \u00fanico encapsulamento, permitindo a cria\u00e7\u00e3o de diversas cores atrav\u00e9s do controle individual de cada elemento.</p> </li> </ul> <p>A integra\u00e7\u00e3o de LEDs \u00e9 t\u00e3o comum que quase todo sistema embarcado possui ao menos um para testes iniciais, sendo o programa que o faz piscar (o famoso Blink) considerado o \"Hello World\" da eletr\u00f4nica.</p> <p>Atrav\u00e9s de um pino de microcontrolador, configurado como sa\u00edda, pode-se realizar o acionamento do LED. Este pino pode estar fornecendo corrente como fonte (source) ao ramo ou drenando (sink) corrente dele.</p> Liga\u00e7\u00e3o do pino como fonte (Source) Liga\u00e7\u00e3o do pino como dreno (Sink) <p>O pino do uC possui limita\u00e7\u00e3o de corrente, que pode variar a depender do modelo ou fabricante.</p> <p>A corrente m\u00e1xima por pino \u00e9 de <code>40 mA</code>, de acordo com o Datasheet (AVR ATmega328P, cap\u00edtulo 28.1 Absolute maximum ratings, p\u00e1g. 258), que \u00e9 o microcontrolador do Arduino Uno. Este valor varia de acordo com o dispositivo controlador, sendo assim, sempre consulte o manual do fabricante do controlador que est\u00e1 sendo utilizado. </p> <p>A vantagem de utilizar o pino como fonte \u00e9 trabalhar com uma l\u00f3gica direta, em que o estado l\u00f3gico 1 (verdadeiro, +5V) produz o acionamento do LED, enquanto que na configura\u00e7\u00e3o do pino como dreno a l\u00f3gica de acionamento \u00e9 invertida, pois para produzir o acionamento do LED o pino deve estar em estado l\u00f3gico 0 (falso, 0V).</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Perifericos/dio01-led/#referencias","title":"Refer\u00eancias","text":"<ol> <li>LIMA, Charles Borges de; VILLA\u00c7A, Marco V. M. AVR e Arduino: t\u00e9cnicas de projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012..</li> <li>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. [S.l.]: Jonathan Valvano, 2014. v. 1..</li> <li>SAP-1 (Simple-As-Possible Computer 1).</li> </ol>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Perifericos/dio02-button/","title":"2. Chave T\u00e1ctil","text":"","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#_1","title":"2. Chave T\u00e1ctil","text":"","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#1-chave-tactil-botao-de-pressao-ou-push-button","title":"1. Chave T\u00e1ctil, Bot\u00e3o de Press\u00e3o ou Push-Button","text":"<p>\u00c9 um dispositivo que realiza condu\u00e7\u00e3o ou interrup\u00e7\u00e3o el\u00e9trica entre, ao menos, dois de seus terminais de forma moment\u00e2nea. </p> <p>S\u00e3o usados para realizar um comando de forma mec\u00e2nica para um dispositivo eletr\u00f4nico ao pressionar o bot\u00e3o. </p> <p>S\u00e3o compostos de dois ou mais terminais, e contatos que fecham ou abrem ao se realizar o acionamento. Esses contatos retornam \u00e0 posi\u00e7\u00e3o original ao deixar de pressionar o bot\u00e3o. Sendo assim, temos bot\u00f5es de press\u00e3o cujos contatos est\u00e3o abertos normalmente (NA ou NO) e s\u00e3o fechados quando o bot\u00e3o \u00e9 acionado e bot\u00f5es de press\u00e3o cujos contatos est\u00e3o fechados normalmente(NF ou NC) e s\u00e3o abertos quando o bot\u00e3o \u00e9 acionado. </p> <ul> <li>Necessidade de Resistor: Um dispositivo digital necessita obrigatoriamente receber um n\u00edvel de tens\u00e3o bem estabelecido, geralmente +5V ou 0V, por exemplo. Um pino de microcontrolador que recebe este est\u00edmulo n\u00e3o pode ficam em aberto, configurando um estado indefinido de tens\u00e3o. Para evitar esta condi\u00e7\u00e3o, usa-se um ramo alimentado pela fonte e com resistor em s\u00e9rie com a chave t\u00e1ctil, de modo a garantir um n\u00edvel l\u00f3gico bem definido quando os contatos da chave estiverem em aberto. </li> <li>Valor do Resitor: O objetivo \u00e9 definir um n\u00edvel de tens\u00e3o que seja reconhecido como <code>1</code> ou <code>0</code> l\u00f3gico, e n\u00e3o h\u00e1 necessidade de inje\u00e7\u00e3o de corrente no pico do microcontrolador, j\u00e1 que o est\u00edmulo \u00e9 pela tens\u00e3o. Assim, costuma-se usar um resistor de valor alto, para que o consumo de corrente seja baixo, reduzindo o consumo de energia do circuito. O valor mais comum \u00e9 de 10 k\\(\\Omega\\). Outros valores na mesma escala de resist\u00eancia podem ser usados. </li> </ul> <p>As duas configura\u00e7\u00f5es poss\u00edves s\u00e3o mostradas na ilustra\u00e7\u00e3o abaixo, em que o bot\u00e3o est\u00e1 conectado ao Vcc e a outra em que o bot\u00e3o est\u00e1 conectado ao terra.</p> Liga\u00e7\u00e3o do resistor de pull-down Liga\u00e7\u00e3o do resistor de pull-up <p>Na configura\u00e7\u00e3o pull-down o resistor est\u00e1 conectado ao terra, o que garante, quando o bot\u00e3o estiver aberto, o n\u00edvel l\u00f3gico 0 (terra/GND) chegando no pino do uC.</p> <p>Ao pressionar o bot\u00e3o, ele fecha e conecta o ponto de conex\u00e3o com o pino ao Vcc, aplicando o n\u00edvel l\u00f3gico 1 a ele.</p> <p>Na configura\u00e7\u00e3o pull-up o resistor est\u00e1 conectado ao positivo da fonte, Vcc. O bot\u00e3o na condi\u00e7\u00e3o de n\u00e3o acionado est\u00e1 com contato aberto, assim a tens\u00e3o sobre ele \u00e9 a tens\u00e3o da fonte, nesse caso 5V, conforme a 2\u00aa lei de Kirchhoff, garantindo o n\u00edvel l\u00f3gico 1.</p> <p>Ao pressionar o bot\u00e3o, ele fecha, ligando o ponto de conex\u00e3o com o pino do uC ao GND, aplicando o n\u00edvel l\u00f3gico 0 a ele.</p> <p>A configura\u00e7\u00e3o com o resistor de pull-down \u00e9 a que proporciona uma l\u00f3gica direta a entrada do dado: bot\u00e3o pressionado.</p>","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#2-o-fenomeno-do-bounce-trepidacao","title":"2. O Fen\u00f4meno do Bounce (Trepida\u00e7\u00e3o)","text":"<p>Na pr\u00e1tica, os bot\u00f5es mec\u00e2nicos n\u00e3o estabelecem contato de forma instant\u00e2nea e limpa. Quando pressionados ou soltos, os contatos met\u00e1licos sofrem um repique mec\u00e2nico, gerando o chamado bounce. Esse ru\u00eddo produz oscila\u00e7\u00f5es na tens\u00e3o que podem durar cerca de 10 ms, fazendo com que o microcontrolador (que opera em alta velocidade) interprete um \u00fanico clique f\u00edsico como m\u00faltiplos acionamentos l\u00f3gicos.</p> Figura: Exemplos de ru\u00eddo gerados no pressionar e soltar um bot\u00e3o Fonte: Lima e Vila\u00e7a (2012)","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#21-tecnicas-de-debounce","title":"2.1 T\u00e9cnicas de Debounce","text":"<p>Para solucionar o problema da trepida\u00e7\u00e3o, utiliza-se a t\u00e9cnica de debounce. Em sistemas microcontrolados ela \u00e9 comumente realizada via software, por\u00e9m o debounce por hardware \u00e9 uma t\u00e9cnica que filtra essas oscila\u00e7\u00f5es antes mesmo que o sinal chegue ao pino do microcontrolador, economizando recursos de processamento da CPU.</p> <p>As fontes descrevem duas formas principais de realizar o debounce via hardware:</p>","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#211-filtros-rc-resistor-capacitor","title":"2.1.1 Filtros RC (Resistor-Capacitor)","text":"<p>A maneira mais comum de filtrar o ru\u00eddo \u00e9 atrav\u00e9s do uso de capacitores e resistores.</p> <ul> <li> <p>Funcionamento: Um capacitor \u00e9 colocado em paralelo com o bot\u00e3o ou entre o pino de entrada e o terra. Ele funciona como um filtro passa-baixa, suavizando as transi\u00e7\u00f5es r\u00e1pidas de tens\u00e3o causadas pelo repique mec\u00e2nico.</p> </li> <li> <p>Constante de Tempo (\\(\\tau\\)): O tempo de estabiliza\u00e7\u00e3o \u00e9 determinado pela f\u00f3rmula \\(\\tau = R \\times C\\). Para que o filtro seja eficaz, o per\u00edodo das oscila\u00e7\u00f5es de ru\u00eddo deve ser significativamente menor que a constante de tempo do circuito.</p> </li> <li> <p>Valores t\u00edpicos: Em circuitos de reset, por exemplo, \u00e9 comum o uso de resistores de \\(10\\text{ k}\\Omega\\) e capacitores de \\(100\\text{ nF}\\) para garantir uma inicializa\u00e7\u00e3o est\u00e1vel.</p> </li> </ul> Figura: Exemplos de circuito de Debounce com filtro RC","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#212-eliminadores-de-trepidacao-com-latches-biestaveis","title":"2.1.2 Eliminadores de Trepida\u00e7\u00e3o com Latches (Biest\u00e1veis)","text":"<p>Sistemas que exigem uma transi\u00e7\u00e3o l\u00f3gica extremamente limpa, como o computador did\u00e1tico SAP-1, utilizam circuitos integrados de l\u00f3gica digital para criar um debouncer.</p> <ul> <li> <p>Latch RS: Utiliza-se um biest\u00e1vel (flip-flop) constru\u00eddo com duas portas NAND (como as do CI 7400) ou portas NOR acopladas de forma cruzada.</p> </li> <li> <p>Funcionamento: Quando o bot\u00e3o toca o primeiro contato, ele \"seta\" o latch para um estado est\u00e1vel. Quaisquer vibra\u00e7\u00f5es subsequentes no mesmo contato s\u00e3o ignoradas pela l\u00f3gica das portas, mantendo a sa\u00edda inalterada at\u00e9 que o bot\u00e3o seja movido para a posi\u00e7\u00e3o oposta.</p> </li> <li> <p>Aplica\u00e7\u00f5es: Esse m\u00e9todo \u00e9 ideal para gerar pulsos de clock manuais ou sinais de controle de etapa \u00fanica (single-step), onde um \u00fanico pulso limpo \u00e9 obrigat\u00f3rio para evitar m\u00faltiplos avan\u00e7os no programa.</p> </li> </ul> <p>Embora o debounce por software seja mais econ\u00f4mico por n\u00e3o exigir componentes extras, o debounce por hardware \u00e9 superior em sistemas cr\u00edticos onde a velocidade de resposta e a previsibilidade temporal s\u00e3o fundamentais, pois o microcontrolador n\u00e3o precisa \"perder tempo\" executando rotinas de atraso para validar a entrada.</p>","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#3-deteccao-de-borda","title":"3. Detec\u00e7\u00e3o de borda","text":"<p>A detec\u00e7\u00e3o de borda \u00e9 o processo de identificar a transi\u00e7\u00e3o de estado em um sinal digital, ou seja, o exato momento em que a tens\u00e3o muda de um n\u00edvel l\u00f3gico para outro. Em sistemas embarcados, essa t\u00e9cnica \u00e9 fundamental para reagir a eventos externos, como o pressionar de um bot\u00e3o ou o sinal de um sensor, permitindo que o microcontrolador execute uma a\u00e7\u00e3o espec\u00edfica apenas no instante da mudan\u00e7a, em vez de processar continuamente enquanto o n\u00edvel permanece est\u00e1tico.</p> <p>Existem dois tipos principais de bordas:</p> <ul> <li>Borda de Subida (Rising Edge): Quando o sinal transita do n\u00edvel l\u00f3gico baixo (0) para o n\u00edvel l\u00f3gico alto (1).</li> <li>Borda de Descida (Falling Edge): Quando o sinal transita do n\u00edvel l\u00f3gico alto (1) para o n\u00edvel l\u00f3gico baixo (0).</li> </ul> <p>Na ilustra\u00e7\u00e3o seguinte os sinais para a detec\u00e7\u00e3o de bordas de subida e descida em fun\u00e7\u00e3o de um sinal de entrada e intervalos discretos (t0, t1, ..., tn) representando o tempo de execu\u00e7\u00e3o de cada ciclo de execu\u00e7\u00e3o do programa principal. </p> Figura: Detec\u00e7\u00e3o de bordas de subida (rising) e descida (falling) Fonte: Autor","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#31-como-realiza-la-de-forma-generica","title":"3.1 Como realiz\u00e1-la de forma gen\u00e9rica","text":"<p>A detec\u00e7\u00e3o de borda pode ser implementada tanto por hardware dedicado (perif\u00e9ricos internos) quanto por l\u00f3gica de software.</p> <p>Em aplica\u00e7\u00f5es simples onde o uso de interrup\u00e7\u00f5es n\u00e3o \u00e9 vi\u00e1vel, a detec\u00e7\u00e3o \u00e9 feita via Software (Polling), comparando o estado atual de um pino com o seu estado anterior dentro do la\u00e7o principal (loop).</p> <ul> <li>Algoritmo gen\u00e9rico:<ol> <li>L\u00ea o estado atual do pino.</li> <li>Compara com o estado salvo na itera\u00e7\u00e3o anterior.</li> <li>Se (Anterior == 0 e Atual == 1), houve uma borda de subida.</li> <li>Atualiza o estado anterior para a pr\u00f3xima leitura.</li> </ol> </li> <li>Aten\u00e7\u00e3o: Ao realizar a detec\u00e7\u00e3o via software em bot\u00f5es mec\u00e2nicos, \u00e9 indispens\u00e1vel implementar uma t\u00e9cnica de debounce para filtrar o ru\u00eddo (trepida\u00e7\u00e3o) que ocorre durante a transi\u00e7\u00e3o, evitando que m\u00faltiplas bordas falsas sejam detectadas em um curto intervalo de tempo.</li> </ul> Figura: Detec\u00e7\u00e3o de borda para incremento e decremento Fonte: Autor","tags":["Push-button"]},{"location":"digitais/Perifericos/dio02-button/#referencias","title":"Refer\u00eancias","text":"<ol> <li>LIMA, Charles Borges de; VILLA\u00c7A, Marco V. M. AVR e Arduino: t\u00e9cnicas de projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012..</li> <li>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. [S.l.]: Jonathan Valvano, 2014. v. 1..</li> <li>SAP-1 (Simple-As-Possible Computer 1).</li> </ol>","tags":["Push-button"]},{"location":"digitais/Perifericos/dio03-display7seg/","title":"3 - Display 7 segmentos","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio03-display7seg/#1-display-7-segmentos","title":"1. Display 7-segmentos","text":"<p>O display de 7 segmentos basicamente \u00e9 um conjunto de LEDs dispostos de forma a cada um deles iluminar um segmento no encapsulamento. Existem v\u00e1rios modelos para diferentes necessidades, mas aqui usamos o mais comum.</p> <p>O display possui, al\u00e9m dos sete segmentos, um ponto, que pode ser utilizado para sinalizar um ponto decimal (v\u00edrgula) ao associar v\u00e1rios displays. Nesse projeto o ponto n\u00e3o ser\u00e1 utilzado.</p> <p>Existem dois modelos de display, Anodo comum e Catodo comum, que se referem aos terminais dos LEDs conectados em comum, conforme exemplo da Figura 1.</p> Figura 1: Segmentos do display Fonte: Autor <p>Cada segmento recebe uma identifica\u00e7\u00e3o em letra min\u00fascula de <code>a</code> a <code>g</code> e o <code>p</code>. O display possui um terminal para cada segmento do display.</p> <p>Note que cada segmento, composto por um LED, necessita de um resistor para limitar a corrente que percorre ele. Como cada pino do uC fornece uma tens\u00e3o de 5V para acionar o segmento. A queda de tens\u00e3o no LED \u00e9 de 2V, aproximadamente. Pode-se assim calcular o valor do resistor limitador de corrente:</p> \\[ R = \\frac{V_{pino} - V_{LED}}{I_{LED}} = \\frac{5-2}{0,02} = 150\\Omega \\] <p>O display aqui utilizado \u00e9 do tipo catodo comum, assim basta acionar os pinos que correspondam aos segmentos a serem acionados para formar o d\u00edgito que se deseja exibir.</p> <p>Para mostrar o d\u00edgito 0(zero), aciona-se os segmento a, b, c, d, e, f conforme mostrado na Figura 2.</p> Figura 2: C\u00f3digo de forma\u00e7\u00e3o do digito 0 (Zero) Fonte: Autor <p>\u00c9 importante notar a sequ\u00eancia de pinos do display e do PORT utilizado, pois uma altera\u00e7\u00e3o de ordem muda o que \u00e9 exibido no display.</p> <p>Para o d\u00edgito 1(um), Figura 3, \u00e9 necess\u00e1rio ligar apenas os segmentos b e c, mantendo os demais desligados.</p> Figura 3: C\u00f3digo de forma\u00e7\u00e3o do digito 1 (Um) Fonte: Autor <p>Para o d\u00edgito 2(dois), Figura 4, \u00e9 mais f\u00e1cil perceber os d\u00edgitos desligados, pois est\u00e3o em menor quantidade, sendo o <code>c</code> e o <code>f</code> desligados e os demais ligados (exceto o ponto como j\u00e1 foi citado).</p> Figura 4: C\u00f3digo de forma\u00e7\u00e3o do digito 2 (Dois) Fonte: Autor <p>A Figura 5 mostra uma tabela com todas as combina\u00e7\u00f5es para os d\u00edgitos decimais e seus valores correspondentes em hexadecimal. Ao atribuir ao PORT um dos valores em hexadecimal da tabela, o digito correspondente deve ser mostrado no display.</p> Figura 5: C\u00f3digo de forma\u00e7\u00e3o do d\u00edgitos <code>0</code> a <code>9</code> Fonte: Autor <p>Est\u00e3o faltando os dados dos d\u00edgitos que completam o conjunto hexadecimal, que podem te servir como exerc\u00edcios. </p> <p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio03-display7seg/#2-uso-com-um-unico-digito","title":"2. Uso com um \u00danico D\u00edgito","text":"<p>Para acionar um display individual, cada segmento (identificado pelas letras de a at\u00e9 g e p para o ponto) deve ser conectado a um pino de sa\u00edda do microcontrolador atrav\u00e9s de um resistor limitador de corrente. O uso pr\u00e1tico envolve os seguintes passos:</p> <ol> <li>Mapeamento: Define-se quais segmentos devem ser acesos para formar cada n\u00famero de 0 a 9 (ou A-F).</li> <li>Decodifica\u00e7\u00e3o: Utiliza-se uma tabela de decodifica\u00e7\u00e3o (ou lookup table) no c\u00f3digo, que traduz o valor bin\u00e1rio convencional para o padr\u00e3o de bits que o display exige. </li> <li>Sa\u00edda de Dados: O microcontrolador escreve o valor da tabela diretamente no registrador da porta (PORT) conectada ao display.</li> </ol> Figura 6: Contagem com 1 d\u00edgito Fonte: Autor","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio03-display7seg/#3-uso-com-multiplos-digitos-multiplexacao","title":"3. Uso com M\u00faltiplos D\u00edgitos (Multiplexa\u00e7\u00e3o)","text":"<p>Ligar v\u00e1rios d\u00edgitos diretamente exigiria um n\u00famero excessivo de pinos (ex: 32 pinos para 4 d\u00edgitos). Para resolver isso, utiliza-se a t\u00e9cnica de multiplexa\u00e7\u00e3o temporal, baseada no fen\u00f4meno da persist\u00eancia da vis\u00e3o humana.</p> <ul> <li>Conex\u00e3o F\u00edsica: Os segmentos correspondentes de todos os d\u00edgitos (todos os \"a\", todos os \"b\", etc.) s\u00e3o interconectados em um barramento comum. Os pinos comuns de cada d\u00edgito (anodo ou catodo comum) s\u00e3o conectados individualmente a pinos de controle, geralmente atrav\u00e9s de transistores (PNP para anodo comum ou NPN para catodo comum) para suportar a corrente.</li> <li>L\u00f3gica de Varredura: O sistema embarcado liga apenas um d\u00edgito por vez, coloca o dado correspondente no barramento de segmentos, espera alguns milissegundos, apaga-o e repete o processo para o pr\u00f3ximo d\u00edgito.</li> <li>Frequ\u00eancia: Para que o olho humano n\u00e3o perceba a cintila\u00e7\u00e3o e veja todos os d\u00edgitos acesos simultaneamente, a varredura deve ocorrer a uma frequ\u00eancia m\u00ednima de 24 Hz a 50 Hz por d\u00edgito.</li> </ul> <p>Segue um exemplo, Figura 6, de implementa\u00e7\u00e3o de dois d\u00edgitos com displays de sete segmentos utilizando a t\u00e9cnica de multiplexa\u00e7\u00e3o.</p> Figura 7: Contagem com 2 d\u00edgitos Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1 <p>Para projetos que visam economizar ainda mais pinos e processamento, podem ser utilizados drivers de hardware dedicados, como o MAX7221 ou o SAA1064, que gerenciam a multiplexa\u00e7\u00e3o e a decodifica\u00e7\u00e3o internamente via comunica\u00e7\u00e3o serial (SPI ou I2C).</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio03-display7seg/#referencias","title":"Refer\u00eancias","text":"<ol> <li>LIMA, Charles Borges de; VILLA\u00c7A, Marco V. M. AVR e Arduino: t\u00e9cnicas de projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012..</li> <li>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. [S.l.]: Jonathan Valvano, 2014. v. 1..</li> <li>SAP-1 (Simple-As-Possible Computer 1).</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/","title":"04 - Display de Cristal L\u00edquido","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/#1-display-de-cristal-liquido","title":"1. Display de Cristal L\u00edquido","text":"<p>Um display de cristal l\u00edquido (LCD - Liquid Crystal Display) \u00e9 uma interface de sa\u00edda amplamente utilizada em sistemas embarcados para fornecer informa\u00e7\u00f5es visuais ao usu\u00e1rio de forma conveniente e econ\u00f4mica, permitindo padr\u00f5es de exibi\u00e7\u00e3o flex\u00edveis com baixo consumo de energia.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/#11-tipos-de-displays","title":"1.1 Tipos de Displays","text":"<p>Os m\u00f3dulos LCD podem ser classificados em dois tipos principais:</p> <ul> <li>Alfanum\u00e9ricos (ou de caractere): Destinados \u00e0 exibi\u00e7\u00e3o de letras, n\u00fameros e s\u00edmbolos pr\u00e9-definidos. S\u00e3o especificados pelo n\u00famero de colunas e linhas, sendo os modelos 16 \u00d7 2 (16 caracteres por 2 linhas) e 20 \u00d7 4 os mais populares.</li> <li>Gr\u00e1ficos (GLCD): Compostos por uma matriz de pontos (pixels), como o modelo de 128 \u00d7 64, que permitem a cria\u00e7\u00e3o de figuras, \u00edcones e fontes customizadas.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/#12-hardware-e-conexao","title":"1.2 Hardware e Conex\u00e3o","text":"<p>A maioria dos displays alfanum\u00e9ricos utiliza o controlador Hitachi HD44780, que se tornou um padr\u00e3o de mercado. Para utiliz\u00e1-lo, \u00e9 necess\u00e1rio conectar os seguintes pinos:</p> <ul> <li>Alimenta\u00e7\u00e3o e Contraste: VSS (GND), VDD (VCC) e VEE, que deve ser ligado a um trimpot de 10k\u03a9 para ajustar a visibilidade dos caracteres.</li> <li>Controle: RS (Register Select - define se o dado \u00e9 instru\u00e7\u00e3o ou caractere), R/W (Read/Write - geralmente aterrado para modo de escrita) e E (Enable - habilita a leitura dos dados pelo LCD).</li> <li>Barramento de Dados: Composto pelos pinos DB0 a DB7.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/#13-modos-de-operacao-e-interface","title":"1.3 Modos de Opera\u00e7\u00e3o e Interface","text":"<p>Existem duas formas principais de interface paralela para displays alfanum\u00e9ricos:</p> <ol> <li>Interface de 8 bits: Utiliza todos os pinos de dados (DB0-DB7).</li> <li>Interface de 4 bits: Envia o byte de dado em duas partes (nibbles) utilizando apenas os pinos DB4 a DB7. Esta forma \u00e9 a mais recomendada, pois libera 4 pinos de E/S do microcontrolador para outras tarefas.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio04-displayLCD/#14-logica-de-utilizacao-e-programacao","title":"1.4 L\u00f3gica de Utiliza\u00e7\u00e3o e Programa\u00e7\u00e3o","text":"<p>Para que o LCD funcione corretamente, o firmware deve seguir uma sequ\u00eancia l\u00f3gica rigorosa:</p> <ul> <li>Inicializa\u00e7\u00e3o: Ap\u00f3s ligar a alimenta\u00e7\u00e3o, deve-se aguardar um tempo de estabiliza\u00e7\u00e3o (aprox. 15ms) e enviar uma sequ\u00eancia espec\u00edfica de comandos para configurar o modo de bits (4 ou 8), o n\u00famero de linhas e o estado do cursor.</li> <li>Escrita de Dados: Para exibir um caractere, coloca-se o pino RS em n\u00edvel alto (1), carrega-se o valor ASCII no barramento e gera-se um pulso no pino Enable (levar a 1 e depois a 0).</li> <li>Comandos: Para limpar a tela ou mover o cursor, o processo \u00e9 o mesmo, mas com o pino RS em n\u00edvel baixo (0).</li> <li>Arduino: A plataforma facilita o uso atrav\u00e9s da biblioteca <code>LiquidCrystal.h</code>, que abstrai a complexidade do protocolo Hitachi, permitindo comandos simples como <code>lcd.begin(colunas, linhas)</code> e <code>lcd.print(\"texto\")</code>.</li> </ul> Figura 1: Simula\u00e7\u00e3o de acionamento manual e inser\u00e7\u00e3o de caracteres Fonte: Autor (SimulIDE-1.1.0-SR1) <p>Al\u00e9m dos caracteres padr\u00e3o, esses dispositivos possuem uma mem\u00f3ria chamada CGRAM, onde o programador pode criar at\u00e9 oito caracteres especiais personalizados em uma matriz de 5 \u00d7 8 pixels.</p> Figura 2: Mapa de caracteres Fonte: Sparkfun - Hitachi","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/","title":"05 - Teclado Matricial","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/#1-teclado-matricial-4x4","title":"1. Teclado Matricial 4x4","text":"<p>Um teclado matricial \u00e9 uma interface de entrada composta por bot\u00f5es (chaves t\u00e1cteis) organizados em um arranjo de linhas e colunas. Essa t\u00e9cnica \u00e9 amplamente utilizada em sistemas embarcados para maximizar o uso dos pinos de I/O do microcontrolador.</p> <p>Diferente de conectar cada bot\u00e3o individualmente a um pino, o teclado matricial interconecta as chaves de forma que \\(N\\) linhas e \\(M\\) colunas resultem em \\(N \\times M\\) teclas utilizando apenas \\(N + M\\) pinos. Por exemplo:</p> <ul> <li>Um teclado de 16 teclas (4\u00d74) utiliza apenas 8 pinos do microcontrolador, em vez de 16.</li> <li>Internamente, as teclas s\u00e3o interruptores do tipo Normalmente Aberto (NA). Quando uma tecla \u00e9 pressionada, ela cria um curto-circuito el\u00e9trico entre uma linha e uma coluna espec\u00edfica.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/#11-como-usar-conexao-e-hardware","title":"1.1 Como usar: Conex\u00e3o e Hardware","text":"<p>Para o funcionamento correto, o hardware deve garantir que os pinos de entrada n\u00e3o fiquem \"flutuando\".</p> <ul> <li>Conex\u00e3o f\u00edsica: Geralmente, as linhas s\u00e3o configuradas como entradas (com resistores de pull-up ou pull-down) e as colunas como sa\u00eddas de controle. </li> <li>Resistores: O uso de resistores \u00e9 fundamental para manter um n\u00edvel l\u00f3gico conhecido quando nenhuma tecla est\u00e1 pressionada. Em microcontroladores com pull-ups internos, eles s\u00e3o utilizados frequentemente para simplificar o circuito.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/#12-a-tecnica-de-varredura-scanning","title":"1.2 A T\u00e9cnica de Varredura (Scanning)","text":"<p>A leitura do teclado n\u00e3o ocorre de forma passiva; o microcontrolador executa um processo sequencial chamado varredura:</p> <ol> <li>O sistema coloca n\u00edvel l\u00f3gico baixo (0) em apenas uma coluna por vez, mantendo as outras em n\u00edvel alto (1) ou alta imped\u00e2ncia.</li> <li>O software ent\u00e3o l\u00ea o estado das linhas. Se uma linha apresentar n\u00edvel baixo, significa que a tecla correspondente ao cruzamento daquela linha com a coluna ativa foi pressionada.</li> <li>Esse processo se repete rapidamente para todas as colunas, de modo que a percep\u00e7\u00e3o para o usu\u00e1rio seja instant\u00e2nea.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/#13-implementacao-em-software","title":"1.3 Implementa\u00e7\u00e3o em Software","text":"<p>Para converter o sinal el\u00e9trico em um caractere \u00fatil, o programador utiliza:</p> <ul> <li>Matriz de Decodifica\u00e7\u00e3o: Uma tabela (lookup table) no c\u00f3digo que associa os \u00edndices de linha e coluna aos caracteres desejados (como '1', '2', '3', 'A').</li> <li>Debounce: Assim como em bot\u00f5es simples, \u00e9 necess\u00e1rio aplicar um atraso (delay) de aproximadamente 10 ms a 20 ms para ignorar o ru\u00eddo mec\u00e2nico dos contatos antes de validar a tecla.</li> </ul> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/dio05-teclado/#14-alternativa-leitura-via-adc","title":"1.4 Alternativa: Leitura via ADC","text":"<p>Uma t\u00e9cnica avan\u00e7ada e ainda mais econ\u00f4mica em pinos consiste em utilizar uma rede resistiva ligada a um Conversor Anal\u00f3gico-Digital (ADC). Nesse arranjo, cada tecla pressionada gera uma tens\u00e3o \u00fanica em um \u00fanico pino anal\u00f3gico, permitindo ler at\u00e9 16 teclas com apenas um pino de I/O, embora exija resistores de precis\u00e3o para evitar erros de leitura.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Perifericos/mpu-6050/","title":"MPU-6050 - Aceler\u00f4metro / Girosc\u00f3pio","text":"","tags":["Sistemas Eletr\u00f4nicos","Dispositivos","Aceler\u00f4metro","Girosc\u00f3pio","Sensor de Temperatura","MPU-6050"]},{"location":"digitais/Perifericos/mpu-6050/#acelerometro-e-giroscopio-hw-123-mpu-6050","title":"Aceler\u00f4metro e Girosc\u00f3pio - HW-123 - MPU-6050","text":"","tags":["Sistemas Eletr\u00f4nicos","Dispositivos","Aceler\u00f4metro","Girosc\u00f3pio","Sensor de Temperatura","MPU-6050"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab06-deteccao_bordas/","title":"Lab 6 - Detec\u00e7\u00e3o de bordas","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab06-deteccao_bordas/#deteccao-de-bordas","title":"Detec\u00e7\u00e3o de bordas","text":"<p>A leitura simples de um bot\u00e3o implica em alguns comportamentos n\u00e3o desejados como um incremento maior do que a quantidade de vezes que um bot\u00e3o \u00e9 pressionado. Para solucionar esse problema pode-se utilizar n\u00e3o o estado l\u00f3gico do bot\u00e3o, mas sim o evendo associado a mudan\u00e7a de estado, evento \u00fanico dentro de um ciclo de opera\u00e7\u00e3o, que \u00e9 a borda de subida ou a borda de descida.</p> <p>A Figura 1 ilustra os sinais para a detec\u00e7\u00e3o de bordas de subida e descida em fun\u00e7\u00e3o de um sinal de entrada e intervalos discretos (t0, t1, ..., tn) representando o tempo de execu\u00e7\u00e3o de cada ciclo de execu\u00e7\u00e3o do programa principal. </p> Figura 1: Detec\u00e7\u00e3o de bordas de subida (rising) e descida (falling) Fonte: Autor <p>A detec\u00e7\u00e3o de uma borda, consiste em fazer a leitura do sinal de entrada no momento atual e comparar este valor com o valor da mesma entrada no ciclo anterior. </p> <p>Para a detec\u00e7\u00e3o da borda de subida, note que no instante de tempo t5, o sinal de entrada \u00e9 alto e no instante anterior, t4, o sinal era baixo, denotando uma transi\u00e7\u00e3o ascendente do sinal de entrada, ou seja, houve uma borda de subida. Assim, o sinal <code>rising</code>, que representa que houve tal transi\u00e7\u00e3o \u00e9 levada ao n\u00edvel alto. No instante seguinte, t6 o n\u00edvel se mant\u00e9m em n\u00edvel alto e no instante anterior, t5, tamb\u00e9m era n\u00edvel alto, n\u00e3o havendo mudan\u00e7a, e assim, deixando o sinal <code>rising</code> em n\u00edvel baixo. </p> <p>Na detec\u00e7\u00e3o de borda de descida,<code>falling</code>, ocorre o mesmo, por\u00e9m com a transi\u00e7\u00e3o do sinal de entrada do n\u00edvel alto para o n\u00edvel baixo, nos instantes t13 para o t14. </p> <p>Objetivo</p> <p>Detectar as bordas de subida e descida em bot\u00e3o pulsador, gerando um incremento e decremento de uma vari\u00e1vel de contagem.</p> Figura 2: Detec\u00e7\u00e3o de borda para incremento e decremento Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1 Entrada Bot\u00e3o pulsador NA B0 : incrementa contagem 13 19 PB5 Entrada Bot\u00e3o pulsador NA B1 : decrementa contagem 12 18 PB4","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab07-bibliotecas/","title":"Lab 7 - Bibliotecas","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab07-bibliotecas/#bibliotecas","title":"Bibliotecas","text":"<p>Quando um programa come\u00e7a a ganhar volume, ou seja, o n\u00famero de fun\u00e7\u00f5es come\u00e7a a aumentar, o c\u00f3digo come\u00e7a a ficar dif\u00edcil de manipular, com todas as fun\u00e7\u00f5es em um \u00fanico arquivo, a solu\u00e7\u00e3o \u00e9 separar as fun\u00e7\u00f5es em arquivos distintos, fazendo agrupamento de fun\u00e7\u00f5es por tipo de acionamento ou perif\u00e9rico. </p> <p>Esta organiza\u00e7\u00e3o facilita a manipula\u00e7\u00e3o do c\u00f3digo e a sua reutiliza\u00e7\u00e3o em outros projetos.</p> <p>Usando como exemplo o Lab 6 - Detec\u00e7\u00e3o de Borda, al\u00e9m da fun\u00e7\u00e3o principal <code>main</code>, existem fun\u00e7\u00f5es de manipula\u00e7\u00e3o dos displays de 7 segmentos, e das teclas de incremento e decremento. Podemos assim, separar todas as fun\u00e7\u00f5es em tr\u00eas arquivos, conforme ilustrado na Figura 1: </p> Figura 1: Diagrama de bibliotecas e declara\u00e7\u00e3o em programa principal Fonte: Autor <ul> <li>main.c: para a fun\u00e7\u00e3o principal e ponto de entrada da aplica\u00e7\u00e3o ou programa;</li> <li>disp7seg.c: para fun\u00e7\u00f5es de inicializa\u00e7\u00e3o e de manipula\u00e7\u00e3o dos pinos respons\u00e1veis por acionar corretamente o conjunto de displays de 7 segmentos;</li> <li>teclas.c: fun\u00e7\u00f5es para inicializar e manipular os pinos repons\u00e1veis pela leitura das teclas utilizados neste projeto. </li> </ul> <p>As vari\u00e1veis globais que forem utilzadas por um determinado perif\u00e9rico devem ser declaradas no respectivo arquivo.</p> <p>Neste caso, as fun\u00e7\u00f5es do display 7 segmentos e das teclas, formam uma camada que abstrai todo acesso aos perif\u00e9ricos, pinos de entrada e sa\u00edda e funcionalidades de exibi\u00e7\u00e3o dos d\u00edgitos e detec\u00e7\u00e3o de bordas nas teclas de uma \u00fanica vez, mas em muitos casos, estas camadas s\u00e3o separadas. </p> <p>Para cada arquivo <code>.c</code> deve haver um arquivo <code>.h</code> de mesmo nome, contendo os prot\u00f3tipos das fun\u00e7\u00f5es que podem ser acessadas/utilizadas.</p> <p>Objetivo</p> <p>Detectar as bordas de subida e descida em bot\u00e3o pulsador, gerando um incremento e decremento de uma vari\u00e1vel de contagem.</p> Figura 2: Detec\u00e7\u00e3o de borda para incremento e decremento Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1 Entrada Bot\u00e3o pulsador NA B0 : incrementa contagem 13 19 PB5 Entrada Bot\u00e3o pulsador NA B1 : decrementa contagem 12 18 PB4 <p>Biblioteca</p> \u00c1rvore do diret\u00f3rio<pre><code>--- avr_bordas\n    |\n    |`-----build|\n    |`-----dist|\n    |`-----bits.h\n    |`-----disp7seg.c\n    |`-----disp7seg.h\n    |`-----main.c\n    |`-----makefile.mak\n    |`-----teclas.c\n     `-----teclas.h\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> disp7seg.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n#define DISP7SEG_UNI_ON     SETBIT(PORTB,0)\n#define DISP7SEG_UNI_OFF    CLRBIT(PORTB,0)\n#define DISP7SEG_DEZ_ON     SETBIT(PORTB,1)\n#define DISP7SEG_DEZ_OFF    CLRBIT(PORTB,1)\n\n#define DIGITOS7SEG_SIZE    16\n\nchar digitos7seg[DIGITOS7SEG_SIZE] = {  0x3F, 0x06, 0x5B, 0x4F, \n                                        0x66, 0x6D, 0x7D, 0x07, \n                                        0x7F, 0x6F, 0x77, 0x7C, \n                                        0x39, 0x5E, 0x79, 0x71  };\n\nvoid disp7seg_init( void )\n{\n    DDRD  = 0xFF;\n    PORTD = 0x00;\n    SETBIT(DDRB, 0);    // Sele\u00e7\u00e3o de Display das Unidades\n    SETBIT(DDRB, 1);    // Sele\u00e7\u00e3o de Display das Dezenas\n}\nunsigned char disp7seg_scan = 0;\nvoid disp7seg( unsigned char d )\n{\n    switch( disp7seg_scan )\n    {\n        case 0: // Unidade\n                    DISP7SEG_DEZ_OFF;\n                    PORTD = digitos7seg[d%10];\n                    DISP7SEG_UNI_ON;\n                    break;\n        case 1: // Dezena\n                    DISP7SEG_UNI_OFF;\n                    PORTD = digitos7seg[(d/10)%10];\n                    DISP7SEG_DEZ_ON;\n                    break;\n    }\n    disp7seg_scan = ++disp7seg_scan % 2;\n}\n</code></pre> disp7seg.h<pre><code>#ifndef DISP7SEG_H\n#define DISP7SEG_H\n\nvoid disp7seg_init( void );\nvoid disp7seg( unsigned char d );\n\n#endif\n</code></pre> teclas.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n#define B0      !BIT(PINB,5)\n#define B1      !BIT(PINB,4)\n\nvoid teclas_init( void )\n{\n    CLRBIT(DDRB, 5); // PB5 Input (+1)\n    CLRBIT(DDRB, 4); // PB4 Input (-1)\n    SETBIT(PORTB,5); // PB5 Pull-up ON (+1)\n    SETBIT(PORTB,4); // PB4 Pull-up ON (-1)\n}\n\nchar b0( void )\n{\n    return( B0 );\n}\n\nchar b0_prev = 0;\nchar b0_rising_edge( void )\n{\n    if( B0 &amp;&amp; !b0_prev )\n    {\n        b0_prev = B0;\n        return( 1 );\n    }\n    else\n    {\n        b0_prev = B0;\n        return( 0 );\n    }\n}\n\nchar b0_falling_edge( void )\n{\n    if( !B0 &amp;&amp; b0_prev )\n    {\n        b0_prev = B0;\n        return( 1 );\n    }\n    else\n    {\n        b0_prev = B0;\n        return( 0 );\n    }\n}\n\n\n\nchar b1( void )\n{\n    return( B1 );\n}\n\nchar b1_prev = 0;\nchar b1_rising_edge( void )\n{\n    if( B1 &amp;&amp; !b1_prev )\n    {\n        b1_prev = B1;\n        return( 1 );\n    }\n    else\n    {\n        b1_prev = B1;\n        return( 0 );\n    }\n}\n\nchar b1_falling_edge( void )\n{\n    if( !B1 &amp;&amp; b1_prev )\n    {\n        b1_prev = B1;\n        return( 1 );\n    }\n    else\n    {\n        b1_prev = B1;\n        return( 0 );\n    }\n}\n</code></pre> teclas.h<pre><code>#ifndef TECLAS_H\n#define TECLAS_H\n\nvoid teclas_init( void );\n\nchar b0( void );\nchar b0_rising_edge( void );\nchar b0_falling_edge( void );\n\nchar b1( void );\nchar b1_rising_edge( void );\nchar b1_falling_edge( void );\n\n#endif\n</code></pre> main.c<pre><code>#include \"disp7seg.h\"\n#include \"teclas.h\"\n\nvoid main(void) \n{\n    char i = 0;\n    disp7seg_init();\n    teclas_init();\n    while( 1 )\n    {\n        if( b0_rising_edge() )\n        {\n            i = i&lt;99 ? i+1 : i;\n        }\n\n        if( b1_falling_edge() )\n        {\n            i = i&gt;0 ? i-1 : i;\n        }\n\n        disp7seg( i );\n    }\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab10-teclado/","title":"Lab 10 - Teclado Matricial","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab10-teclado/#teclado-matricial-4x4","title":"Teclado Matricial 4x4","text":"main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n#include \"teclado.h\"\n\nvoid main(void) \n{\n    char tecla;\n    char str[17] = \"Tecla:          \";\n\n    lcd_init();\n    teclado_init();\n\n    while( 1 )\n    {\n        tecla = teclado_scan();\n        str[7] = tecla;\n        lcd(0,0,str);\n    }\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> teclado.h<pre><code>#ifndef TECLADO_H\n#define TECLADO_H\n\nvoid teclado_init( void );\nunsigned char teclado_scan( void );\n\n#endif\n</code></pre> teclado.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    |Pino   |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 0     | Teclado Sa\u00edda   L0\n *  PB1     | 1     | Teclado Sa\u00edda   L1\n *  PB2     | 2     | Teclado Sa\u00edda   L2\n *  PB3     | 3     | Teclado Sa\u00edda   L3\n *  PB4     | 4     | Teclado Entrada C0\n *  PB5     | 5     | Teclado Entrada C1\n *  PB6     | 6     | Teclado Entrada C2\n *  PB7     | 7     | Teclado Entrada C3\n * -------------------------------------------------\n */\n\n#define NUM_COL         4\n#define NUM_LIN         4\n\n#define L0_MASK         0x01\n#define C0_MASK         0x10\n\n\nvoid teclado_init( void )\n{\n    DDRD = 0x0F;    // L_Mask\n    PORTD = 0xFF;   \n}\n\nconst char tecladoMatriz[4][4] =  { {'1','2','3','A'},\n                                    {'4','5','6','B'},\n                                    {'7','8','9','C'},\n                                    {'*','0','#','D'} };\n\n\n\nunsigned char teclado_scan( void )\n{\n    unsigned char aux = 0;\n    unsigned int l,c;\n\n    for( l=0; l&lt;NUM_LIN; l++ )\n    {\n        PORTD = ~(L0_MASK &lt;&lt; l);\n        for( c=0; c&lt;NUM_COL; c++ )\n        {\n            if( (~PIND) &amp; (C0_MASK&lt;&lt;c) )\n            {\n                aux = tecladoMatriz[l][c];\n            }\n        }\n    }   \n    return( aux );\n}\n</code></pre> lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\nvoid lcd_init( void );\nvoid lcd_clr( void );\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam );\n\n#endif\n</code></pre> lcd.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    | Pino  |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 8     | LCD_D4\n *  PB1     | 9     | LCD_D5\n *  PB2     | 10    | LCD_D6\n *  PB3     | 11    | LCD_D7\n *  PB4     | 12    | LCD_RS\n *  PB5     | 13    | LCD_EN\n * -------------------------------------------------\n */\n\n\n//***************** Interface com PORTs/Pinos\n#define LCD_ROWS        2\n#define LCD_COLS        16\n#define LCD_BUS(bus)    PORTB = ((PORTB &amp; 0xF0) | ((bus) &amp; 0x0F))\n#define LCD_RS(bit)     (bit) ? (SETBIT(PORTB,4)) : (CLRBIT(PORTB,4))\n#define LCD_EN(bit)     (bit) ? (SETBIT(PORTB,5)) : (CLRBIT(PORTB,5))\n\n//***************** Definicao de Comandos ao LCD \n#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n\n\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i )\n{   \n    LCD_RS(0);\n    LCD_BUS(i&gt;&gt;4);\n\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n\n    if( (i &amp; 0xF0) == (LCD_FUNCTION_SET | LCD_FS_DATA_LENGTH_4) )\n    {\n        LCD_BUS(i&gt;&gt;4);\n        LCD_EN(0);\n        _delay_us( 40 );\n        LCD_EN(1);\n    }\n\n    LCD_BUS(i);\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n}\n\n\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d )\n{\n    LCD_RS(1);\n    LCD_BUS(d &gt;&gt; 4);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n\n    LCD_BUS(d);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n}\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col)\n{\n    lcd_instReg( LCD_SET_DDRAM_ADDRS( ((LCD_ADDR_LINE_1 * lin) + (col + LCD_ADDR_LINE_0) ) ) );\n}\n\n\n\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void )\n{\n    DDRB |= 0x3F;\n    PORTB &amp;= ~0x3F;\n\n    LCD_EN(1);\n    lcd_instReg( LCD_FUNCTION_SET|LCD_FS_DATA_LENGTH_4|LCD_FS_LINE_NUMBER_2);\n    lcd_instReg( LCD_DISPLAY_CONTROL|LCD_DC_DISPLAY_ON|LCD_DC_CURSOR_OFF|LCD_DC_BLINK_OFF );\n    lcd_instReg( LCD_CLEAR_DISPLAY );\n    lcd_instReg( LCD_RETURN_HOME );\n}\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str )\n{\n    char pos = col;\n    lcd_lincol( lin, col );\n\n    while( *str )\n    {\n        lcd_dataReg( *str );\n        ++str;\n        ++pos;\n    }\n}\n\n// Escreve um n\u00famero inteiro no display\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam )\n{\n    int div;\n    unsigned char size;\n    char sinal; // 0:+ 1:-\n\n    sinal = (num &lt; 0);\n    if( sinal )\n        num = (~num) + 1;\n\n    lcd_lincol(lin, col);\n\n    div=10000;\n    size = 5;\n    while( div &gt; 1 )\n    {\n        if( num/div == 0 )\n            --size;\n        else\n            break;\n        div/=10;\n    }\n\n    while( tam &gt; (size+sinal) &amp;&amp; tam &gt; 1 )\n    {\n        lcd_dataReg(' ');\n        --tam;\n    }  \n\n    if( sinal )\n        lcd_dataReg('-');\n\n    do\n    {\n        lcd_dataReg( (num / div) + '0' );\n        num = num % div;\n        div/=10;\n    }\n    while( div &gt;= 1 );\n}\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void )\n{\n    lcd_instReg(LCD_CLEAR_DISPLAY);\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab11-ihm/","title":"Lab 11 - Interface Homem-M\u00e1quina","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab11-ihm/#interface-homem-maquina","title":"Interface Homem-M\u00e1quina","text":"<p>Elabore um programa que execute o que comportamento conforme ilustra\u00e7\u00e3o acima.</p> <p>Seguem c\u00f3digos de apoio para o display e teclado. </p> main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n#include \"teclado.h\"\n\n\nvoid main(void) \n{\n    char tecla;\n\n    lcd_init();\n    teclado_init();\n\n    while( 1 )\n    {\n        tecla = teclado_scan();\n\n    }\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> teclado.h<pre><code>#ifndef TECLADO_H\n#define TECLADO_H\n\nvoid teclado_init( void );\nunsigned char teclado_scan( void );\n\n#endif\n</code></pre> teclado.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    |Pino   |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 0     | Teclado Sa\u00edda   L0\n *  PB1     | 1     | Teclado Sa\u00edda   L1\n *  PB2     | 2     | Teclado Sa\u00edda   L2\n *  PB3     | 3     | Teclado Sa\u00edda   L3\n *  PB4     | 4     | Teclado Entrada C0\n *  PB5     | 5     | Teclado Entrada C1\n *  PB6     | 6     | Teclado Entrada C2\n *  PB7     | 7     | Teclado Entrada C3\n * -------------------------------------------------\n */\n\n#define NUM_COL         4\n#define NUM_LIN         4\n\n#define L0_MASK         0x01\n#define C0_MASK         0x10\n\n\nvoid teclado_init( void )\n{\n    DDRD = 0x0F;    // L_Mask\n    PORTD = 0xFF;   \n}\n\nconst char tecladoMatriz[4][4] =  { {'1','2','3','A'},\n                                    {'4','5','6','B'},\n                                    {'7','8','9','C'},\n                                    {'*','0','#','D'} };\n\n\n\nunsigned char teclado_scan( void )\n{\n    unsigned char aux = 0;\n    unsigned int l,c;\n\n    for( l=0; l&lt;NUM_LIN; l++ )\n    {\n        PORTD = ~(L0_MASK &lt;&lt; l);\n        for( c=0; c&lt;NUM_COL; c++ )\n        {\n            if( (~PIND) &amp; (C0_MASK&lt;&lt;c) )\n            {\n                aux = tecladoMatriz[l][c];\n            }\n        }\n    }   \n    return( aux );\n}\n</code></pre> lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\nvoid lcd_init( void );\nvoid lcd_clr( void );\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam );\n\n#endif\n</code></pre> lcd.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    | Pino  |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 8     | LCD_D4\n *  PB1     | 9     | LCD_D5\n *  PB2     | 10    | LCD_D6\n *  PB3     | 11    | LCD_D7\n *  PB4     | 12    | LCD_RS\n *  PB5     | 13    | LCD_EN\n * -------------------------------------------------\n */\n\n\n//***************** Interface com PORTs/Pinos\n#define LCD_ROWS        2\n#define LCD_COLS        16\n#define LCD_BUS(bus)    PORTB = ((PORTB &amp; 0xF0) | ((bus) &amp; 0x0F))\n#define LCD_RS(bit)     (bit) ? (SETBIT(PORTB,4)) : (CLRBIT(PORTB,4))\n#define LCD_EN(bit)     (bit) ? (SETBIT(PORTB,5)) : (CLRBIT(PORTB,5))\n\n//***************** Definicao de Comandos ao LCD \n#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n\n\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i )\n{   \n    LCD_RS(0);\n    LCD_BUS(i&gt;&gt;4);\n\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n\n    if( (i &amp; 0xF0) == (LCD_FUNCTION_SET | LCD_FS_DATA_LENGTH_4) )\n    {\n        LCD_BUS(i&gt;&gt;4);\n        LCD_EN(0);\n        _delay_us( 40 );\n        LCD_EN(1);\n    }\n\n    LCD_BUS(i);\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n}\n\n\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d )\n{\n    LCD_RS(1);\n    LCD_BUS(d &gt;&gt; 4);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n\n    LCD_BUS(d);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n}\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col)\n{\n    lcd_instReg( LCD_SET_DDRAM_ADDRS( ((LCD_ADDR_LINE_1 * lin) + (col + LCD_ADDR_LINE_0) ) ) );\n}\n\n\n\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void )\n{\n    DDRB |= 0x3F;\n    PORTB &amp;= ~0x3F;\n\n    LCD_EN(1);\n    lcd_instReg( LCD_FUNCTION_SET|LCD_FS_DATA_LENGTH_4|LCD_FS_LINE_NUMBER_2);\n    lcd_instReg( LCD_DISPLAY_CONTROL|LCD_DC_DISPLAY_ON|LCD_DC_CURSOR_OFF|LCD_DC_BLINK_OFF );\n    lcd_instReg( LCD_CLEAR_DISPLAY );\n    lcd_instReg( LCD_RETURN_HOME );\n}\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str )\n{\n    char pos = col;\n    lcd_lincol( lin, col );\n\n    while( *str )\n    {\n        lcd_dataReg( *str );\n        ++str;\n        ++pos;\n    }\n}\n\n// Escreve um n\u00famero inteiro no display\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam )\n{\n    int div;\n    unsigned char size;\n    char sinal; // 0:+ 1:-\n\n    sinal = (num &lt; 0);\n    if( sinal )\n        num = (~num) + 1;\n\n    lcd_lincol(lin, col);\n\n    div=10000;\n    size = 5;\n    while( div &gt; 1 )\n    {\n        if( num/div == 0 )\n            --size;\n        else\n            break;\n        div/=10;\n    }\n\n    while( tam &gt; (size+sinal) &amp;&amp; tam &gt; 1 )\n    {\n        lcd_dataReg(' ');\n        --tam;\n    }  \n\n    if( sinal )\n        lcd_dataReg('-');\n\n    do\n    {\n        lcd_dataReg( (num / div) + '0' );\n        num = num % div;\n        div/=10;\n    }\n    while( div &gt;= 1 );\n}\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void )\n{\n    lcd_instReg(LCD_CLEAR_DISPLAY);\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab12-timer/","title":"Lab 12 - Timer","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab12-timer/#temporizadorcontador-2","title":"Temporizador/Contador 2","text":"<p>O perif\u00e9rico Timer/Counter2 \u00e9 um temporizador ou contador de uso geral, com m\u00f3dulo de contagem de 8 bits.</p> <p>Um diagrama simplificado pode ser visto na Figura 1.</p> Figura 1: Diagrama de blocos simplificado do Timer/Counter 2 Fonte: Adaptado pelo autor de Datasheet <p>O Timer/counter2 possui alguns registradores para configurar um comportamento de contagem espec\u00edfico, produzindo temporiza\u00e7\u00e3o ou contagem, inclusive podendo implementar sa\u00eddas com o comportamento de modula\u00e7\u00e3o de largura de pulso (PWM - Pulse Width Modulation).</p> <p>A interface com a contagem ou temporiza\u00e7\u00e3o, se d\u00e1 por meio de sinais de requisi\u00e7\u00e3o de interrup\u00e7\u00e3o(Interrupt Request)  (TOVn, OCnA e OCnB) e clock, ou atrav\u00e9s de pinos para entrada de pulsos (pino Tn) do contador ou sa\u00eddas PWM (pinos OCnA e OCnB).</p> <p>Dentre as v\u00e1rias possibilidades que esta interface possibilita, usaremos apenas a configura\u00e7\u00e3o de temporiza\u00e7\u00e3o, tendo na Figura 2 o principal segmento do circuito que implementa esta funcionalidade.</p> Figura 2: Diagrama de blocos de contagem Fonte: Datasheet <p>Os sinais internos apresentados no diagrama s\u00e3o:</p> <ul> <li>\\(count\\): Incrementa ou decrementa o registrador de contagem TCNT2 em 1 unidade;</li> <li>\\(direction\\): Sele\u00e7\u00e3o entre incremento e decremento;</li> <li>\\(clear\\): Inicializa o registrador de contagem com o valor 0;</li> <li>\\(clk_{Tn}\\): Sinal de clock utilizado no Timer/Counter2;</li> <li>\\(top\\): Sinaliza que o registrador de contagem TCNT2 alcan\u00e7ou o seu valor m\u00e1ximo;</li> <li>\\(bottom\\): Sinaliza que o registrador de contagem TCNT2 alcan\u00e7ou o seu valor m\u00ednimo, zero.</li> </ul> <p>Dependendo do modo de opera\u00e7\u00e3o, o registrador TCNT2 \u00e9 zerado, incrementado ou decrementado em cada pulso no \\(clk_{Tn}\\). Este sinal pode ter origem no sinal de fonte de clock do controlador ou de uma fonte externa atrav\u00e9s de um pino (\\(Tn\\)).</p> <p>O modo mais simples de opera\u00e7\u00e3o \u00e9 denominado modo normal (normal mode), em que a dire\u00e7\u00e3o de contagem \u00e9 sempre incremental e n\u00e3o h\u00e1 um reset for\u00e7ado do contador, simplesmente o contador ao chegar em seu valor m\u00e1ximo (TOP) e ser incrementado retorna ao valor zero (BOTTON), conforme ilustrado na Figura 3, sendo este evento chamado de overflow, acionando uma sinaliza\u00e7\u00e3o (TOV2).</p> Figura 3: Diagrama de tempo da contagem (superior sem prescaler, inferior com prescaler de 8) Fonte: Datasheet <p>A Figura 4 ilustra o diagrama de blocos do circuito do divisor de frequ\u00eancia, o prescaler, com os poss\u00edveis divisores 8, 32, 64, 128 e 256. Sendo ainda poss\u00edvel a utiliza\u00e7\u00e3o de sinal de clock obtido diretamente do cristal que pode estar instalado junto ao microcontrolador. O escopo aqui aborda apenas a funcionalidade em que o clock prov\u00e9m do sinal de clock principal do microcontrolador, identificado como \\(clk_{I/O}\\).</p> Figura 4: Prescaler do Timer 2 Fonte: Datasheet <p>A configura\u00e7\u00e3o do comportamento \u00e9 realizada atrav\u00e9s dos seguintes registradores:</p> Figura 5: TCCR2B \u2013 Timer/Counter Control Register B Fonte: Datasheet Figura 6: TCNT2 \u2013 Timer/Counter Register Fonte: Datasheet Figura 7: TIMSK2 \u2013 Timer/Counter2 Interrupt Mask Register e  TIFR2 \u2013 Timer/Counter2 Interrupt Flag Register Fonte: Datasheet <p>Exemplo de simula\u00e7\u00e3o de temporiza\u00e7\u00e3o</p> <p></p> <p>C\u00f3digo de teste do Temporizador</p> main.c<pre><code>#include \"lcd.h\"\n#include \"teclado.h\"\n#include \"timer2.h\"\n\nint main(void)\n{\n    char tecla;\n    unsigned long t = 0;\n\n    timer2_init();\n    teclado_init();\n    lcd_init();\n\n    lcd(0,0,\" Temporizador:  \");\n    lcd(1,0,\"   h   min   s  \");\n    while( 1 )\n    {\n        tecla = teclado_scan();\n\n        if( timer2_status() == 0 )\n        {\n            timer2_set( 1000 );\n            t++;\n            lcd_num(1, 0,t/(60*60),3);\n            lcd_num(1, 5,t/(60),2);\n            lcd_num(1,11,t%(60),2);\n        }\n    }\n    return( 0 );\n}\n</code></pre> timer2.h<pre><code>#ifndef TIMER2_H\n#define TIMER2_H\n\nvoid timer2_init( void );\nvoid timer2_set( unsigned long t );\nunsigned long timer2_status( void );\n\n#endif\n</code></pre> timer2.c<pre><code>#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n\n#define T2INT_OVERFLOW_EN   0x01\n#define T2COUNT_RELOAD      (256-250)\n#define T2NO_CLK            0x00\n#define T2CLK_DIV_8         0x01\n#define T2CLK_DIV_16        0x02\n#define T2CLK_DIV_32        0x03\n#define T2CLK_DIV_64        0x04\n#define T2CLK_DIV_128       0x05\n#define T2CLK_DIV_256       0x06\n#define T2CLK_DIV_1024      0x07\n\nunsigned long t2_t = 0;\n\nvoid timer2_init( void )\n{\n    cli();\n    TCCR2B  = T2CLK_DIV_64;\n    TCNT2   = T2COUNT_RELOAD;\n    TIMSK2  = T2INT_OVERFLOW_EN;\n    t2_t = 0;\n    sei();\n}\n\nISR(TIMER2_OVF_vect) // 1ms\n{\n    TCNT2 = T2COUNT_RELOAD;\n    if( t2_t )\n        --t2_t;\n}\n\nvoid timer2_set( unsigned long t )\n{\n    t2_t = t;\n}\n\nunsigned long timer2_status( void )\n{\n    return( t2_t );\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab13-adc/","title":"Lab 13 - ADC","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab13-adc/#conversor-analogico-digital-adc","title":"Conversor Anal\u00f3gico Digital (ADC)","text":"<p>O conversor anal\u00f3gico digital realiza convers\u00e3o por aproxima\u00e7\u00e3o sucessiva utilizando uma resolu\u00e7\u00e3o de 10 bits.</p> <p>Possui 8 canais, associados ao PORTA, multiplexados ao conversor, com circuito que garante o valor da amostra durante o tempo de convers\u00e3o.</p> <p>A refer\u00eancia de tens\u00e3o do conversor \u00e9 o GND e a tens\u00e3o de fundo de escala pode ser aplicada ao pino <code>AVcc</code> ou atrav\u00e9s de uma tens\u00e3o de refer\u00eancia interna de <code>1.1V</code>.</p> <p>Um diagrama simplificado pode ser visto na Figura 1.</p> Figura 1: Diagrama de blocos simplificado do ADC Fonte: Adaptado pelo autor de Datasheet <p>Os registradores de configura\u00e7\u00e3o do ADC s\u00e3o:</p> Figura 2: ADC Multiplexer Selection Register Fonte: Datasheet Figura 3: DC Control and Status Register A Fonte: Datasheet Figura 4: Digital Input Disable Register 0 Fonte: Datasheet <p>C\u00f3digo fonte de exemplo</p> main.c<pre><code>#include \"lcd.h\"\n#include \"adc.h\"\n\nint main(void)\n{\n    adc_init();\n    lcd_init();\n\n    lcd(0,0,\" x:      y:     \");\n\n    while( 1 )\n    {\n        if( adc_available() )\n        {\n            lcd_num(0, 4,adc_ch0(),4);\n            lcd_num(0,11,adc_ch1(),4);\n            adc_start();\n        }\n    }\n    return( 0 );\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BITVAL(bit)         (1&lt;&lt;bit)\n\n#define SETBIT(var,bit)     (var |=  (1&lt;&lt;bit))\n#define CLRBIT(var,bit)     (var &amp;= ~(1&lt;&lt;bit))\n#define TOGBIT(var,bit)     (var ^=  (1&lt;&lt;bit))\n#define TSTBIT(var,bit)     (var &amp;   (1&lt;&lt;bit))\n\n#endif\n</code></pre> adc.h<pre><code>#ifndef ADC_H\n#define ADC_H\n\nvoid adc_init();\nvoid adc_start( void );\nchar adc_available( void );\nint adc_ch0( void );\nint adc_ch1( void );\n\n#endif\n</code></pre> adc.c<pre><code>#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include \"adc.h\"\n#include \"bits.h\"\n\n\n// -------------------------------------- Vars\nunsigned int adc0_value = 0;\nunsigned int adc1_value = 0;\nunsigned int adc_value;\nunsigned char adc_available_flag = 0;\n\n\n\n// -------------------------------------- adc_init\n    // Sele\u00e7\u00e3o de tens\u00e3o de refer\u00eancia\n#define ADC_AVCC    BITVAL(REFS0)\n#define ADC_1V1     (BITVAL(REFS1)|BITVAL(REFS0))\n#define ADC_AREF    0\n\n// Sele\u00e7\u00e3o de canal para conversao\n#define ADC_CH0     0\n#define ADC_CH1     1\n#define ADC_CH2     2\n#define ADC_CH3     3\n#define ADC_CH4     4\n#define ADC_CH5     5\n\n\n    // Ajuste de bits (Left Adjust Result)\n#define ADC_LAR    BITVAL(ADLAR)\n\n// --------------------------------------\n    // Habilita conversor AD\n#define ADC_EN      BITVAL(ADEN)\n    // Inicia a conversao AD\n#define ADC_START   BITVAL(ADSC)\n    // Habilita Trigger Automatico\n#define ADC_ATE     BITVAL(ADATE)\n    // Habilita Interrupcao\n#define ADC_IE      BITVAL(ADIE)\n    // Fator de divisao - ADC Prescaler\n#define ADC_FREQ_DIV_2      0x1\n#define ADC_FREQ_DIV_4      0x2\n#define ADC_FREQ_DIV_8      0x3\n#define ADC_FREQ_DIV_16     0x4\n#define ADC_FREQ_DIV_32     0x5\n#define ADC_FREQ_DIV_64     0x6\n#define ADC_FREQ_DIV_128    0x7\n\n\n\n// -------------------------------------- adc_init\nvoid adc_init( void )\n{\n    cli();\n    ADMUX = (ADC_AVCC | ADC_CH1 );\n    ADCSRA = (ADC_EN | ADC_IE | ADC_FREQ_DIV_128);\n    sei();\n    adc_start();\n}\n\n\n\n// -------------------------------------- adc_start\nvoid adc_start( void )\n{\n    SETBIT(ADMUX, MUX0);        // CH1\n    SETBIT(ADCSRA, ADSC);       // START\n    adc_available_flag = 0;\n}\n\n\n\n// -------------------------------------- adc_interrupt\nISR( ADC_vect )\n{\n    adc_value = ADC;\n    if( TSTBIT(ADMUX, MUX0) )   // CH1\n    {\n        adc1_value = adc_value;\n        CLRBIT(ADMUX, MUX0);        // CH0\n        SETBIT(ADCSRA, ADSC);       // START\n    }\n    else                        // CH0\n    {\n        adc0_value = adc_value;\n        adc_available_flag = 1;\n    }\n}\n\n\n\n// -------------------------------------- adc available\nchar adc_available( void )\n{\n    return( adc_available_flag );\n}\n\n\n// -------------------------------------- adc result\nint adc_ch0( void )\n{\n    return( adc0_value );\n}\nint adc_ch1( void )\n{\n    return( adc1_value );\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab14-usart/","title":"USART: Universal Asynchronous Receiver/Transmitter","text":"<p>O receptor e transmissor serial s\u00edncrono e ass\u00edncrono universal (USART) \u00e9 um dispositivo de comunica\u00e7\u00e3o serial altamente flex\u00edvel.</p> <p>Possui as seguintes caracter\u00edsticas:</p> <ul> <li>Opera\u00e7\u00e3o full duplex (registradores de recep\u00e7\u00e3o e transmiss\u00e3o seriais independentes);</li> <li>Opera\u00e7\u00e3o ass\u00edncrona ou s\u00edncrona;</li> <li>Opera\u00e7\u00e3o s\u00edncrona com clock mestre ou escravo;</li> <li>Gerador de taxa de transmiss\u00e3o de alta resolu\u00e7\u00e3o;</li> <li>Suporta pacotes seriais com 5, 6, 7, 8 ou 9 bits de dados e 1 ou 2 bits de parada;</li> <li>Gera\u00e7\u00e3o de paridade par ou \u00edmpar e verifica\u00e7\u00e3o de paridade suportadas por hardware;</li> <li>Detec\u00e7\u00e3o de estouro de dados;</li> <li>Detec\u00e7\u00e3o de erro de enquadramento;</li> <li>Filtragem de ru\u00eddo inclui detec\u00e7\u00e3o de bit de in\u00edcio falso e filtro passa-baixo digital;</li> <li>Tr\u00eas interrup\u00e7\u00f5es separadas para TX completo, registro de dados TX vazio e RX completo;</li> <li>Modo de comunica\u00e7\u00e3o multiprocessador;</li> <li>Modo de comunica\u00e7\u00e3o ass\u00edncrona de dupla velocidade.</li> </ul> <p>Um diagrama de blocos simplificado do transmissor USART \u00e9 mostrado na Figura 1.</p> <p>Os registradores de E/S acess\u00edveis pela CPU s\u00e3o mostrados em negrito.</p> <p>As caixas tracejadas no diagrama de blocos separam as tr\u00eas partes principais do USART (listadas de cima para baixo): gerador de clock, transmissor e receptor.</p> <p>Os registradores de controle s\u00e3o compartilhados por todas as unidades.</p> <p>A l\u00f3gica de gera\u00e7\u00e3o de clock consiste na l\u00f3gica de sincroniza\u00e7\u00e3o para a entrada de clock externo usada pela opera\u00e7\u00e3o escrava s\u00edncrona e no gerador de taxa de transmiss\u00e3o. O pino XCKn (clock de transfer\u00eancia) \u00e9 usado apenas no modo de transfer\u00eancia s\u00edncrona.</p> <p>O transmissor consiste em um \u00fanico buffer de grava\u00e7\u00e3o, um registrador de deslocamento serial, um gerador de paridade e l\u00f3gica de controle para lidar com diferentes formatos de pacotes seriais. O buffer de grava\u00e7\u00e3o permite uma transfer\u00eancia cont\u00ednua de dados sem qualquer atraso entre os pacotes.</p> <p>O receptor \u00e9 a parte mais complexa do m\u00f3dulo USART devido \u00e0s suas unidades de clock e recupera\u00e7\u00e3o de dados. As unidades de recupera\u00e7\u00e3o s\u00e3o usadas para recep\u00e7\u00e3o ass\u00edncrona de dados. Al\u00e9m das unidades de recupera\u00e7\u00e3o, o receptor inclui um verificador de paridade, l\u00f3gica de controle, um registrador de deslocamento e um buffer de recep\u00e7\u00e3o de dois n\u00edveis (UDRn). O receptor suporta os mesmos formatos de pacote que o transmissor e pode detectar erros de pacote, estouro de dados e erros de paridade.</p> Figura 1: Diagrama de Blocos - USART Fonte: Datasheet p. 144 <p>A Gera\u00e7\u00e3o de Clock</p> <p>A l\u00f3gica de gera\u00e7\u00e3o de clock, Figura 2, ilustra a gera\u00e7\u00e3o do clock base para o transmissor e o receptor.</p> <p>O USART suporta quatro modos de opera\u00e7\u00e3o de clock: modo ass\u00edncrono normal, modo ass\u00edncrono de velocidade dupla, modo s\u00edncrono mestre e modo s\u00edncrono escravo.</p> <p>O bit UMSELn no registrador de controle e status C do USART (UCSRnC) seleciona entre opera\u00e7\u00e3o ass\u00edncrona e s\u00edncrona.</p> <p>A velocidade dupla (somente modo ass\u00edncrono) \u00e9 controlada pelo U2Xn encontrado no registrador UCSRnA.</p> <p>Ao usar o modo s\u00edncrono (UMSELn = 1), o registrador de dire\u00e7\u00e3o de dados para o pino XCKn (DDR_XCKn) controla se a fonte de clock \u00e9 interna (modo mestre) ou externa (modo escravo).</p> <p>O pino XCKn s\u00f3 fica ativo ao usar o modo s\u00edncrono.</p> Figura 2: Diagrama de Blocos - L\u00f3gica de gera\u00e7\u00e3o de clock Fonte: Datasheet p. 145 <p>O registrador de taxa de transmiss\u00e3o USART (UBRRn) e o contador regressivo conectado a ele funcionam como um pr\u00e9-escalador program\u00e1vel ou gerador de taxa de transmiss\u00e3o. O contador regressivo, operando no clock do sistema (\\(f_{osc}\\)), \u00e9 carregado com o valor <code>UBRRn</code> cada vez que o contador chega a zero ou quando o registrador <code>UBRRnL</code> \u00e9 gravado. Um clock \u00e9 gerado cada vez que o contador chega a zero. Este clock \u00e9 a sa\u00edda de clock do gerador de taxa de transmiss\u00e3o: \\(\\frac{f_{osc}}{UBRRn + 1}\\). O transmissor divide a sa\u00edda de clock do gerador de taxa de transmiss\u00e3o por 2, 8 ou 16, dependendo do modo. A sa\u00edda do gerador de taxa de transmiss\u00e3o \u00e9 utilizada diretamente pelas unidades de rel\u00f3gio e recupera\u00e7\u00e3o de dados do receptor. No entanto, as unidades de recupera\u00e7\u00e3o utilizam uma m\u00e1quina de estados que utiliza 2, 8 ou 16 estados, dependendo do modo definido pelo estado dos bits <code>UMSELn</code>, <code>U2Xn</code> e <code>DDR_XCKn</code>.</p> Figura 3: C\u00e1lculo da taxa de transmiss\u00e3o (Baud Rate [bps]) Fonte: Datasheet p. 146 <p>Quadro ou Pacote de dados (data frame)</p> <p>Um frame serial \u00e9 definido como um dcaractere de bits de dados com bits de sincroniza\u00e7\u00e3o (bits de in\u00edcio e parada) e, opcionalmente, um bit de paridade para verifica\u00e7\u00e3o de erros. O USART aceita todas as 30 combina\u00e7\u00f5es dos seguintes formatos de quadro v\u00e1lidos:</p> <ul> <li>1 bit de in\u00edcio</li> <li>5, 6, 7, 8 ou 9 bits de dados</li> <li>bit de paridade sem paridade, par ou \u00edmpar</li> <li>1 ou 2 bits de parada</li> </ul> <p>Um frame come\u00e7a com o bit de in\u00edcio seguido pelo bit de dados menos significativo. Em seguida, os pr\u00f3ximos bits de dados, at\u00e9 um total de nove, s\u00e3o sucessivos, terminando com o bit mais significativo. Se habilitado, o bit de paridade \u00e9 inserido ap\u00f3s os bits de dados, antes dos bits de parada.</p> <p>Quando um frame completo \u00e9 transmitido, ele pode ser seguido diretamente por um novo quadro, ou a linha de comunica\u00e7\u00e3o pode ser definida para um estado ocioso (alto). A Figura 4 ilustra as combina\u00e7\u00f5es poss\u00edveis dos formatos de frame. Os bits entre colchetes s\u00e3o opcionais.</p> Figura 4: Formatos de frame Fonte: Datasheet p. 147 <p>Registradores do USART</p> Figura 5: Registradores do USART Fonte: Datasheet p. 159-162 <p>C\u00f3digo fonte de exemplo</p> main.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"delay.h\"\n#include \"usart.h\"\n\nint main(void)\n{\n    uart_init(9600, 8, 'n', 1);\n    while( 1 )\n    {\n        uart_tx(\"IFSP Salto\", 10);\n        DELAY(1000);\n    }\n    return( 0 );\n}\n</code></pre> usart.c<pre><code>#include &lt;xc.h&gt;\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include \"usart.h\"\n#include \"delay.h\"\n\nvolatile unsigned char rx_var = 0;\nunsigned char   tx_count = 0;\nunsigned char * tx_ptr;\n\nvoid uart_tx( unsigned char * ptr, unsigned char n )\n{\n    tx_ptr = ptr;\n    tx_count = n;\n    if( n )\n    {\n        UDR0 = *tx_ptr;\n        --tx_count;\n    }\n}\n\nISR(USART_TX_vect)\n{\n    if( tx_count )\n    {\n        UDR0 = *++tx_ptr;\n        --tx_count;\n    }\n}\n\nISR(USART_RX_vect)\n{\n    rx_var = UDR0;\n}\n\nunsigned char uart_rx( void )\n{\n    return( rx_var );\n}\n\n\n\n\n//\n// USART: Universal Synchronous Asynchronous Receiver/Transmitter\n// Configuration\n//\ntypedef struct\n{\n    unsigned char MPCMn:1;  // (R/W) Multi-processor Communication Mode\n    unsigned char U2Xn:1;   // (R/W) Double the USART Transmission Speed\n    unsigned char UPEn:1;   // (R  ) USART Parity Error\n    unsigned char DORn:1;   // (R  ) Data OverRun\n    unsigned char FEn:1;    // (R  ) Frame Error\n    unsigned char UDREn:1;  // (R  ) USART Data Register Empty\n    unsigned char TXCn:1;   // (R/W) USART Transmit Complete\n    unsigned char RXCn:1;   // (R  ) USART Receive Complete\n} UCSRnA_T;                 // 0x20  Initial Value\n\ntypedef struct\n{\n    unsigned char TXB8n:1;  // (R/W) Transmit Data Bit 8 n\n    unsigned char RXB8n:1;  // (R  ) Receive Data Bit 8 n\n    unsigned char UCSZn2:1; // (R/W) Character Size n\n    unsigned char TXENn:1;  // (R/W) Transmitter Enable n\n    unsigned char RXENn:1;  // (R/W) Receiver Enable n\n    unsigned char UDRIEn:1; // (R/W) USART Data Register Empty Interrupt Enable n\n    unsigned char TXCIEn:1; // (R/W) TX Complete Interrupt Enable n\n    unsigned char RXCIEn:1; // (R/W) RX Complete Interrupt Enable n\n} UCSRnB_T;                 // 0x00  Initial Value\n\ntypedef union\n{\n    struct\n    {\n        unsigned char UCPOLn:1; // (R/W) Clock Polarity\n        unsigned char UCSZn:2;  // (R/W) Character Size\n        unsigned char USBSn:1;  // (R/W) Stop Bit Select\n        unsigned char UPMn: 2;  // (R/W) Parity Mode\n        unsigned char UMSEL:2;  // (R/W) USART Mode Select\n    } bits;                 // 0x06  Initial Value\n    unsigned char byte;\n} UCSRnC_U;\n\n#define UART_INIT_ERROR_BAUDRATE        0x01\n#define UART_INIT_ERROR_NBITS           0x02\n#define UART_INIT_ERROR_PARITY          0x04\n#define UART_INIT_ERROR_STOPBITS        0x08\n\nunsigned char uart_init( unsigned long baudrate, char nbits, char parity, char stopbits )\n{\n    UCSRnC_U UCSRnC;\n    unsigned char erro = 0;\n\n    UCSRnC.bits.UMSEL = 0;  // 0: async;  1: sync;  2: Reserved;  3: Master SPI\n    UCSRnC.bits.UCPOLn = 0; // Write this bit to zero when asynchronous mode is used. (p\u00e1g. 162 datasheet)\n\n    switch( nbits )\n    {\n        case 5:     UCSRnC.bits.UCSZn = 0;               break;\n        case 6:     UCSRnC.bits.UCSZn = 1;               break;\n        case 7:     UCSRnC.bits.UCSZn = 2;               break;\n        case 8:     UCSRnC.bits.UCSZn = 3;               break;\n        case 9:     UCSRnC.bits.UCSZn = 3;               break;\n        default:    erro |= UART_INIT_ERROR_NBITS;       break;\n    }\n    switch( parity )\n    {\n        case 'N':\n        case 'n':\n                    UCSRnC.bits.UPMn = 0;                break;\n        case 'E':\n        case 'e':\n                    UCSRnC.bits.UPMn = 2;                break;\n        case 'O':\n        case 'o':\n                    UCSRnC.bits.UPMn = 3;                break;\n        default:    erro |= UART_INIT_ERROR_PARITY;      break;\n    }\n    switch( stopbits )\n    {\n        case 1:     UCSRnC.bits.USBSn = 0;               break;\n        case 2:     UCSRnC.bits.USBSn = 1;               break;\n        default:    erro |= UART_INIT_ERROR_STOPBITS;    break;\n    }\n\n    cli();\n    UBRR0 = ((F_CPU&gt;&gt;4)/(baudrate))-1;\n    UCSR0B = (1&lt;&lt;RXCIE0)|(1&lt;&lt;TXCIE0)|(1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);\n    UCSR0C = UCSRnC.byte;\n    sei();\n}\n</code></pre> usart.h<pre><code>#ifndef USART_H\n#define USART_H\n\nunsigned char uart_init( unsigned long baudrate, char nbits, char parity, char stopbits );\nunsigned char uart_rx( void );\nvoid uart_tx( unsigned char * ptr, unsigned char n );\n\n#endif\n</code></pre> delay.h<pre><code>#ifndef DELAY_H\n#define DELAY_H\n\n#define F_CPU   16000000\n#include &lt;util/delay.h&gt;\n\n#define DELAY( t )        _delay_ms( t )\n\n#endif\n</code></pre> <p></p> <p>Refer\u00eancias</p> <ol> <li>Datasheet</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab_atividades/","title":"Lab Atividades","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/lab_atividades/#situacao-de-aprendizagem-somativa","title":"Situa\u00e7\u00e3o de Aprendizagem Somativa","text":"<p>Avalia\u00e7\u00e3o MMR (Microcontroladores - AVR) - Forms</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa01-sinalizador_garagem/","title":"Sinalizador de garagem","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa01-sinalizador_garagem/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de sinaliza\u00e7\u00e3o de seguran\u00e7a para sa\u00edda de ve\u00edculos em garagem.</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa01-sinalizador_garagem/#2-requisitos-da-solucao","title":"2. Requisitos da solu\u00e7\u00e3o","text":"<ol> <li>Luzes piscando enquanto o port\u00e3o estiver aberto;</li> <li>Intervalo de altern\u00e2ncia entre luzes: 500 ms.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa01-sinalizador_garagem/#3-planejamento-da-solucao","title":"3. Planejamento da solu\u00e7\u00e3o","text":"<ol> <li>Planejamento do produto final</li> <li>Planejamento das ferramentas e materiais</li> <li>Planejamento do processo</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa02-partida_estrela_triangulo/","title":"Partida Estrela-Tri\u00e2ngulo","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa02-partida_estrela_triangulo/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de comando para partida Estrela-Tri\u00e2ngulo. </p> Figura 1: Diagramas de comando e pot\u00eancia da partida Estrela-Tri\u00e2ngulo Fonte: Wikipedia","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa02-partida_estrela_triangulo/#2-requisitos-da-solucao","title":"2. - Requisitos da solu\u00e7\u00e3o","text":"<ol> <li>Interface<ol> <li>Bot\u00e3o de partida: S1;</li> <li>Bot\u00e3o de parada: S0;</li> <li>Contatores de acionamento do motor: K1, K2 e K3.</li> </ol> </li> <li>Comportamento<ul> <li>Ao pressionar S1<ul> <li>Ligar K1, K2 (fechamento estrela);</li> <li>Temporizar 5 segundos</li> <li>Desligar K2 e ligar K3 (fechamento tri\u00e2ngulo).</li> </ul> </li> <li>Ao pressionar S0, em qualquer momento:<ul> <li>Desligar todos os contatores.</li> </ul> </li> </ul> </li> <li>Estrutura (Hardware): Circuito eletr\u00f4nico<ul> <li>Acionamento via Rel\u00e9 ou transistor;</li> <li>Tens\u00e3o opera\u00e7\u00e3o: 24V, 12V ou 5V.</li> </ul> </li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa02-partida_estrela_triangulo/#3-planejamento-da-solucao","title":"3. Planejamento da solu\u00e7\u00e3o","text":"<ol> <li>Planejamento do produto final</li> <li>Planejamento das ferramentas e materiais</li> <li>Planejamento do processo</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa03-semaforo/","title":"Sem\u00e1foro","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa03-semaforo/#1-objetivo","title":"1. Objetivo","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de controle de tr\u00e1fego (sem\u00e1foro), a ser instalado em um cruzamento de pedestre. </p> Figura 1a: Exemplo de cruzamento de pedestres Figura 1b: Sem\u00e1foro para ve\u00edculos Fonte: freepik","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa03-semaforo/#2-requisitos-da-solucao","title":"2. Requisitos da solu\u00e7\u00e3o","text":"<ol> <li>Interface<ol> <li>Sem\u00e1foro de ve\u00edculos (Vm, Am, Vd);</li> <li>Sem\u00e1foro de pedestres (Vd, Vm);</li> <li>Bot\u00e3o pulsador para pedestres.</li> </ol> </li> <li>Comportamento<ul> <li>Intervalo de tempo para o Sem\u00e1foro de Ve\u00edculos(sv):<ul> <li>Verde: 42s</li> <li>Amarelo: 3s</li> <li>Vermelho: 15s</li> </ul> </li> <li>Sem\u00e1foro de Pedestre(sp) sincronizado com o de ve\u00edculos:<ul> <li>Verde (sv) : Vermelho (sp)</li> <li>Amarelo (sv) : Vermelho (sp)</li> <li>Vermelho (sv) : Verde (sp)</li> <li>Piscar Vermelho (sp) 3x antes de mudar em definitivo.</li> </ul> </li> <li>Bot\u00e3o pulsador para antecipar libera\u00e7\u00e3o de passagem dos pedestres:<ul> <li>Se faltar mais do que 10s para o acionamento da cor amarela, reduzir para 10s.</li> <li>Se faltar menos do que 10s para o acionamento da cor amarela, manter o tempo restante.</li> </ul> </li> </ul> </li> <li>Estrutra (Hardware): Circuito eletr\u00f4nico<ul> <li>Pot\u00eancia por sinaleiro: 7W</li> <li>Tens\u00e3o de opera\u00e7\u00e3o: 24V</li> </ul> </li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa03-semaforo/#3-planejamento-da-solucao","title":"3. Planejamento da solu\u00e7\u00e3o","text":"<ol> <li>Planejamento do produto final</li> <li>Planejamento das ferramentas e materiais</li> <li>Planejamento do processo</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa04-semaforo_temporizado/","title":"Sem\u00e1foro com temporizador","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa04-semaforo_temporizado/#1-objetivo","title":"1. Objetivo:","text":"<p>Desenvolver uma aplica\u00e7\u00e3o, programa, para um ser executado na simula\u00e7\u00e3o de controle de tr\u00e1fego (sem\u00e1foro), a ser instalado em um cruzamento de pedestre. </p> Figura 1a: Exemplo de cruzamento de pedestres Figura 1b: Sem\u00e1foro para ve\u00edculos Fonte: freepik","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa04-semaforo_temporizado/#2-requisitos-da-solucao","title":"2. Requisitos da solu\u00e7\u00e3o","text":"<ol> <li>Interface<ol> <li>Sem\u00e1foro de ve\u00edculos (Vm, Am, Vd);</li> <li>Sem\u00e1foro de pedestres (Vd, Vm);</li> <li>Bot\u00e3o pulsador para pedestres;</li> <li>Display de temporiza\u00e7\u00e3o decrescente;</li> </ol> </li> <li>Comportamento<ul> <li>Intervalo de tempo para o Sem\u00e1foro de Ve\u00edculos(sv):<ul> <li>Verde: 42s</li> <li>Amarelo: 3s</li> <li>Vermelho: 15s</li> </ul> </li> <li>Sem\u00e1foro de Pedestre(sp) sincronizado com o de ve\u00edculos:<ul> <li>Verde (sv) : Vermelho (sp)</li> <li>Amarelo (sv) : Vermelho (sp)</li> <li>Vermelho (sv) : Verde (sp)</li> <li>Piscar Vermelho (sp) 3x antes de mudar em definitivo.</li> </ul> </li> <li>Bot\u00e3o pulsador para antecipar libera\u00e7\u00e3o de passagem dos pedestres:<ul> <li>Se faltar mais do que 10s para o acionamento da cor amarela, reduzir para 10s.</li> <li>Se faltar menos do que 10s para o acionamento da cor amarela, manter o tempo restante.</li> </ul> </li> <li>O display de temporiza\u00e7\u00e3o deve exibir a contagem decrescente com o tempo restante para atravessia do pedestre, ou o tempo restante da cor vermelha no sem\u00e1foro dos ve\u00edculos. <ul> <li>Em qualquer outra situa\u00e7\u00e3o, o display n\u00e3o deve mostrar contagem, apenas uma indica\u00e7\u00e3o de que est\u00e1 funcionando, n\u00e3o podendo ficar totalmente apagado. </li> </ul> </li> </ul> </li> <li>Estrutra (Hardware): Circuito eletr\u00f4nico<ul> <li>Pot\u00eancia por sinaleiro: 7W</li> <li>Tens\u00e3o de opera\u00e7\u00e3o: 24V</li> <li>Displays de 7 segmentos Anodo ou Catodo comum</li> </ul> </li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa04-semaforo_temporizado/#3-planejamento-da-solucao","title":"3. Planejamento da solu\u00e7\u00e3o","text":"<ol> <li>Planejamento do produto final</li> <li>Planejamento das ferramentas e materiais</li> <li>Planejamento do processo</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa04-semaforo_temporizado/#4-solucao","title":"4. Solu\u00e7\u00e3o","text":"<p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/","title":"05 - Display de Cristal L\u00edquido","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/#biblioteca-do-display-de-cristal-liquido","title":"Biblioteca do Display de Cristal L\u00edquido","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/#1-objetivo","title":"1. Objetivo:","text":"<p>Desenvolver uma conjunto de fun\u00e7\u00f5es, para controlador o LCD HD44780 - Hitachi, de modo a reproduzir a seguinte simula\u00e7\u00e3o de teste:</p> Figura 1: Simula\u00e7\u00e3o de LCD acionado pelo Arduino Uno Fonte: Autor","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/#2-requisitos-da-solucao","title":"2. Requisitos da solu\u00e7\u00e3o","text":"<p>1) Interface</p> <p>Definicao de Comandos ao LCD<pre><code>#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n</code></pre> lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void );\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i );\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d );\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col);\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void );\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\n\n#endif\n</code></pre></p> <p>2) Comportamento</p> main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n\nvoid main(void) \n{\n    long t = 0;\n    lcd_init();\n    while( 1 )\n    {\n        switch( t )\n        {\n            case 0:         lcd_clr();                      break;\n            case 1000:      lcd(0,0,\"    HD44780    \");     break;\n            case 3000:      lcd(0,0,\" LCD 16x2 MMR  \");     break;\n            case 6000:      lcd(0,0,\"  IFSP Salto   \");     break;\n            case 20000:     t = 0;                          break;\n        }\n        _delay_ms(1);\n        ++t;\n    }\n}\n</code></pre> <p>3) Estrutra (Hardware): Circuito eletr\u00f4nico</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/#3-planejamento-da-solucao","title":"3. Planejamento da solu\u00e7\u00e3o","text":"<ol> <li>Planejamento do produto final</li> <li>Planejamento das ferramentas e materiais</li> <li>Planejamento do processo</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Basicas/sa05-displayLCD/#4-solucao","title":"4. Solu\u00e7\u00e3o","text":"<p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Intermediarias/01-ihm/","title":"01 - Interface Homem-M\u00e1quina","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Intermediarias/01-ihm/#interface-homem-maquina","title":"Interface Homem-M\u00e1quina","text":"<p>Uma IHM (Interface Homem-M\u00e1quina), tamb\u00e9m referida pelos termos em ingl\u00eas HCI (Human-Computer Interface) ou MMI (Man-Machine Interface), define a maneira como um sistema computacional interage com os seres humanos. Em sistemas embarcados, a IHM \u00e9 o componente que permite ao usu\u00e1rio monitorar o estado do dispositivo, fornecer comandos ou realizar a parametriza\u00e7\u00e3o de seu comportamento.</p> <p>Os principais conceitos e caracter\u00edsticas de uma IHM no contexto de sistemas embarcados incluem:</p> <ul> <li>Interfaces Dedicadas: Diferente dos computadores de uso geral, que utilizam teclados, mouses e grandes monitores, a maioria dos sistemas embarcados possui uma interface de usu\u00e1rio dedicada e simplificada. Isso pode incluir bot\u00f5es (push buttons), LEDs, volantes, pedais e chaves t\u00e1cteis.</li> <li>Componentes de Hardware: As IHMs podem variar conforme a complexidade da aplica\u00e7\u00e3o:<ul> <li>Simples: LEDs para sinaliza\u00e7\u00e3o visual e bot\u00f5es para entradas bin\u00e1rias.</li> <li>Alfanum\u00e9ricas e Num\u00e9ricas: Displays de sete segmentos e m\u00f3dulos LCD (16x2, 20x4) para exibi\u00e7\u00e3o de mensagens de texto e n\u00fameros.</li> <li>Avan\u00e7adas: Displays gr\u00e1ficos (GLCD), telas sens\u00edveis ao toque (touch screens), teclados matriciais e at\u00e9 interfaces de voz.</li> </ul> </li> <li>Computa\u00e7\u00e3o Ub\u00edqua: Muitas vezes, a IHM \u00e9 projetada para ser t\u00e3o integrada ao produto f\u00edsico que o usu\u00e1rio mal percebe que h\u00e1 processamento de informa\u00e7\u00f5es envolvido, um conceito conhecido como \"computador que desaparece\".</li> <li>Camada de Software: A intera\u00e7\u00e3o \u00e9 gerenciada por c\u00f3digos espec\u00edficos:<ul> <li>Drivers de Dispositivo: Fun\u00e7\u00f5es de baixo n\u00edvel que controlam diretamente o hardware da interface.</li> <li>GUI (Interface Gr\u00e1fica de Usu\u00e1rio): Em sistemas mais robustos que utilizam Sistemas Operacionais de Tempo Real (RTOS), pode haver suporte para elementos gr\u00e1ficos mais complexos, facilitando a usabilidade.</li> </ul> </li> </ul> <p>Em resumo, a IHM \u00e9 o elo de comunica\u00e7\u00e3o entre o firmware (a l\u00f3gica interna do sistema) e o operador humano, sendo essencial para que o sistema embarcado cumpra seu objetivo pr\u00e1tico de forma eficiente e segura.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/SituacoesAprendizagem/Intermediarias/01-ihm/#desafio","title":"Desafio","text":"<p>Elabore um programa que execute o comportamento conforme ilustra\u00e7\u00e3o da simula\u00e7\u00e3o que segue.</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig0-fundamentos/","title":"Sistemas Digitais","text":"<p>Um sistema digital pode ser definido como um conjunto de componentes eletr\u00f4nicos interconectados projetado para processar informa\u00e7\u00f5es sob uma forma discreta. Ao contr\u00e1rio dos sistemas anal\u00f3gicos, que lidam com fun\u00e7\u00f5es e sinais cont\u00ednuos, os sistemas digitais operam atrav\u00e9s de pulsos ou intervalos predeterminados, tratando um conjunto finito de valores. Essa estrutura l\u00f3gica \u00e9 baseada no sistema de numera\u00e7\u00e3o bin\u00e1rio, no qual as quantidades s\u00e3o representadas por bits (0 e 1) que simbolizam estados opostos. Fisicamente, esses estados l\u00f3gicos correspondem \u00e0 presen\u00e7a ou \u00e0 aus\u00eancia de tens\u00e3o el\u00e9trica em elementos espec\u00edficos do circuito.</p> <p>A implementa\u00e7\u00e3o desses sistemas baseia-se em elementos fundamentais: as portas l\u00f3gicas, que formam a l\u00f3gica combinacional, e os flip-flops, que constituem a base da l\u00f3gica sequencial. Enquanto na l\u00f3gica combinacional a sa\u00edda \u00e9 estritamente dependente das vari\u00e1veis de entrada atuais, a l\u00f3gica sequencial introduz a capacidade de mem\u00f3ria, onde o estado da sa\u00edda \u00e9 influenciado por estados anteriores e frequentemente sincronizado por pulsos de clock.</p> <p>A an\u00e1lise e o projeto de sistemas digitais modernos exigem diferentes n\u00edveis de abstra\u00e7\u00e3o, partindo do n\u00edvel elementar de transistores e resistores at\u00e9 blocos funcionais mais complexos, como registradores e processadores. Por fim, visto que a maioria das grandezas f\u00edsicas \u00e9 inerentemente anal\u00f3gica, esses sistemas frequentemente integram conversores anal\u00f3gico-digitais (A/D) e digital-anal\u00f3gicos (D/A) para permitir a interface e o processamento eficiente de informa\u00e7\u00f5es do mundo real.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig0-fundamentos/#referencias-e-complementos","title":"Refer\u00eancias e complementos","text":"<ul> <li>TOCCI, Ronald J.; WIDMER, Neal S. Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es. 8. ed. Pearson, 2015.</li> <li>PALANIAPPAN, Ramaswamy. Digital Systems Design. bookboon.com, 2011.</li> <li>TRINDADE JUNIOR, Rosumiro; JULI\u00c3O, Jodelson Moreira. Circuitos Digitais. Manaus: Centro de Educa\u00e7\u00e3o Tecnol\u00f3gica do Amazonas (CETAM), 2012.</li> <li>D\u2019AMORE, Roberto. VHDL: Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/","title":"Sistemas de Numera\u00e7\u00e3o","text":"<p>Sistemas de numera\u00e7\u00e3o s\u00e3o estruturas matem\u00e1ticas fundamentais compostas por um conjunto de s\u00edmbolos e regras que permitem a representa\u00e7\u00e3o e a atribui\u00e7\u00e3o de valores num\u00e9ricos a grandezas, objetos ou fen\u00f4menos do cotidiano. Historicamente, a depend\u00eancia humana de atribuir valores num\u00e9ricos aumentou em uma escala sem precedentes, sendo que, na eletr\u00f4nica moderna, o entendimento desses sistemas \u00e9 essencial para descrever como os circuitos processam informa\u00e7\u00f5es.</p> <p>Os sistemas de numera\u00e7\u00e3o possuem as seguintes caracter\u00edsticas principais:</p> <ul> <li>Natureza Posicional: O valor de um n\u00famero \u00e9 determinado pela combina\u00e7\u00e3o de d\u00edgitos, onde cada posi\u00e7\u00e3o possui um peso ou valor posicional baseado em pot\u00eancias da base (ou radix) do sistema. Por exemplo, no sistema decimal, as posi\u00e7\u00f5es representam unidades, dezenas, centenas (pot\u00eancias de 10), enquanto no bin\u00e1rio representam pot\u00eancias de 2.</li> </ul> Figura 1: Valor Posicional ou peso Fonte: Autor <ul> <li>Sistemas de Bases Diversas:<ul> <li>Decimal (Base 10): \u00c9 o sistema mais popular e universalmente utilizado, composto por dez caracteres (0 a 9).</li> <li>Bin\u00e1rio (Base 2): Utiliza apenas dois caracteres (0 e 1), denominados bits (binary digits), sendo a base fundamental para o processamento de informa\u00e7\u00f5es em dispositivos digitais.</li> <li>Octal (Base 8) e Hexadecimal (Base 16): S\u00e3o utilizados como formas compactas ou \"taquigr\u00e1ficas\" para representar grandes quantidades de bits, facilitando o trabalho em computadores digitais e a programa\u00e7\u00e3o de microcontroladores. O hexadecimal, especificamente, utiliza os d\u00edgitos de 0 a 9 e as letras de A a F para representar 16 valores.</li> </ul> </li> </ul> Figura 2: Sistema posicional e convers\u00e3o para a base decimal Fonte: Autor <ul> <li>Signific\u00e2ncia dos D\u00edgitos: Em qualquer representa\u00e7\u00e3o num\u00e9rica, o caractere mais \u00e0 esquerda \u00e9 chamado de d\u00edgito mais significativo (Most Significant Decimal - MSD ou Most Significant Bit - MSB), pois possui o maior peso, enquanto o caractere mais \u00e0 direita \u00e9 o d\u00edgito menos significativo (Least Significant Decimal - LSD ou Least Significant Bit - LSB).</li> <li>Convers\u00e3o e Interconectividade: No contexto de sistemas digitais, \u00e9 frequentemente necess\u00e1rio converter n\u00fameros entre essas bases, como transformar uma entrada anal\u00f3gica (decimal) em formato bin\u00e1rio para processamento e, posteriormente, reconvert\u00ea-la para apresenta\u00e7\u00e3o ao usu\u00e1rio.</li> </ul> <p>Em resumo, sistemas de numera\u00e7\u00e3o em n\u00edvel acad\u00eamico s\u00e3o compreendidos como linguagens matem\u00e1ticas que permitem a abstra\u00e7\u00e3o e manipula\u00e7\u00e3o de dados discretos, sendo a base bin\u00e1ria a \"mat\u00e9ria-prima\" da l\u00f3gica digital.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#codigos-ascii-bcd-e-gray","title":"C\u00f3digos ASCII, BCD e Gray","text":"<p>No \u00e2mbito dos sistemas digitais, c\u00f3digos s\u00e3o conjuntos de s\u00edmbolos e regras utilizados para representar informa\u00e7\u00f5es, sejam elas num\u00e9ricas, alfanum\u00e9ricas ou de controle, de maneira que circuitos eletr\u00f4nicos possam process\u00e1-las. Os c\u00f3digos ASCII, BCD e Gray possuem finalidades distintas na arquitetura de computadores e no design de circuitos l\u00f3gicos.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#codigo-ascii","title":"C\u00f3digo ASCII","text":"<p>O ASCII (American Standard Code for Information Interchange) \u00e9 um c\u00f3digo alfanum\u00e9rico universalmente adotado para a transfer\u00eancia de informa\u00e7\u00f5es entre computadores e dispositivos perif\u00e9ricos. </p> <ul> <li> <p>Estrutura: O padr\u00e3o original utiliza 7 bits para representar at\u00e9 128 caracteres, incluindo letras (mai\u00fasculas e min\u00fasculas), algarismos, sinais de pontua\u00e7\u00e3o e caracteres de controle.</p> </li> <li> <p>Expans\u00e3o: Existe o ASCII estendido, que utiliza 8 bits (um byte) para incluir mais 128 s\u00edmbolos, como caracteres acentuados e s\u00edmbolos matem\u00e1ticos.</p> </li> <li> <p>Aplica\u00e7\u00e3o Pr\u00e1tica: \u00c9 a base para o processamento de textos e comunica\u00e7\u00e3o de dados em sistemas computacionais.</p> </li> </ul> Figura 3: Tabela ASCII Fonte: Quais as principais diferen\u00e7as entre Unicode, UTF, ASCII, ANSI? - Stackoverflow","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#codigo-bcd","title":"C\u00f3digo BCD","text":"<p>O BCD (Binary Coded Decimal) \u00e9 um m\u00e9todo de codifica\u00e7\u00e3o onde cada d\u00edgito de um n\u00famero decimal \u00e9 representado individualmente pelo seu equivalente em bin\u00e1rio de 4 bits.</p> <ul> <li> <p>Funcionamento: Diferente do bin\u00e1rio puro, o BCD trata cada posi\u00e7\u00e3o decimal separadamente. Por exemplo, o n\u00famero decimal 137 em bin\u00e1rio puro \u00e9 <code>10001001</code>, mas em BCD \u00e9 representado como <code>0001 0011 0111</code>.</p> </li> <li> <p>Limita\u00e7\u00f5es: Como utiliza apenas os c\u00f3digos de 0000 (0) a 1001 (9), os seis agrupamentos restantes de 4 bits (1010 a 1111) s\u00e3o considerados proibidos ou ilegais; a presen\u00e7a de qualquer um deles indica erro no sistema.</p> </li> <li> <p>Vantagem: A principal facilidade reside na convers\u00e3o direta entre decimal e bin\u00e1rio para interfaces de visualiza\u00e7\u00e3o, como calculadoras e mostradores de sete segmentos.</p> </li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#codigo-gray","title":"C\u00f3digo Gray","text":"<p>O C\u00f3digo Gray \u00e9 um sistema de codifica\u00e7\u00e3o bin\u00e1ria cuja principal caracter\u00edstica \u00e9 a mudan\u00e7a de apenas um bit entre dois valores sucessivos.</p> <ul> <li> <p>Natureza: Ao contr\u00e1rio do sistema bin\u00e1rio convencional, o Gray \u00e9 um c\u00f3digo n\u00e3o ponderado, o que significa que as posi\u00e7\u00f5es dos bits n\u00e3o possuem pesos fixos (como 1, 2, 4, 8).</p> </li> <li> <p>Vantagens e Aplica\u00e7\u00f5es: Por variar apenas um bit por transi\u00e7\u00e3o, ele \u00e9 significativamente menos propenso a erros em sistemas de comunica\u00e7\u00e3o digital e em dispositivos de comuta\u00e7\u00e3o mec\u00e2nica. \u00c9 amplamente utilizado em encoders de posi\u00e7\u00e3o e na simplifica\u00e7\u00e3o de fun\u00e7\u00f5es sequenciais atrav\u00e9s de Mapas de Karnaugh.</p> </li> </ul> Figura 4: C\u00f3digo Gray Fonte: Applications of gray code <p>Em resumo, enquanto o ASCII foca na representa\u00e7\u00e3o de textos, o BCD facilita a interface com humanos atrav\u00e9s de n\u00fameros decimais, e o Gray otimiza a confiabilidade das transi\u00e7\u00f5es de estado em circuitos l\u00f3gicos.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#exercicios","title":"Exerc\u00edcios","text":"<p>1) Preencha a tabela realizando a devida convers\u00e3o conforme indicado nas colunas:</p> # Bin\u00e1rio Octal Decimal Hexadecimal 0 10101 25 21 15 1 101010 2 1010100 3 168 4 26 5 50 6 78 7 125 8 C3 9 4A <p>2) Converta as cadeias de caracteres (strings) em sequ\u00eancia de n\u00fameros hexadecimais correspondentes da tabela ASCII:</p> <p>Um n\u00famero hexadecimal 49 pode ser representado 0x49 ou 49h para evitar erros de interpreta\u00e7\u00e3o do n\u00famero.</p> # String Sequ\u00eancia num\u00e9rica hexadecimal Convers\u00e3o Mai\u00fasuclas -&gt; Min\u00fasculas 0 \"IFSP\" 49 46 53 50 69 66 73 70 1 \"OLA MUNDO\" 2 \"SALTO 2026\" 3 Seu nome <p>3) Converta os n\u00fameros decimais em BCD:</p> # Decimal BCD 0 42 0100 0010 1 379 2 6194 3 5800 4 918273 <p>4) Converta o c\u00f3digo Bin\u00e1rio convencional em c\u00f3digo Gray</p> # Bin\u00e1rio Gray 0 0000 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 15 1111","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig1-sistema_numeracao/#referencias-e-complementos","title":"Refer\u00eancias e complementos","text":"<ul> <li>TOCCI, Ronald J.; WIDMER, Neal S. Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es. 8. ed. Pearson, 2015.</li> <li>PALANIAPPAN, Ramaswamy. Digital Systems Design. bookboon.com, 2011.</li> <li>TRINDADE JUNIOR, Rosumiro; JULI\u00c3O, Jodelson Moreira. Circuitos Digitais. Manaus: Centro de Educa\u00e7\u00e3o Tecnol\u00f3gica do Amazonas (CETAM), 2012.</li> <li>D\u2019AMORE, Roberto. VHDL: Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig2-portas_logicas/","title":"Elementos l\u00f3gicos","text":"<p>Elementos l\u00f3gicos, ou ainda portas l\u00f3gicas, constituem os blocos fundamentais para a implementa\u00e7\u00e3o de circuitos e sistemas digitais. Esses elementos operam essencialmente sob os princ\u00edpios da l\u00f3gica bin\u00e1ria, o que significa que suas entradas e sa\u00eddas podem assumir apenas um de dois estados discretos: 0 ou 1. Em termos f\u00edsicos e el\u00e9tricos, o n\u00edvel l\u00f3gico 0 representa a aus\u00eancia de tens\u00e3o ou um estado de n\u00e3o-condu\u00e7\u00e3o, enquanto o n\u00edvel l\u00f3gico 1 representa a presen\u00e7a de tens\u00e3o ou condu\u00e7\u00e3o.</p> <p>As fun\u00e7\u00f5es l\u00f3gicas prim\u00e1rias que regem esses sistemas s\u00e3o AND (E), OR (OU) e NOT (N\u00c3O), sendo que todos os outros blocos l\u00f3gicos complexos s\u00e3o deriva\u00e7\u00f5es ou combina\u00e7\u00f5es dessas tr\u00eas fun\u00e7\u00f5es b\u00e1sicas. Cada porta executa uma opera\u00e7\u00e3o espec\u00edfica:</p> <ul> <li>AND (E): Produz uma sa\u00edda de n\u00edvel l\u00f3gico 1 apenas quando todas as suas entradas forem n\u00edvel l\u00f3gico 1.</li> </ul> <p></p> <ul> <li>OR (OU): Resulta em n\u00edvel l\u00f3gico alto se pelo menos uma de suas entradas apresentar n\u00edvel l\u00f3gico alto.</li> </ul> <p></p> <ul> <li>NOT (N\u00c3O): Tamb\u00e9m conhecida como inversora, esta porta complementa o estado l\u00f3gico da vari\u00e1vel de entrada, transformando 0 em 1 e vice-versa.</li> </ul> <p></p> <p>Al\u00e9m das fun\u00e7\u00f5es b\u00e1sicas, a eletr\u00f4nica digital utiliza portas derivadas, como a NAND (N\u00e3o-E), NOR (N\u00e3o-OU), XOR (OU-Exclusivo) e XNOR (Coincid\u00eancia). Portas como NAND e NOR s\u00e3o tecnicamente classificadas como <code>portas universais</code>, pois s\u00e3o capazes de, sozinhas ou em combina\u00e7\u00e3o, implementar a funcionalidade de qualquer outra porta l\u00f3gica ou circuito digital.</p> <p></p> <p></p> <p></p> <p></p> <p>Na pr\u00e1tica, esses elementos s\u00e3o fabricados sob a forma de circuitos integrados (CI), que utilizam tecnologias como TTL (L\u00f3gica Transistor-Transistor) ou CMOS (Semicondutor de \u00d3xido Met\u00e1lico Complementar) para agrupar m\u00faltiplas portas l\u00f3gicos em um \u00fanico dispositivo f\u00edsico. Quando essas portas s\u00e3o interconectadas, elas formam circuitos combinacionais, onde a sa\u00edda resultante \u00e9 uma fun\u00e7\u00e3o direta das vari\u00e1veis de entrada atuais, podendo ser descrita matematicamente atrav\u00e9s de express\u00f5es booleanas e tabelas-verdade.</p> Figura: Tecnologia de portas l\u00f3gicas com Diodos, Resistores e Transistores Fonte: Controle E Automa\u00e7\u00e3o Industrial III - Prof. Sin\u00e9sio Gomes - 2012 <p>A tecnologia CMOS (Complementary Metal-Oxide Semiconductor ou Semicondutor de \u00d3xido Met\u00e1lico Complementar) \u00e9 um dos pilares da eletr\u00f4nica digital moderna, sendo amplamente utilizada na fabrica\u00e7\u00e3o de circuitos integrados.</p> <p>A tecnologia CMOS baseia-se no uso de transistores MOS, que permitem a implementa\u00e7\u00e3o de fun\u00e7\u00f5es l\u00f3gicas complexas e estruturas espec\u00edficas, como as portas de passagem (transmission gates). Essas portas operam de maneira bidirecional, funcionando como chaves eletr\u00f4nicas que transmitem informa\u00e7\u00f5es de forma eficiente em circuitos de tecnologia MOS.</p> <p></p> <p>Embora o CMOS seja a tecnologia predominante em larga escala, ele apresenta caracter\u00edsticas distintas em rela\u00e7\u00e3o ao seu principal concorrente hist\u00f3rico, o TTL (Transistor-Transistor Logic):</p> <ul> <li> <p>Ru\u00eddo Eletrost\u00e1tico: Dispositivos CMOS tendem a ser menos robustos ao ru\u00eddo eletrost\u00e1tico do que os dispositivos TTL, motivo pelo qual estes \u00faltimos ainda s\u00e3o muito comuns em ambientes educacionais e laboratoriais.</p> </li> <li> <p>Margem de Ru\u00eddo: O projeto de CIs digitais busca reduzir a interfer\u00eancia de ru\u00eddo, e a diferen\u00e7a entre as faixas de tens\u00e3o de entrada e sa\u00edda (margem de ru\u00eddo) \u00e9 um par\u00e2metro cr\u00edtico que a tecnologia CMOS gerencia para garantir a integridade do sinal l\u00f3gico.</p> </li> </ul> <p>Para que um circuito CMOS opere de forma confi\u00e1vel, ele deve respeitar par\u00e2metros rigorosos de temporiza\u00e7\u00e3o, que variam conforme a subfam\u00edlia:</p> <ul> <li>Tempo de Setup (\\(t_s\\)): O intervalo m\u00ednimo que o dado deve estar est\u00e1vel antes da transi\u00e7\u00e3o do clock.</li> <li>Tempo de Hold (\\(t_H\\)): O intervalo que o dado deve permanecer est\u00e1vel ap\u00f3s a transi\u00e7\u00e3o do clock.</li> <li>Frequ\u00eancia M\u00e1xima (\\(f_{MAX}\\)): A maior frequ\u00eancia de clock que pode ser aplicada mantendo o disparo confi\u00e1vel, variando de 5 MHz (em s\u00e9ries como 74C) at\u00e9 patamares superiores em s\u00e9ries de alta velocidade.</li> </ul> <p>A tecnologia CMOS \u00e9 fundamental para a implementa\u00e7\u00e3o de unidades de mem\u00f3ria RAM e ROM. Em dispositivos l\u00f3gicos program\u00e1veis (como FPGAs), a exist\u00eancia de unidades de mem\u00f3ria CMOS integradas permite economizar recursos de l\u00f3gica combinacional e registradores, otimizando o custo e a \u00e1rea do chip. Al\u00e9m disso, o CMOS \u00e9 essencial para o modelamento de estados de alta imped\u00e2ncia (estado Z), facilitando a cria\u00e7\u00e3o de barramentos de comunica\u00e7\u00e3o onde m\u00faltiplos controladores compartilham o mesmo n\u00f3.</p> <p></p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig2-portas_logicas/#referencias-e-complementos","title":"Refer\u00eancias e complementos","text":"<ul> <li>TOCCI, Ronald J.; WIDMER, Neal S. Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es. 8. ed. Pearson, 2015.</li> <li>PALANIAPPAN, Ramaswamy. Digital Systems Design. bookboon.com, 2011.</li> <li>TRINDADE JUNIOR, Rosumiro; JULI\u00c3O, Jodelson Moreira. Circuitos Digitais. Manaus: Centro de Educa\u00e7\u00e3o Tecnol\u00f3gica do Amazonas (CETAM), 2012.</li> <li>D\u2019AMORE, Roberto. VHDL: Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/","title":"Express\u00f5es L\u00f3gicas","text":"<p>Express\u00f5es l\u00f3gicas, tamb\u00e9m denominadas express\u00f5es booleanas, consistem na representa\u00e7\u00e3o alg\u00e9brica do comportamento de circuitos e sistemas digitais, estabelecendo uma rela\u00e7\u00e3o matem\u00e1tica entre vari\u00e1veis de entrada e uma sa\u00edda resultante. Elas fundamentam-se na \u00c1lgebra de Boole, desenvolvida por George Boole no s\u00e9culo XIX, que utiliza postulados e opera\u00e7\u00f5es simples para resolver problemas pr\u00e1ticos de controle atrav\u00e9s de estados bin\u00e1rios: 0 (aus\u00eancia de tens\u00e3o ou n\u00e3o-condu\u00e7\u00e3o) e 1 (presen\u00e7a de tens\u00e3o ou condu\u00e7\u00e3o).</p> <p>As fun\u00e7\u00f5es l\u00f3gicas prim\u00e1rias que comp\u00f5em essas express\u00f5es s\u00e3o AND (conjun\u00e7\u00e3o), OR (disjun\u00e7\u00e3o) e NOT (nega\u00e7\u00e3o ou invers\u00e3o), a partir das quais derivam-se blocos mais complexos como NAND, NOR, XOR (OU-Exclusivo) e XNOR (Coincid\u00eancia). Na nota\u00e7\u00e3o alg\u00e9brica usual, a opera\u00e7\u00e3o AND \u00e9 representada por um ponto (\\(A \\cdot B\\)) ou pela justaposi\u00e7\u00e3o das vari\u00e1veis (\\(AB\\)), enquanto a opera\u00e7\u00e3o OR \u00e9 representada pelo sinal de adi\u00e7\u00e3o (\\(A + B\\)).</p> <p>No \u00e2mbito do projeto de sistemas, a interconex\u00e3o de portas l\u00f3gicas forma circuitos combinacionais, cuja sa\u00edda \u00e9 descrita por uma express\u00e3o booleana que depende exclusivamente das vari\u00e1veis de entrada atuais. A an\u00e1lise dessas express\u00f5es pode ser feita atrav\u00e9s de tabelas-verdade, que listam todas as combina\u00e7\u00f5es poss\u00edveis de entrada e seus respectivos resultados. Al\u00e9m disso, express\u00f5es l\u00f3gicas podem ser estruturadas em formatos espec\u00edficos como a Soma de Produtos , onde termos de produto s\u00e3o unidos por portas OR, ou o Produto de Somas, onde termos de soma s\u00e3o unidos por portas AND.</p> <p>\u00c9 fundamental compreender que essas express\u00f5es podem ser otimizadas utilizando leis e teoremas booleanos, como as Leis de De Morgan, visando reduzir a complexidade do hardware e os atrasos de propaga\u00e7\u00e3o. Em linguagens de descri\u00e7\u00e3o de hardware como VHDL, as express\u00f5es l\u00f3gicas seguem regras estritas de preced\u00eancia de operadores \u2014 onde o NOT possui a maior preced\u00eancia e o AND precede o OR \u2014 sendo o uso de par\u00eanteses essencial para garantir a ordem correta de avalia\u00e7\u00e3o e evitar ambiguidades.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#mintermos-e-maxtermos","title":"Mintermos e Maxtermos","text":"<p>No contexto da l\u00f3gica booleana e do projeto de sistemas digitais, mintermos e maxtermos representam as formas can\u00f4nicas de descrever matematicamente uma fun\u00e7\u00e3o a partir de uma tabela-verdade.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#mintermos-soma-de-produtos","title":"Mintermos (Soma de Produtos)","text":"<p>Um mintermo \u00e9 um termo de produto (opera\u00e7\u00e3o l\u00f3gica AND) que assume o valor l\u00f3gico 1 para uma \u00fanica combina\u00e7\u00e3o espec\u00edfica das vari\u00e1veis de entrada. Na an\u00e1lise de circuitos combinacionais, os mintermos s\u00e3o utilizados no m\u00e9todo da Soma de Produtos, onde se identificam todas as linhas da tabela-verdade cujo resultado da sa\u00edda \u00e9 1. Para a constru\u00e7\u00e3o de um mintermo, segue-se a regra de que vari\u00e1veis com valor 0 aparecem na forma complementada (barrada) e vari\u00e1veis com valor 1 aparecem na forma n\u00e3o complementada. Ao realizar a disjun\u00e7\u00e3o (opera\u00e7\u00e3o OR) de todos os mintermos que resultam em sa\u00edda alta, obt\u00e9m-se a express\u00e3o l\u00f3gica completa do sistema.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#maxtermos-produto-de-somas","title":"Maxtermos (Produto de Somas)","text":"<p>Em contrapartida, um maxtermo \u00e9 um termo de soma (opera\u00e7\u00e3o l\u00f3gica OR) que produz o valor l\u00f3gico 0 para uma combina\u00e7\u00e3o exclusiva das vari\u00e1veis de entrada. O uso de maxtermos fundamenta o m\u00e9todo de Produto de Somas, que \u00e9 menos frequente em sistemas digitais, mas igualmente v\u00e1lido do ponto de vista alg\u00e9brico. Na conven\u00e7\u00e3o de maxtermos, a l\u00f3gica \u00e9 invertida em rela\u00e7\u00e3o aos mintermos: a vari\u00e1vel assume a forma n\u00e3o complementada se seu valor for 0 e a forma complementada se seu valor for 1, visando for\u00e7ar o resultado do termo de soma para 0. A fun\u00e7\u00e3o completa \u00e9 obtida atrav\u00e9s da conjun\u00e7\u00e3o (opera\u00e7\u00e3o AND) de todos os maxtermos que representam as sa\u00eddas 0 da tabela-verdade.</p> <p>A distin\u00e7\u00e3o entre esses conceitos \u00e9 vital para a otimiza\u00e7\u00e3o de hardware, pois:</p> <ul> <li> <p>Minimiza\u00e7\u00e3o: Ambas as representa\u00e7\u00f5es podem ser simplificadas utilizando as leis da \u00c1lgebra de Boole ou o Mapa de Karnaugh para reduzir a complexidade do circuito e os atrasos de propaga\u00e7\u00e3o.</p> </li> <li> <p>Dualidade: Atrav\u00e9s do Teorema de De Morgan, \u00e9 poss\u00edvel demonstrar que uma express\u00e3o em Soma de Produtos (mintermos) \u00e9 logicamente equivalente ao complemento de uma express\u00e3o em Produto de Somas (maxtermos).</p> </li> <li> <p>Don't Care: Em projetos avan\u00e7ados, condi\u00e7\u00f5es de \"n\u00e3o importa\" (don't care) podem ser tratadas como 0 ou 1 para simplificar ainda mais os agrupamentos de mintermos ou maxtermos em um diagrama de Veitch-Karnaugh.</p> </li> </ul> <p>Na an\u00e1lise e s\u00edntese de sistemas digitais, a compreens\u00e3o da hierarquia de preced\u00eancia e das opera\u00e7\u00f5es l\u00f3gicas \u00e9 fundamental para evitar ambiguidades no comportamento dos circuitos e garantir a infer\u00eancia correta de hardware. As express\u00f5es l\u00f3gicas fundamentam-se na \u00c1lgebra de Boole, que utiliza estados bin\u00e1rios (0 e 1) para resolver problemas de controle e processamento de informa\u00e7\u00e3o.</p> <p>Abaixo, detalham-se a tabela de preced\u00eancia e as principais opera\u00e7\u00f5es l\u00f3gicas booleanas.</p> <p>Tabela de Preced\u00eancia de Operadores</p> <p>A hierarquia de preced\u00eancia define a ordem em que os operadores s\u00e3o avaliados em uma express\u00e3o. No contexto de linguagens de descri\u00e7\u00e3o de hardware (como VHDL), a ordem de preced\u00eancia, da maior para a menor, \u00e9 organizada em classes:</p> Preced\u00eancia Classe de Operadores Operadores Maior Diversos <code>**</code>, <code>abs</code>, <code>not</code> Multiplica\u00e7\u00e3o <code>*</code>, <code>/</code>, <code>mod</code>, <code>rem</code> Sinal <code>+</code>, <code>-</code> Adi\u00e7\u00e3o <code>+</code>, <code>-</code>, <code>&amp;</code> (concatena\u00e7\u00e3o) Deslocamento <code>sll</code>, <code>srl</code>, <code>sla</code>, <code>sra</code>, <code>rol</code>, <code>ror</code> Relacionais <code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Menor L\u00f3gicos <code>and</code>, <code>or</code>, <code>nand</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code> <p>Nota importante sobre ambiguidade: Na \u00c1lgebra de Boole cl\u00e1ssica, a opera\u00e7\u00e3o AND geralmente tem preced\u00eancia sobre a OR. No entanto, em linguagens como VHDL, todos os operadores l\u00f3gicos (exceto o <code>not</code>) possuem o mesmo n\u00edvel de preced\u00eancia, tornando o uso de par\u00eanteses essencial para definir a ordem desejada e evitar erros de compila\u00e7\u00e3o.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#axiomas-e-teoremas","title":"Axiomas e Teoremas","text":"<p>Para a simplifica\u00e7\u00e3o de express\u00f5es, as fontes destacam postulados fundamentais:</p> <ul> <li> <p>Identidade: </p> <ul> <li>\\(A + 0 = A\\)</li> <li>\\(A \\cdot 1 = A\\)</li> </ul> </li> <li> <p>Nulo (Absorvente): </p> <ul> <li>\\(A + 1 = 1\\)</li> <li>\\(A \\cdot 0 = 0\\)</li> </ul> </li> <li> <p>Idempot\u00eancia: </p> <ul> <li>\\(A + A = A\\)</li> <li>\\(A \\cdot A = A\\)</li> </ul> </li> <li> <p>Complementaridade: </p> <ul> <li>\\(A + \\overline{A} = 1\\)</li> <li>\\(A \\cdot \\overline{A} = 0\\)</li> </ul> </li> <li> <p>Involu\u00e7\u00e3o (Dupla Nega\u00e7\u00e3o): </p> <ul> <li>\\(\\overline{\\overline{A}} = A\\)</li> </ul> </li> </ul> <p>A \u00e1lgebra de Boole, formalizada pelo matem\u00e1tico ingl\u00eas George Boole em meados do s\u00e9culo XIX, constitui a base te\u00f3rica essencial para o desenvolvimento e a simplifica\u00e7\u00e3o de sistemas e circuitos l\u00f3gicos digitais. Esta estrutura alg\u00e9brica permite solucionar problemas pr\u00e1ticos de controle atrav\u00e9s de opera\u00e7\u00f5es sobre vari\u00e1veis que assumem apenas dois estados discretos: 0 (falso ou aus\u00eancia de tens\u00e3o) e 1 (verdadeiro ou condu\u00e7\u00e3o).</p> <p>Abaixo est\u00e3o detalhados os postulados, leis e teoremas fundamentais conforme a literatura t\u00e9cnica:</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#propriedades-e-leis-algebricas","title":"Propriedades e Leis Alg\u00e9bricas","text":"<p>Essas leis regem a manipula\u00e7\u00e3o de express\u00f5es complexas e seguem princ\u00edpios similares \u00e0 \u00e1lgebra convencional, com exce\u00e7\u00f5es espec\u00edficas.</p> <ul> <li> <p>Comutativa: A ordem das vari\u00e1veis n\u00e3o altera o resultado da opera\u00e7\u00e3o</p> <ul> <li>\\(A + B = B + A\\)</li> <li>\\(A \\cdot B = B \\cdot A\\)</li> </ul> </li> <li> <p>Associativa: O agrupamento de termos em somas ou produtos n\u00e3o altera o resultado final </p> <ul> <li>\\(A + (B + C) = (A + B) + C\\)</li> <li>\\(A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C\\)</li> </ul> </li> <li> <p>Distributiva: Permite a expans\u00e3o ou fatora\u00e7\u00e3o de termos </p> <ul> <li>\\(A \\cdot (B + C) = (A \\cdot B) + (A \\cdot C)\\)</li> <li>\\((A \\cdot B) + C = (A + C) \\cdot (B + C)\\)</li> </ul> </li> <li> <p>Absor\u00e7\u00e3o: Termos redundantes s\u00e3o eliminados pela vari\u00e1vel dominante </p> <ul> <li>\\(A + A \\cdot B = A\\)</li> <li>\\(A \\cdot (A + B) = A\\)</li> </ul> </li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#teoremas-de-de-morgan","title":"Teoremas de De Morgan","text":"<p>Augustus De Morgan estabeleceu dois teoremas vitais que permitem a convers\u00e3o entre operadores e a simplifica\u00e7\u00e3o de barras de invers\u00e3o sobre express\u00f5es complexas.</p> <ul> <li> <p>Primeira Lei: O complemento do produto de vari\u00e1veis \u00e9 igual \u00e0 soma dos complementos individuais </p> <ul> <li>\\(\\overline{A \\cdot B} = \\overline{A} + \\overline{B}\\)</li> </ul> </li> <li> <p>Segunda Lei: O complemento da soma de vari\u00e1veis \u00e9 igual ao produto dos complementos individuais </p> <ul> <li>\\(\\overline{A + B} = \\overline{A} \\cdot \\overline{B}\\)</li> </ul> </li> </ul> <p>Princ\u00edpio da Dualidade</p> <p>Toda express\u00e3o booleana permanece v\u00e1lida se os operadores AND e OR forem trocados entre si, simultaneamente com a troca dos valores l\u00f3gicos 0 e 1. Este princ\u00edpio \u00e9 fundamental para a s\u00edntese de hardware, permitindo, por exemplo, a implementa\u00e7\u00e3o de uma porta AND utilizando uma porta OR com entradas e sa\u00eddas invertidas.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#exercicios","title":"Exerc\u00edcios","text":"","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#1-simplificacao-de-expressoes-booleanas","title":"1. Simplifica\u00e7\u00e3o de Express\u00f5es Booleanas","text":"<p>Simplifique as seguintes express\u00f5es alg\u00e9bricas visando a redu\u00e7\u00e3o do n\u00famero de termos ou vari\u00e1veis:</p> <ol> <li>\\(S = A \\bar{B} C + A \\bar{B} \\bar{C}\\)</li> <li>\\(S = \\bar{A} B \\bar{C} + A \\bar{B} \\bar{C} + \\bar{A} \\bar{B} \\bar{C}\\)</li> <li>\\(S = ABC + A\\bar{C} + A\\bar{B}\\)</li> <li>\\(S = \\bar{A}B + A\\bar{B} + AB\\)</li> <li>\\(S = A \\bar{B} C + A \\bar{B} \\bar{C} + \\bar{A} B C\\)</li> <li>\\(Y = A B C D + A B \\bar{C} D + A B C \\bar{D}\\)</li> <li>\\(Y = A \\bar{B} C + \\bar{A} \\bar{B} C\\)</li> <li>\\(F = A \\bar{B} \\bar{C} + \\bar{A} B \\bar{C} + A B \\bar{C}\\)</li> <li>\\(F = A\\bar{B}(B+C)\\)</li> </ol>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#2-aplicacao-dos-teoremas-de-de-morgan","title":"2. Aplica\u00e7\u00e3o dos Teoremas de De Morgan","text":"<p>Utilize as leis de De Morgan para simplificar ou transformar as express\u00f5es abaixo, eliminando as barras de nega\u00e7\u00e3o sobre m\u00faltiplos termos:</p> <ol> <li>\\(F = \\overline{A + B + \\bar{C}}\\)</li> <li>\\(F = \\overline{\\overline{ABC} + D}\\)</li> <li>\\(F = \\overline{A + (B + C)\\bar{D}}\\)</li> <li>\\(F = \\overline{\\overline{A + B} + \\bar{A}B}\\)</li> <li>\\(F = \\overline{A + B + C + \\bar{A}\\bar{B} + \\bar{B}C}\\)</li> <li>\\(F = \\overline{\\bar{A}B} + ABC\\)</li> </ol>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#3-provas-algebricas-e-teoricas","title":"3. Provas Alg\u00e9bricas e Te\u00f3ricas","text":"<p>Demonstre a validade das igualdades ou situa\u00e7\u00f5es l\u00f3gicas utilizando os axiomas da \u00e1lgebra booleana:</p> <p>Prove a seguinte igualdade: \\((A + B)(A + C) = A + BC\\) (Dica: utilize a propriedade distributiva e o postulado de que \\(A+1=1\\)).</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig3-expressoes_logicas_circuitos/#referencias-e-complementos","title":"Refer\u00eancias e complementos","text":"<ul> <li>TOCCI, Ronald J.; WIDMER, Neal S. Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es. 8. ed. Pearson, 2015.</li> <li>PALANIAPPAN, Ramaswamy. Digital Systems Design. bookboon.com, 2011.</li> <li>TRINDADE JUNIOR, Rosumiro; JULI\u00c3O, Jodelson Moreira. Circuitos Digitais. Manaus: Centro de Educa\u00e7\u00e3o Tecnol\u00f3gica do Amazonas (CETAM), 2012.</li> <li>D\u2019AMORE, Roberto. VHDL: Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Portas L\u00f3gicas","Express\u00f5es L\u00f3gicas","Circuitos"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/","title":"0100 - Mapa de Karnaugh","text":"","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#mapa-de-karnaugh","title":"Mapa de Karnaugh","text":"<p>O Mapa de Karnaugh (ou Mapa K) simplifica express\u00f5es de mintermos \u2014 representadas na forma de Soma de Produtos (SOP) \u2014 atrav\u00e9s de um m\u00e9todo gr\u00e1fico que identifica padr\u00f5es de adjac\u00eancia l\u00f3gica para eliminar vari\u00e1veis redundantes. Enquanto a simplifica\u00e7\u00e3o por \u00e1lgebra booleana exige manipula\u00e7\u00f5es matem\u00e1ticas complexas, o Mapa K permite visualizar essas redu\u00e7\u00f5es diretamente da tabela-verdade.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#1-organizacao-por-adjacencia-logica-codigo-gray","title":"1. Organiza\u00e7\u00e3o por Adjac\u00eancia L\u00f3gica (C\u00f3digo Gray)","text":"<p>O mapa \u00e9 constru\u00eddo de forma que as c\u00e9lulas adjacentes (horizontal ou verticalmente) difiram por apenas um bit em suas vari\u00e1veis de entrada. Essa organiza\u00e7\u00e3o segue o C\u00f3digo Gray, garantindo que, ao mover-se de uma c\u00e9lula para a vizinha, apenas o estado de uma vari\u00e1vel mude (de 0 para 1 ou vice-versa).</p> <p></p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#2-agrupamento-de-mintermos-looping","title":"2. Agrupamento de Mintermos (Looping)","text":"<p>O processo de simplifica\u00e7\u00e3o baseia-se em identificar regi\u00f5es onde a sa\u00edda assume o valor l\u00f3gico 1 e agrup\u00e1-los em la\u00e7os (loops). As regras fundamentais para esses agrupamentos s\u00e3o:</p> <ul> <li>Tamanho dos Grupos: Os grupos devem conter obrigatoriamente pot\u00eancias de 2 (1, 2, 4, 8 ou 16 elementos).</li> <li>Maximiza\u00e7\u00e3o: Os la\u00e7os devem ser o maior poss\u00edvel para garantir a m\u00e1xima simplifica\u00e7\u00e3o; quanto maior o la\u00e7o, mais vari\u00e1veis s\u00e3o eliminadas.</li> <li>Flexibilidade: Os la\u00e7os podem se sobrepor e tamb\u00e9m podem \"dar a volta\" pelas bordas do mapa (adjac\u00eancia circular).</li> </ul> <p></p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#3-eliminacao-de-variaveis","title":"3. Elimina\u00e7\u00e3o de Vari\u00e1veis","text":"<p>A simplifica\u00e7\u00e3o ocorre quando uma vari\u00e1vel aparece dentro de um mesmo la\u00e7o tanto em sua forma complementada (0) quanto n\u00e3o complementada (1). Como essas formas se anulam logicamente (\\(A + \\bar{A} = 1\\)), a vari\u00e1vel \"desaparece\" da express\u00e3o resultante.</p> <p>O impacto da simplifica\u00e7\u00e3o depende do n\u00famero de elementos no grupo:</p> <ul> <li>Par (2 c\u00e9lulas): Elimina 1 vari\u00e1vel da express\u00e3o do mintermo.</li> <li>Quadra (4 c\u00e9lulas): Elimina 2 vari\u00e1veis.</li> <li>Oitava (8 c\u00e9lulas): Elimina 3 vari\u00e1veis.</li> </ul> <p></p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#4-construcao-da-expressao-simplificada","title":"4. Constru\u00e7\u00e3o da Express\u00e3o Simplificada","text":"<p>Ap\u00f3s realizar todos os agrupamentos necess\u00e1rios para cobrir todos os 1s do mapa, a fun\u00e7\u00e3o final simplificada \u00e9 obtida atrav\u00e9s da disjun\u00e7\u00e3o (opera\u00e7\u00e3o OR) dos termos resultantes de cada la\u00e7o. Se houver condi\u00e7\u00f5es de \"n\u00e3o importa\" (don't care), representadas por \"X\", elas podem ser tratadas como 1 para aumentar o tamanho dos la\u00e7os e simplificar ainda mais a express\u00e3o, ou como 0 se n\u00e3o ajudarem no agrupamento.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#5-casos-irrelevantes","title":"5. Casos Irrelevantes","text":"<p>As condi\u00e7\u00f5es \"don't care\" (frequentemente denominadas como condi\u00e7\u00f5es de \"n\u00e3o importa\" ou \"casos irrelevantes\") referem-se a combina\u00e7\u00f5es de vari\u00e1veis de entrada que nunca ocorrer\u00e3o em um projeto espec\u00edfico ou cujos resultados de sa\u00edda n\u00e3o interferem no funcionamento do sistema,. Nos Mapas de Karnaugh (Mapa K) e nas tabelas-verdade, esses estados s\u00e3o representados graficamente pelo s\u00edmbolo \"X\" ou por um h\u00edfen \"-\".</p> <p>A utiliza\u00e7\u00e3o dessas condi\u00e7\u00f5es no Mapa de Karnaugh segue crit\u00e9rios t\u00e9cnicos de otimiza\u00e7\u00e3o de hardware:</p> <ul> <li>Flexibilidade no Agrupamento: Durante o processo de simplifica\u00e7\u00e3o gr\u00e1fica, o projetista pode tratar cada \"X\" individualmente como n\u00edvel l\u00f3gico 1 ou 0, dependendo do que for mais vantajoso para a redu\u00e7\u00e3o do circuito.</li> <li>Maximiza\u00e7\u00e3o dos La\u00e7os (Looping): Para obter a express\u00e3o booleana mais simples, deve-se considerar o \"X\" como valor 1 sempre que ele permitir a forma\u00e7\u00e3o de grupos maiores \u2014 como quadras (4 c\u00e9lulas) ou oitavas (8 c\u00e9lulas) \u2014 j\u00e1 que grupos maiores eliminam um n\u00famero maior de vari\u00e1veis redundantes.</li> <li>Tratamento como N\u00edvel Zero: Se uma condi\u00e7\u00e3o \"don't care\" n\u00e3o auxiliar na expans\u00e3o de um la\u00e7o ou na cobertura de uma sa\u00edda 1 que precise ser agrupada, ela deve ser tratada como 0 e, consequentemente, ignorada nas associa\u00e7\u00f5es.</li> <li>Simplifica\u00e7\u00e3o de Express\u00f5es: O uso estrat\u00e9gico de \"X\" permite que fun\u00e7\u00f5es complexas sejam reduzidas a formas can\u00f4nicas muito mais simples, minimizando o n\u00famero de portas l\u00f3gicas e os atrasos de propaga\u00e7\u00e3o no circuito final.</li> </ul> <p>Essa t\u00e9cnica \u00e9 amplamente aplicada em componentes onde certas combina\u00e7\u00f5es bin\u00e1rias s\u00e3o descartadas, como em decodificadores de BCD para sete segmentos ou em codificadores de prioridade, permitindo que a l\u00f3gica resultante seja mais econ\u00f4mica em termos de \u00e1rea de sil\u00edcio e consumo de recursos.</p>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/eletronicaDigital/sdig4-mapa_de_karnaugh/#referencias-e-complementos","title":"Refer\u00eancias e complementos","text":"<ul> <li>TOCCI, Ronald J.; WIDMER, Neal S. Sistemas Digitais: Princ\u00edpios e Aplica\u00e7\u00f5es. 8. ed. Pearson, 2015.</li> <li>PALANIAPPAN, Ramaswamy. Digital Systems Design. bookboon.com, 2011.</li> <li>TRINDADE JUNIOR, Rosumiro; JULI\u00c3O, Jodelson Moreira. Circuitos Digitais. Manaus: Centro de Educa\u00e7\u00e3o Tecnol\u00f3gica do Amazonas (CETAM), 2012.</li> <li>D\u2019AMORE, Roberto. VHDL: Descri\u00e7\u00e3o e S\u00edntese de Circuitos Digitais. LTC.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital","Express\u00f5es L\u00f3gicas","Simplifica\u00e7\u00e3o","Mapa de Karnaugh"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t01-intro_plds/","title":"Introdu\u00e7\u00e3o aos Dispositivos L\u00f3gicos Program\u00e1veis","text":"<p>O universo dos dispositivos digitais podem ser resumidos na Figura 1, desde dispositivos simples, como portas l\u00f3gicas b\u00e1sicas implementados em circuitos integrados, que possuem comportamento muito espec\u00edfico, e geralmente bem simples, em que s\u00e3o usados para compor um circuito mais complexo atrav\u00e9s de associa\u00e7\u00f5es que dependem da aplica\u00e7\u00e3o.</p> <p>Seguindo pelo Circuitos Integrados de Aplica\u00e7\u00e3o Espec\u00edficas (Application-Specific Integrated Circuit - ASICs), em que o arranjo de circuito complexos s\u00e3o implementados em um \u00fanico componente, gerelmente feito por encomenda.</p> <p>Na sequ\u00eancia temos os microprocessadores (microprocessor) e microcontroladores (microcontroller), em que um circuito dedicado orquestra o acionamento e processamento de sinais baseados em uma sequencia de c\u00f3digos gravados em mem\u00f3ria. O comportamento que estes circuitos apresentam, dependem do c\u00f3digo que eles executam, e possuem razo\u00e1vel flexibilidade, por\u00e9m, os circuitos internos que respons\u00e1veis por essa execu\u00e7\u00e3o \u00e9 est\u00e1tico.</p> <p>J\u00e1 os disposivos l\u00f3gicos program\u00e1veis (Programmable Logic Devices - PLDs) possuem a capacidade de serem programados em sua totalidade de comportamento, possibilitando a reconfigura\u00e7\u00e3o completa do circuito e por consequencia de seu comportamento. Tornando eles assim, os mais gen\u00e9ricos, pois \u00e9 poss\u00edvel sintetizar em um PLD, inclusive, o circuito de um microcontrolador ou processador, a depender do seu grau de integra\u00e7\u00e3o, ou seja, da quantidade de c\u00e9lulas que ele disp\u00f5e para ser programado.</p> Figura 1: Tecnologias digitais Fonte: autor <p>Os circuitos integrados, a depender da quantidade de dispositivos l\u00f3gicos implementados, como transistores, s\u00e3o classificados pelo grau de integra\u00e7\u00e3o, como ilustrado na tabela que segue:</p> Grau de Integra\u00e7\u00e3o Caracter\u00edstica SSI (Small Scale Integration) Dezenas de dispositivos MSI (Medium Scale Integration) Centenas de dispositivos LSI (Large Scale Integration) Dezenas de milhares de dispositivos VLSI (Very Large Scale Integration) Milh\u00f5es de dispositivos ULSI (Ultra Large Scale Integration) Utiliza Nanotecnologia <p>Portanto, os primeiros circuitos integrados possuiam grau de integra\u00e7\u00e3o pequeno (SSI), j\u00e1 os processadores modernos, s\u00e3o classificados como ULSI, bem como os PLDs.</p> <p>Dispositivos L\u00f3gicos Program\u00e1veis (PLDs)</p> <p>Os dispositivos l\u00f3gicos program\u00e1veis (PLDs) surgem da necessidade de criar circuitos integrados flex\u00edveis, que possuem a capacidade de implementar fun\u00e7\u00f5es l\u00f3gicas sem a necessidade de mudar o hardware, neste caso, numa escala de circuito integrado. Assim, circuitos de l\u00f3gica combinacional puderam ser programados a partir da d\u00e9cada de 1970.</p> <p>O PLD \u00e9 portanto, um circuito integrado configurado para atender \u00e0 diversas especifica\u00e7\u00f5es. Para isso, possui um grande n\u00famero de portas l\u00f3gicas e unidades de mem\u00f3ria interconectadas em um \u00fanico circuito integrado.</p> <p>A maioria das conex\u00f5es \u00e9 feita atrav\u00e9s de elos, do tipo fus\u00edveis, que podem ser \"queimados\" ou n\u00e3o, a depender da fun\u00e7\u00e3o l\u00f3gica que est\u00e1 sendo implementada e da forma de programa\u00e7\u00e3o do PLD.</p> Figura 2: Diagrama de uma c\u00e9lula de um PLD <p>O processo de \"queima\" pode ser feito pelo fabricante, de acordo com as especifica\u00e7\u00f5es do cliente, ou pelo pr\u00f3prio usu\u00e1rio, por meio de equipamentos programadores.</p> <p>Os primeiros PLDs foram desenvolvidos para construir apenas circuitos combinacionais, chamados de PAL (programmable array logic) e PLA (programmable logic array).</p> <p>Logo surgiu a necessidade de construir circuitos sequenciais e ent\u00e3o foi criada a estrutura GAL (generic array logic), que continha flip-flop, portas logicas e multiplexadores.</p> <p>Essas estruturas at\u00e9 aqui foram denominadas de SPLD (simple PLDs), que utilizam tecnologia CMOS e disponibilizam elementos de mem\u00f3ria do tipo EPROM, EEPROM e FLASH.</p> <p>Com a evolu\u00e7\u00e3o foram criados os CPLDs (Complex PLDs) e os FPGAs (Field Programmable Gate Array).</p> <p>Simbologia dos PLDs</p> <p>Foi adotada uma simbologia simplificada para representar os circuitos internos dos PLDs, conforme ilustrado na Figura 3.</p> Figura 3: Diagrama de uma c\u00e9lula de um PLD <p>Exemplo: Simbologia utilizada para uma porta AND de 4 entradas.</p> <ul> <li>Observe que, nas sa\u00eddas dos buffers, est\u00e3o representadas uma sa\u00edda inversora e uma n\u00e3o inversora;</li> <li>Uma \u00fanica linha aparece como entrada da porta AND, representando as 4 entradas existentes;</li> <li>As conex\u00f5es das vari\u00e1veis de entrada \u00e0 porta AND s\u00e3o indicadas por um ponto ou por um X.</li> <li>O X representa um fus\u00edvel intacto, e o ponto representa uma liga\u00e7\u00e3o, ou seja, ambas representa\u00e7\u00f5es indicam que existe uma liga\u00e7\u00e3o f\u00edsica ou uma conex\u00e3o.</li> <li>A aus\u00eancia do X ou do ponto indica aus\u00eancia de conex\u00e3o.</li> </ul> <p>Arquitetura dos PLD</p> <p>Dentre os SPLD (simple PLDs), t\u00eam-se:</p> <ul> <li>PLA (arranjo l\u00f3gico program\u00e1vel - programmable logic array);<ul> <li>Consiste em um arranjo de portas AND program\u00e1vel e um arranjo de portas OR tamb\u00e9m program\u00e1vel.</li> </ul> </li> <li>PAL (l\u00f3gica de arranjo program\u00e1vel - programmable array logic);<ul> <li>Consiste em um arranjo de portas AND program\u00e1vel e um arranjo de portas OR fixo.</li> </ul> </li> <li>GAL (l\u00f3gica de arranjo gen\u00e9rico - generic array logic).<ul> <li>Assim como a PAL, tem um arranjo AND program\u00e1vel e um arranjo OR fixo.</li> <li>Adicionalmente, a GAL apresenta uma macroc\u00e9lula de sa\u00edda (OMLC) program\u00e1vel, com capacidade de armazenamento de dados de sa\u00edda.</li> </ul> </li> </ul> Figura 4: Exemplo de diagrama <p>Uma vez programado, o PLD program\u00e1vel atrav\u00e9s da queima de fus\u00edveis n\u00e3o pode ser recomposto. Essa desvantagem foi eliminada pela maioria dos fabricantes de PLD ao desenvolverem dispositivos que podem ser apagados e reprogramados quantas vezes forem necess\u00e1rias. Esses dispositivos s\u00e3o tamb\u00e9m chamados de dispositivos l\u00f3gicos program\u00e1veis apag\u00e1veis (EPLD - Erasable programmable logic device), sendo eles programados e apagados de maneira semelhante \u00e0s EEPROM</p> <p>Dispositivos L\u00f3gicos Program\u00e1veis Complexos (CPLDs)</p> <p>Os Dispositivos L\u00f3gicos Program\u00e1veis Complexos (CPLDs) foram introduzidos no mercado internacional pela empresa Altera Corp. em 1983, inicialmente como Dispositivos L\u00f3gicos Program\u00e1veis Apag\u00e1veis (EPLDs) e, posteriormente, como CPLDs.</p> <p>Nessa arquitetura foram utilizados esquemas de roteamento sofisticado, tecnologia de sil\u00edcio mais avan\u00e7ada, entre outras caracter\u00edsticas.</p> <p>Originalmente, os CPLDs podiam ser obtidos com a constru\u00e7\u00e3o e associa\u00e7\u00e3o de in\u00fameros SPLDs no mesmo chip.</p> <p>Arquitetura de um CPLD</p> <p>A arquitetura de um CPLD \u00e9 baseada em certo n\u00famero de blocos l\u00f3gicos, conforme ilustrado na Figura 4, cada um deles contendo uma macroc\u00e9lula e um arranjo PLA ou PAL, alguns blocos de E/S e todos estes blocos interligados por uma rede de interconex\u00e3o global program\u00e1vel.</p> Figura 5: Estrutura padr\u00e3o de um CPLD <p>Normalmente, incorporam blocos combinacionais e elementos de mem\u00f3ria do tipo flip-flop ou registros.</p> <p>Os elementos program\u00e1veis s\u00e3o c\u00e9lulas do tipo EEPROM.</p> <p>Esta arquitetura de dispositivo permite tornar mais aproveit\u00e1vel a \u00e1rea de integra\u00e7\u00e3o (\u00e1rea em sil\u00edcio) permitindo um desempenho melhor e redu\u00e7\u00e3o de custo. Um \u00fanico CPLD pode substituir centenas de componentes 74XX (portas l\u00f3gicas).</p> <p>As interconex\u00f5es program\u00e1veis formam um esp\u00e9cie de barramento que roteia (interliga) sinais das entradas ou sa\u00eddas para as entradas de um bloco l\u00f3gico, ou das sa\u00eddas de um bloco l\u00f3gico para as entradas do mesmo ou outro bloco.</p> <p>Cada bloco l\u00f3gico \u00e9 equivalente \u00e0 um SPLD, contendo suas macro c\u00e9lulas com suas interconex\u00f5es.</p> <p>Diferente das interconex\u00f5es configur\u00e1veis da SPLD, as interconex\u00f5es entre os blocos l\u00f3gicos da CPLD podem n\u00e3o ser totalmente conect\u00e1veis, ou seja, algumas conex\u00f5es entre um bloco e outro, teoricamente pode ser poss\u00edvel, mas na pr\u00e1tica n\u00e3o podem ser executadas.</p> <p>Com isso, torna-se dif\u00edcil utilizar 100% das macroc\u00e9lulas.</p> <p>Encapsulamentos</p> <p>Um Quad Flat Package (QFP ou encapsulamento quadrado) \u00e9 um encapsulamento de circuito integrado com terminais que se estendem de cada um dos quatro lados.</p> <p>Acondicionamentos especiais incluem LQFP (Low profile QFP) e TQFP (Thin QFP).</p> <p>Um plastic leaded chip carrier (PLCC) \u00e9 um encapsulamento pl\u00e1stico de quatro lados, com um terminal em \"J\" e espa\u00e7amentos de pino de 0,05\" (1,27 mm).</p> Figura 6: Encapsulamento <p>Como os principais fabricantes de CPLD podemos citar a Intel, que comprou a Altera em 2015, Xilinx, Microchip e Lattice.</p> <p>Matriz de Portas Program\u00e1veis (Field Programmable Gate Arrays - FPGAs)</p> <p>Ainda na d\u00e9cada de 1980, lan\u00e7adas pelas empresa Xilinx, surgiram as FPGAs (Field Programmable Gate Arrays) que diferem dos CPLDs em arquitetura, tecnologia, caracter\u00edsticas embutidas, tamanho, desempenho e custo.</p> <p>Elas s\u00e3o, de forma geral, uma matriz de blocos, ao inv\u00e9s de uma pilha como nos CPLDs, que possuem um n\u00famero de blocos maior, com blocos menores por\u00e9m mais sofisticados.</p> <p>FPGAs s\u00e3o circuitos program\u00e1veis que n\u00e3o possuem planos AND e OR, mas possuem um grande n\u00famero (da ordem de milhares) de unidades id\u00eanticas (blocos l\u00f3gicos) configur\u00e1veis.</p> <p>As unidades l\u00f3gicas podem ser vistas como componentes padr\u00f5es que podem ser configurados independentemente e interconectados a partir de uma matriz de  trilhas condutoras e chaves program\u00e1veis</p> Figura 7: Diagrama de blocos l\u00f3gicos de FPGA <p>Arquitetura de uma FPGA</p> <p>Arquitetura baseada em blocos l\u00f3gicos configur\u00e1veis, chamados de CLB (Configuration Logical Blocks).</p> <ul> <li>Os CLBs s\u00e3o formados por portas l\u00f3gicas e flip-flops que implementam fun\u00e7\u00f5es l\u00f3gicas.</li> <li>Blocos de entrada e sa\u00edda (IOB \u2013 In/Out Blocks), os quais s\u00e3o respons\u00e1veis pela interface das sa\u00eddas provenientes das combina\u00e7\u00f5es de CLBs.</li> </ul> Figura 8: Arquitetura de um FPGA <ul> <li>Os bits de configura\u00e7\u00e3o s\u00e3o selecionados de acordo com a fun\u00e7\u00e3o l\u00f3gica desejada (combinacional ou sequencial).</li> <li>A configura\u00e7\u00e3o \u00e9 uma tabela verdade (LUT - look up table) da funcionalidade. As LUTs podem ser programadas para qualquer tipo de porta necess\u00e1ria ao projeto. H\u00e1 um n\u00famero finito de LUTs em uma FPGA.</li> </ul> Figura 9: <p>Granularidade</p> <ul> <li>\u00c9 uma caracter\u00edstica dos FPGAs relacionada com o gr\u00e3o.</li> <li>O gr\u00e3o \u00e9 a menor unidade configur\u00e1vel que comp\u00f5e um FPGA.</li> <li> <p>A fim de classificar os FPGAs quanto ao bloco l\u00f3gico, foram criadas algumas categorias:</p> <ul> <li> <p>Gr\u00e3o Grande: Os FPGAs dessa categoria podem possuir como gr\u00e3o unidades l\u00f3gicas aritm\u00e9ticas, pequenos microprocessadores e mem\u00f3rias.</p> </li> <li> <p>Gr\u00e3o M\u00e9dio: Os FPGAs de gr\u00e3o m\u00e9dio frequentemente cont\u00eam dois ou mais LUTs e dois ou mais flip-flops. A maioria das arquiteturas de FPGAs implementam a l\u00f3gica em LUTs de quatro entradas.</p> </li> <li> <p>Gr\u00e3o Pequeno: Os FPGAs de gr\u00e3o pequeno cont\u00eam um grande n\u00famero de blocos l\u00f3gicos simples. Os blocos l\u00f3gicos normalmente cont\u00eam uma fun\u00e7\u00e3o l\u00f3gica de duas entradas ou multiplexadores 4x1 e um flip-flop.</p> </li> </ul> </li> </ul> <p>Aten\u00e7\u00e3o!</p> <p>A configura\u00e7\u00e3o da LUT e da interconex\u00e3o \u00e9 vol\u00e1til, isto \u00e9, se perde quando a alimenta\u00e7\u00e3o \u00e9 removida.</p> <p>S\u00e3o vol\u00e1teis pois as c\u00e9lulas de armazenamento s\u00e3o implementadas com mem\u00f3rias SRAMs (mem\u00f3rias RAM est\u00e1ticas).</p> <ul> <li>Existe uma mem\u00f3ria n\u00e3o-vol\u00e1til associada \u00e0 FPGA de onde a sua configura\u00e7\u00e3o \u00e9 carregada quando o sistema \u00e9 ligado.</li> <li>S\u00e3o necess\u00e1rias PROMS ao lado de FPGAs (conte\u00fado atualizado ao serem alimentadas).</li> <li>Geralmente utiliza-se uma pequena mem\u00f3ria FLASH ou EEPROM, cuja fun\u00e7\u00e3o \u00e9 carregar automaticamente as c\u00e9lulas de armazenamento, toda vez que o FPGA for energizado.</li> <li>J\u00e1 que a programa\u00e7\u00e3o \u00e9 feita pelo usu\u00e1rio depois da fabrica\u00e7\u00e3o, ela \u00e9 chamada de program\u00e1vel no campo \u2013 field programmable.</li> </ul> <p>T\u00e9cnicas de Configura\u00e7\u00e3o da Interconex\u00e3o</p> <ul> <li>As chaves program\u00e1veis de roteamento apresentam algumas propriedades, tais como tamanho, resist\u00eancia, capacit\u00e2ncia e tecnologia de fabrica\u00e7\u00e3o, que afetam principalmente a velocidade e o tempo de propaga\u00e7\u00e3o dos sinais e definem caracter\u00edsticas como volatilidade e capacidade de reprograma\u00e7\u00e3o.</li> <li>Na escolha de um dispositivo reconfigur\u00e1vel, esses fatores devem ser avaliados.</li> <li> <p>Basicamente existem tr\u00eas tipos de tecnologia de programa\u00e7\u00e3o das chaves de roteamento:</p> </li> <li> <p>SRAM;</p> </li> <li>Antifuse;</li> <li>Gate Flutuante</li> </ul> <p>SRAM</p> <p>Nessa tecnologia, a chave de roteamento ou comutador \u00e9 um transistor de passagem ou um multiplexador controlado por uma mem\u00f3ria est\u00e1tica de acesso rand\u00f4mico SRAM.</p> <p>A figura ilustra essa tecnologia de programa\u00e7\u00e3o, na qual uma c\u00e9lula SRAM \u00e9 utilizada para controlar a porta (gate) do transistor de passagem.</p> Figura 10: SRAM <p>Devido a volatilidade dessas mem\u00f3rias, os FPGAs que se utilizam dessa tecnologia precisam de uma mem\u00f3ria externa tipo FLASH ou EEPROM.</p> <p>Essa tecnologia ocupa muito espa\u00e7o no circuito integrado, por\u00e9m \u00e9 rapidamente reprogram\u00e1vel.</p> <p>Antifuse</p> <p>Essa tecnologia baseia-se num dispositivo de dois terminais, que no estado n\u00e3o programado apresenta uma alta imped\u00e2ncia (circuito aberto).</p> <p>Aplicando-se a uma tens\u00e3o, por exemplo, entre 11 e 20Vdc, o dispositivo forma um caminho de baixa imped\u00e2ncia entre seus terminais.</p> Figura 11: Antifuse <p>Gate Flutuante</p> <p>A tecnologia Gate flutuante baseia-se em transistores MOS (Metal Oxide Semicondutor), especialmente constru\u00eddos com dois Gates flutuantes semelhantes ao usados nas mem\u00f3rias EPROM (Erasable Programmable Read Only Memory) e EEPROM (Electrical EPROM).</p> <p>A maior vantagem dessa tecnologia \u00e9 sua capacidade de programa\u00e7\u00e3o e a reten\u00e7\u00e3o dos dados.</p> <p>Al\u00e9m disso, da mesma forma que uma mem\u00f3ria EEPROM, os dados podem ser programados com o circuito integrado instalado na placa, caracter\u00edstica denominada ISP (In System Programmability).</p> Figura 12: Gate Flutuante <p>Encapsulamentos</p> <ul> <li>Ball Grid Array (BGA): a conex\u00e3o entre o circuito integrado e a placa \u00e9 feita por pequenos pontos de solda na sua parte inferior, que est\u00e3o em contato direto com o chip de sil\u00edcio, dispensando os pinos externos como tamb\u00e9m outros tipos de pinagens n\u00e3o fixos.</li> <li> <p>\u00c9 um tipo de soldagem onde os terminais de contato s\u00e3o do tipo esfera.</p> </li> <li> <p>Pin Grid Array (PGA): o CI \u00e9 montado numa placa cer\u00e2mica na qual uma face \u00e9 coberta, ou parcialmente coberta, numa matriz quadrada de pinos de metal.</p> </li> <li> <p>Quad Flat Package (QFP): \u00e9 conhecido por sua alta densidade de pinos e sua capacidade de fornecer uma conex\u00e3o confi\u00e1vel entre o chip e a placa de circuito impresso.</p> </li> </ul> Figura 13: Encapsulamento de FPGA <p>Entre os principais fabricantes de FPGA, pode-se destacar novamente a Xilinx, Lattice, Microchip e Intel (Altera).</p> <p>FPGA x CPLD</p> <p>Ambos s\u00e3o dispositivos l\u00f3gico program\u00e1veis e ambos, muitas vezes, s\u00e3o produzidos pelas mesmas empresas. Por\u00e9m, existem muitas diferen\u00e7as entre estas tecnologias:</p> <ul> <li>FPGAs cont\u00e9m muitos pequenos blocos l\u00f3gicos com flip-flops (at\u00e9 da ordem de 1.000.000). CPLDs s\u00e3o compostos por um pequeno n\u00famero (algumas centenas) de grandes blocos l\u00f3gicos.</li> <li>FPGAs, tipicamente, s\u00e3o baseados em RAM. Isto significa que eles precisam ser reconfigurados (ou reprogramados) ap\u00f3s cada corte de energia (existem FPGAs com programa\u00e7\u00e3o persistente baseados em Flash ou EEPROM). CPLDs s\u00e3o, tipicamente, baseados em EEPROM. Eles j\u00e1 est\u00e3o ativos ao serem ligados (desde que tenham sido programados pelo menos uma vez).</li> <li>CPLDs t\u00eam um tempo de resposta melhor, por ser composto de alguns poucos grande blocos l\u00f3gicos. Em contrapartida esta caracter\u00edstica lhe d\u00e1 menos flexibilidade.</li> <li>FPGAs t\u00eam recursos de roteamento especiais para implementar de maneira eficiente fun\u00e7\u00f5es aritm\u00e9ticas e RAM. CPLDs n\u00e3o t\u00eam.</li> <li>FPGAs podem ser usados em projetos grandes e complexos, enquanto CPLDs est\u00e3o restritos a projetos bem menores.</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t01-intro_plds/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Integrated Circuits - Learn Sparkfun </li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t02-terasic-DE1-SoC/","title":"TerasIC DE1 SoC - DevKit","text":"","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t02-terasic-DE1-SoC/#terasic-de1-soc-for-intel-fpga-university-program","title":"TerasIC DE1-SoC for Intel FPGA University Program","text":"<p>O Kit de Desenvolvimento (Development Kit) DE1-SoC apresenta uma plataforma robusta de design de hardware constru\u00edda em torno do FPGA System-on-Chip (SoC) da Altera, que combina n\u00facleos embarcados Cortex-A9 dual-core com l\u00f3gica program\u00e1vel para m\u00e1xima flexibilidade de design, aproveitando poder da reconfigurabilidade aliada a um sistema de processador de alto desempenho e baixo consumo de energia.</p> <p>O SoC da Altera integra, como mostrado na Figura 1, um sistema de processador r\u00edgido ( HPS - Hard Processor System) baseado em ARM, composto por processador, perif\u00e9ricos e interfaces de mem\u00f3ria, perfeitamente integrados \u00e0 estrutura FPGA por meio de um backbone de interconex\u00e3o de alta largura de banda.</p> Figura 1: Diagrama de blocos - DE1-Soc DevKit Fonte: DE1-SoC Development and Education Kit <p>Especifica\u00e7\u00f5es</p> <ol> <li>FPGA Device<ul> <li>Cyclone V SoC 5CSEMA5F31C6 Device</li> <li>Dual-core ARM Cortex-A9 (HPS)</li> <li>85K Programmable Logic Elements</li> <li>4,450 Kbits embedded memory</li> <li>6 Fractional PLLs</li> <li>2 Hard Memory Controllers</li> </ul> </li> <li>Configuration and Debug<ul> <li>Serial Configuration device \u2013 EPCS128 on FPGA</li> <li>On-Board USB Blaster II (Normal type B USB connector)</li> </ul> </li> <li>Memory Device<ul> <li>64MB (32Mx16) SDRAM on FPGA</li> <li>1GB (2x256Mx16) DDR3 SDRAM on HPS</li> <li>Micro SD Card Socket on HPS</li> </ul> </li> <li>Communication<ul> <li>Two USB 2.0 Host Ports (ULPI interface with USB type A connector) on HPS</li> <li>UART to USB (USB Mini B connector)</li> <li>10/100/1000 Ethernet</li> <li>PS/2 mouse/keyboard</li> <li>IR Emitter/Receiver</li> </ul> </li> <li>Connectors<ul> <li>Two 40-pin Expansion Headers (voltage levels: 3.3V)</li> <li>One 10-pin ADC Input Header</li> <li>One LTC connector (One Serial Peripheral Interface (SPI) Master ,one I2C and one GPIO interface )</li> </ul> </li> <li>ADC<ul> <li>Sample rate: 500 KSPS</li> <li>Channel number: 8</li> <li>Resolution: 12 bits</li> <li>Analog input range : 0 ~ 4.096 V</li> </ul> </li> <li>Switches, Buttons and Indicators<ul> <li>4 User Keys (FPGA x4)</li> <li>10 User switches (FPGA x10)</li> <li>11 User LEDs (FPGA x10 ; HPS x 1)</li> <li>2 HPS Reset Buttons (HPS_RST_n and HPS_WARM_RST_n)</li> <li>Six 7-segment displays</li> </ul> </li> <li>Sensors<ul> <li>G-Sensor on HPS</li> </ul> </li> <li>Power<ul> <li>12V DC input</li> </ul> </li> </ol> <p>Layout</p> <p>A Figura 2 ilustra a distribui\u00e7\u00e3o na parte superior da placa de desenvolvimento dos dispositivos associados ao FPGA e ao HPS. Os diversos dispositivos da placa e os conectores podem ser vistos na distribui\u00e7\u00e3o apresentada na Figura 2.</p> Figura 2: Layout superior da placa DE1-SoC Fonte: DE1-SoC Development and Education Kit <p>Na parte inferior da placa de desenvolvimento \u00e9 poss\u00edvel configurar o FPGA para operar em modo EPCS (Erasable Programmable Configurable Serial) ou HPS (Hard Processor System) atrav\u00e9s das chaves de sele\u00e7\u00e3o <code>MSEL[4:0]</code> implementadas na chave <code>SW10</code>, como ilustrado na Figura 3.</p> Figura 3: Layout inferior da placa DE1-SoC Fonte: DE1-SoC Development and Education Kit <p>Obs: Note que a chave na posi\u00e7\u00f5a <code>ON</code> corresponde ao valor l\u00f3gico <code>0</code>.</p> MSEL[4:0] Configure Scheme Description 10010 AS FPGA configured from EPCS (default) 01010 FPPx32 FPGA configured from HPS software: Linux 00000 FPPx16 FPGA configured from HPS software: U-Boot,  with image stored on the SD card, like LXDE Desktop or  console Linux with frame buffer edition. <p>Vers\u00f5es do kit did\u00e1tico</p> <p>Existem algumas revis\u00f5es no projeto e documenta\u00e7\u00e3o da placa de desenvolvimento. Para identificar a vers\u00e3o que estamos utilizando, basta identificar, na parte inferior da placa, o n\u00famero de s\u00e9rie, conforme ilustrado na Figura 4.</p> Figura 4: Identificando a vers\u00e3o da placa Fonte: DE1-SoC Development and Education Kit <p>Conte\u00fado do kit</p> <p>A Figura 5 ilustra o conte\u00fado do kit did\u00e1tico DE1-SoC, que ser\u00e1 utilizado durante o desenvolvimento das atividades deste componente curricular.</p> Figura 5: Conte\u00fado do kit Fonte: DE1-SoC Development and Education Kit","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t02-terasic-DE1-SoC/#software","title":"Software","text":"<p>O software de desenvolvimento utilizado para projetos com a placa DE1-SoC \u00e9 o Intel\u00ae Quartus\u00ae Prime Lite Edition Design Software, aqui em sua vers\u00e3o 24.1.</p> <p>Ao baixar o instalador recomendado, execute o arquivo <code>qinst-lite-windows-24.1std-1077.exe</code> no Windows ou <code>qinst-lite-linux-24.1std-1077.run</code> no Linux.</p> <p>Ao abrir a janela do instalador, conforme Figura 6, selecione os pacotes pertinentes \u00e0 sua aplica\u00e7\u00e3o. Aqui s\u00e3o selecionados pacotes para os dispositivos <code>Cyclone\u00ae V</code> e <code>MAX\u00ae II</code>.</p> Figura 6: Instala\u00e7\u00e3o do Quartus Prime Lite Edition Fonte: Intel\u00ae Quartus\u00ae Prime Lite Edition Design Software <p>Ap\u00f3s a instala\u00e7\u00e3o a ferramenta est\u00e1 pronta para o uso.</p> Figura 7: Quartus Prime Lite Edition Fonte: Autor","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t02-terasic-DE1-SoC/#comunicacao-com-a-placa-de-desenvolvimento","title":"Comunica\u00e7\u00e3o com a placa de desenvolvimento","text":"<p>1) Verifique a fonte de alimenta\u00e7\u00e3o e conecte-a entre a placa e a tomada;</p> <p>2) Conecte o cabo USB entre a placa e o computador;</p> <p>3) Pressione o bot\u00e3o vermelho para ligar a placa;</p> <p>4) No Windows, abra o <code>Gerenciador de dispositivos</code> e verifique se o seguinte dispositivo foi reconhecido:</p> <ul> <li>JTAG cables<ul> <li>Altera USB-Blaster II (JTAG interface)</li> <li>Altera USB-Blaster II (System console interface)</li> </ul> </li> <li>Caso apare\u00e7a <code>Dispositivo desconhecido</code><ul> <li>Verifique se o driver est\u00e1 na pasta do quartus: <code>C:\\intelFPGA_lite\\XX.X\\quartus\\drivers\\usb-blaster-ii</code>, onde o <code>XX.X</code> \u00e9 a vers\u00e3o instalada.</li> <li>Se n\u00e3o houver o arquivo do driver na pasta de instala\u00e7\u00e3o do Quartus, baixe o driver direto do site e instale-o.</li> </ul> </li> </ul> <p>4) No Linux, n\u00e3o h\u00e1 necessidade de instalar driver para realizar download via USB-BlasterTM e USB-BlasterII, mas necessita de permiss\u00e3o de administrador.</p> <ul> <li>Com privil\u00e9gio de administrador, via <code>sudo</code> por exemplo, crie o novo arquivo <code>/etc/udev/rules.d/92-usbblaster.rules</code>, contendo:</li> </ul> 92-usbblaster.rules<pre><code># USB-Blaster\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"09fb\", ATTRS{idProduct}==\"6001\", MODE=\"0666\"\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"09fb\", ATTRS{idProduct}==\"6002\", MODE=\"0666\"\n\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"09fb\", ATTRS{idProduct}==\"6003\", MODE=\"0666\"\n\n# USB-Blaster II\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"09fb\", ATTRS{idProduct}==\"6010\", MODE=\"0666\"\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"09fb\", ATTRS{idProduct}==\"6810\", MODE=\"0666\"\n</code></pre> <ul> <li>Caso tenha problemas, consulte Intel\u00ae FPGA Download Cable (formerly USB-Blaster) Driver for Linux.</li> </ul> <p>Obs: A distribui\u00e7\u00e3o de GNU/Linux aqui utilizada \u00e9 <code>Debian 12</code>.</p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t02-terasic-DE1-SoC/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Manual do usu\u00e1rio DE1-SoC - rev.F/G</li> <li>DE1-SoC Development and Education Kit | terasIC</li> <li>Digital System Design (DSD) | kevinwlu github</li> <li>Quartus com Questa:Escolhendo o hardware | Nets&amp;Nuts</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t03-quartus-novo_projeto/","title":"Quartus - Novo Projeto","text":"<p>O processo de cria\u00e7\u00e3o de um projeto para o kit DE1-SoC \u00e9 complexo e possui um s\u00e9rie razoavelmente extensa de passos, assim, realize-os com aten\u00e7\u00e3o.</p> <p>Para ilustrar o processo, o objetivo \u00e9 criar um projeto que sintetize uma opera\u00e7\u00e3o l\u00f3gica b\u00e1sica, porta E, recebendo sinais de duas entradas f\u00edsicas da placa <code>SW9</code> e <code>SW8</code> e o resultado seja apresentado na sa\u00edda ligada ao <code>LEDR9</code>, de modo que se possa fazer a grava\u00e7\u00e3o e o teste empirico da s\u00edntese do circuito.</p> <p>1) Criando um novo projeto, utilizando o assistente do software Quartus</p> <p>File &gt; New Project Wizard</p> <p>Ap\u00f3s ler as instru\u00e7\u00f5es da tela New Project Wizard, clique em Next, conforme indicado na Figura 1.</p> Figura 1: Novo Projeto Fonte: Autor <p>2) Identifica\u00e7\u00e3o do projeto</p> <p>2.1) Defina um local e um nome para o projeto, depois clique em Next;</p> <p>2.2) Em seguida, \u00e9 possivel escolher se ser\u00e1 utilizado um modelo (template) existente ou n\u00e3o. Geralmente usaremos Empty project. Clique em Next.</p> <p>2.3) Na tela Add Files apenas clique em Next sem incluir qualquer arquivo no momento.</p> Figura 2: Identifica\u00e7\u00e3o do projeto Fonte: Autor <p>3) Sele\u00e7\u00e3o de placa</p> <p>3.1) Na tela Family, Device &amp; Board Settings selecione a aba Board, Family : <code>Cyclone V</code> e Development kit : <code>DE1 SoC Board</code>, ent\u00e3o clique em Next.</p> <p>3.2) Em EDA Tool Settings, selecione para o campus Simulation: <code>QuestaSim</code> <code>VHDL</code>, em seguida Next.</p> <p>3.3) Por fim aparece o Summary com o resumo dos par\u00e2metros do projeto. Verifique as informa\u00e7\u00f5es e clique em Finish.</p> <p>3.4) Ao final, aparece uma mensagem solicitando confirma\u00e7\u00e3o de fonte segura. Se concorda, clique em Yes.</p> Figura 3: Sele\u00e7\u00e3o de placa e simula\u00e7\u00e3o Fonte: Autor <p>Ap\u00f3s a cria\u00e7\u00e3o do projeto, vamos criar o programa utilizando um diagrama de blocos.</p> <p>4) Cria\u00e7\u00e3o do arquivo de programa/diagrama</p> <p>4.1) File &gt; New...*</p> <p>4.2) Na janela New, escolha a op\u00e7\u00e3o <code>Block Diagram/Schematic File</code>. Clique em Ok.</p> Figura 4: Novo arquivo - Diagrama de Blocos Fonte: Autor <p>Foi criado um arquivo com o nome Block1.bdf.</p> <p>5) Importa\u00e7\u00e3o de atribui\u00e7\u00e3o de pinos</p> <p>A importa\u00e7\u00e3o dos pinos da placa de desenvolvimento \u00e9 um procedimento que poupa um grande tempo em mapear em quais pinos do FPGA cada componente de entrada e sa\u00edda est\u00e1 conectado.</p> <p>\u00c9 comum que sejam disponibilizadas essas atribui\u00e7\u00f5es, pelos fabricantes dos kits de desenvolvimento, e tais atribui\u00e7\u00f5es podem ser encontradas em Intel\u00ae Quartus\u00ae Prime Design Software Setting File with Pin Assignments. Para facilitar segue o arquivo de atribui\u00e7\u00e3o de pinos da placa DE1-SoC.qsf.</p> <p>Ap\u00f3s realizar o Download do arquivo <code>DE1_SoC.qsf</code>:</p> <p>5.1) Assignments &gt; Import Assignments</p> <p>5.2) Na tela Import Assignments, clique em <code>...</code> conforme indicado na Figura 5.</p> <p>5.3) Em Select File, selecione o arquivo <code>DE1_SoC.qsf</code> no local em que fez o download, e confirme, Ok.</p> Figura 5: Importa\u00e7\u00e3o de atribui\u00e7\u00e3o de pinos Fonte: Autor <p>6) Montando circuito</p> <p>Conforme a Figura 6 indica, clique em Symbol Tool.</p> Figura 6: Inserindo portas l\u00f3gicas b\u00e1sicas Fonte: Autor <p>Selecione em Libraries, o diret\u00f3rio primitives e logic ou digite no campo Name o nome da porta que se quer usar: <code>and2</code>, em seguida, clique em Ok.</p> Figura 7: Inserindo elementos primitivos Fonte: Autor <p>A Figura 8 ilustar a ferramenta para inserir pinos de entrada (<code>Input</code>), sa\u00edda (<code>Output</code>) e bidirecionais (<code>Bidir</code>).</p> Figura 8: Inserindo conectores Fonte: Autor <p>Para alocar os pinos, ainda sem nomes ou conex\u00f5es com os dispositivos f\u00edsicos, clique em Pin Planner, conforme Figura 9.</p> <p>No campo Named, digite <code>LED*</code> para que sejam listadas todos os pinos associados \u00e0s sa\u00eddas com este prefixo. Da mesma forma, busque por <code>SW*</code> para identificar as entradas com este prefixo.</p> <p>Troque os nomes gen\u00e9ricos dos pinos <code>pin_name1</code>, por exemplo, pelo nome associado ao pino de entrada <code>SW[8]</code>, bem como a outra entrada e a sa\u00edda, conforme Figura 9.</p> Figura 9: Alocando os pinos Fonte: Autor <p>Conforme Figura 10, clique no destaque <code>Compile Design</code>.</p> <p>Ao final, n\u00e3o devem haver erros no circuito.</p> Figura 10: Compilando o circuito Fonte: Autor <p>Em seguida, com a placa conectada ao computador via USB, clique em Program Device.</p> <p>Selecione Hardware Setup, conforme Figura 11.</p> Figura 11: Abrindo o Program Device Fonte: Autor <p>Em seguida, clique em Auto Detect, conforme indicado em Figura 12.</p> <p>Selecione o dispositivo: <code>5CSEMA5</code>.</p> Figura 12: Auto Detect Fonte: Autor <p>Conforme Figura 13, clique em <code>&lt;none&gt;</code> do campo File, para abrir a janela de carregamento do arquivo compilado.</p> <p>Abra o diret\u00f3rio <code>output_files</code> e selecione o seu projeto com extens\u00e3o <code>.sof</code>. Clique em Open.</p> Figura 13: Output_files Fonte: Autor <p>Na mesa linha ainda, marque a caixa de sele\u00e7\u00e3o do campo Program/Configure e clique em Start.</p> Figura 14: Gravar dispositivo Fonte: Autor <p>Ao final da barra de progresso com 100%, o programa est\u00e1 gravado.</p> Figura 15: Opera\u00e7\u00e3o de l\u00f3gica E Fonte: Autor <p>Realize o teste da l\u00f3gica E utilizando as chaves <code>SW9</code> e <code>SW8</code> como entradas e a sa\u00edda <code>LEDR9</code>.</p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t03-quartus-novo_projeto/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Notas de aula/Slides de SDP Prof. Ary (2024)</li> <li>My First FPGA Tutorial</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t04-quartus-sim_vwf/","title":"Quartus - Simula\u00e7\u00e3o VWF","text":"<p>Vector Waveform File </p> Figura 1: Criando um novo projeto com assistente Fonte: Autor Figura 2: Tipo de projeto e adi\u00e7\u00e3o de arquivos Fonte: Autor Figura 3: Fam\u00edlia, Dispositivo e Configura\u00e7\u00e3o de placa Fonte: Autor Figura 4: Configura\u00e7\u00e3o da ferramenta EDA e Sum\u00e1rio Fonte: Autor Figura 5: Novo projeto criado Fonte: Autor Figura 6: Cria\u00e7\u00e3o do arquivo de esquem\u00e1tico Fonte: Autor Figura 7: Ambiente de simula\u00e7\u00e3o vwf (Vector Waveform File) Fonte: Autor Figura 8: Ajustando tempo final da simula\u00e7\u00e3o Fonte: Autor Figura 9: Inserindo elementos de simula\u00e7\u00e3o Fonte: Autor Figura 10: Inserindo sinal de simula\u00e7\u00e3o em uma entrada Fonte: Autor Figura 10: Inserindo sinal de simula\u00e7\u00e3o em uma entrada Fonte: Autor Figura 11: Ajustando par\u00e2metros de compila\u00e7\u00e3o Fonte: Autor Figura 12: Salvando arquivo de simula\u00e7\u00e3o Fonte: Autor Figura 13: Resultado da simula\u00e7\u00e3o Fonte: Autor <p>Erros</p> Figura 14: Erro 1 - Par\u00e2metro -novopt deve ser retirado Fonte: Autor Figura 14: Erro 2 - Sa\u00edda indefinida Fonte: Autor <p>Corre\u00e7\u00e3o:</p> <p>No Quartus Prime, (N\u00e3o no Simulation Waveform Edition), acesse:</p> <ol> <li>Tools -&gt; Options...</li> <li>Em Category, clique em EDA Tools Options</li> <li>No campo ModelSim insira o diret\u00f3rio correspondente a: <code>C:/intelFPGA/20.1/modelsim_ase/win32aloem</code> da instala\u00e7\u00e3o do ModelSim.</li> <li>Se n\u00e3o houver o ModelSim instalado, fa\u00e7a o Download e instale-o.</li> <li>Execute o passo 3 e em seguida execute a simula\u00e7\u00e3o novamente.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t05-quartus-rtl_viewer/","title":"Quartus - Visualiza\u00e7\u00e3o do RTL","text":"Figura 1: Novo arquivo VHDL Fonte: Autor Figura 2: Edi\u00e7\u00e3o do c\u00f3digo, an\u00e1lise e sintese Fonte: Autor Figura 3: Simula\u00e7\u00e3o do RTL Fonte: Autor Figura 4: Simula\u00e7\u00e3o no Questa Fonte: Autor Figura 5: Adicionando formas de onda Fonte: Autor Figura 6: Abrindo objetos Fonte: Autor Figura 7: Modificando formas de onda das entradas Fonte: Autor Figura 8: Execu\u00e7\u00e3o das formas de onda Fonte: Autor Figura 9: Salvando simula\u00e7\u00e3o Fonte: Autor Figura 10: Abrindo a visualiza\u00e7\u00e3o do RTL Fonte: Autor Figura 11: Visualiza\u00e7\u00e3o do RTL Fonte: Autor","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/tecnologia/t06-ghdl-gtkwave/","title":"GHDL - GtkWave","text":"<p>O GHDL \u00e9 um compilador e simulador de c\u00f3digo aberto para VHDL, mantido pela comunidade de desenvolvedores no GitHub, regularmente atualizado.</p> <p>Pode ser executado em Windows, macOs e GNU/Linux e possui suporte para diversas plataformas entre elas x86, x86_64, armv6/armv7/aarch32, aarch64 e ppc64.</p> <p>Possui suporte completo \u00e0s vers\u00f5es de VHDL IEEE 1076 padr\u00f5es 1987, 1993 e 2002 e suporte parcial \u00e0s vers\u00f5es 2008 e 2019.</p> <p>Possui a desvantagem de dar suporte apenas \u00e0 linguagem VHDL, n\u00e3o suportando Verilog ou System Verilog.</p> <p>Necessita exportar seus arquivos para formatos de onda do tipo GHW, VCD ou FST para visualizador como o GtkWave.</p> <p></p> <p>O GtkWave \u00e9 uma ferramenta de an\u00e1lise para executar depura\u00e7\u00e3o em modelos de simula\u00e7\u00e3o VHDL.</p> <p>Suporta v\u00e1rios formatos de despejo (dump) como:</p> <ul> <li>Value Change Dump (VCD);</li> <li>InterLaced eXtensible Trace (LXT);</li> <li>GHDL Waveform (GHW).</li> </ul> <p>Instala\u00e7\u00e3o (Windows)</p> <ol> <li>Download GHDL V5.1.1.</li> <li>Download GtkWave v3.</li> <li>Clique com o bot\u00e3o direito sobre cada um dos arquivos e <code>Extrair tudo</code>.</li> <li>Renomeie os respectivos diret\u00f3rios para <code>ghdl</code> e <code>gtkwave</code>.</li> <li>Mova ambos para <code>C:\\eda\\</code>.</li> <li>Edite as vari\u00e1veis de ambiente do sistema:<ol> <li>Vari\u00e1veis de usu\u00e1rio</li> <li>Vari\u00e1vel: <code>Path</code> -&gt; Editar -&gt; Novo</li> <li>Inclua: <code>C:\\eda\\ghdl\\bin</code></li> <li>Inclua: C:\\eda\\gtkwave\\bin`</li> <li>Clique em <code>Ok</code> -&gt; <code>Ok</code> -&gt; <code>Ok</code></li> </ol> </li> <li>GHDL e GtkWave instalados.</li> </ol> <p>Instala\u00e7\u00e3o (GNU/Linux - Debian)</p> <pre><code>sudo apt update\nsudo apt install ghdl gtkwave\n</code></pre> <p>Primeiro programa</p> <p>Crie um arquivo de porta l\u00f3gica b\u00e1sica do tipo <code>E</code> (And).</p> and.vhdl<pre><code>library ieee;\nuse ieee.std_logic_1164.all;\n\nentity and_gate is\n    port(x0,x1: in std_logic; y:out std_logic );\nend entity;\n\narchitecture main of and_gate is\nbegin\n    y &lt;= x0 and x1;\nend architecture;\n</code></pre> <p>Crie um arquivo de <code>teste de bancada</code>.</p> and_tb.vhdl<pre><code>library ieee;\nuse ieee.std_logic_1164.all;\n\nentity and_gate_test_bench is\nend and_gate_test_bench;\n\n\narchitecture test of and_gate_test_bench is\n    component and_gate\n        port(x0,x1: in std_logic; y: out std_logic);\n    end component;\n    signal in0, in1, out0 : std_logic;\nbegin\n    gate_and: and_gate port map(x0 =&gt; in0, x1 =&gt; in1, y =&gt; out0);\n    process begin\n        in0 &lt;= 'X';\n        in1 &lt;= 'X';\n        wait for 1 ns;\n\n        in0 &lt;= '0';\n        in1 &lt;= '0';\n        wait for 1 ns;\n\n        in0 &lt;= '1';\n        in1 &lt;= '0';\n        wait for 1 ns;\n\n        in0 &lt;= '0';\n        in1 &lt;= '1';\n        wait for 1 ns;\n\n        in0 &lt;= '1';\n        in1 &lt;= '1';\n        wait for 1 ns;\n\n        assert false report \"Executed testbench\";\n        wait;\n    end process;\nend architecture;\n</code></pre> <p>Crie um arquivo de Makefile.</p> makefile<pre><code>HDL=ghdl\nFLAGS=\"--std=08\"\nSIM=gtkwave\n\nall:\n    @$(HDL) -a $(FLAGS) and.vhdl\n    @$(HDL) -a $(FLAGS) and_tb.vhdl\n    @$(HDL) -e $(FLAGS) and_gate_test_bench\n    @$(HDL) -r $(FLAGS) and_gate_test_bench --wave=wave.ghw  --stop-time=5us\n\nwave:\n    $(SIM) wave.ghw\n</code></pre> <p>No Windows PowerShell, digite:</p> <pre><code>make\n</code></pre> <p>e para executar a simula\u00e7\u00e3o, digite:</p> <pre><code>make wave\n</code></pre> <p></p> <p>Refer\u00eancias</p> <ul> <li>GHDL Reposit\u00f3rio</li> <li>GHDL Documentation</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","FPGA","GHDL","GtkWave"]},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/","title":"00 rascunho","text":"<p>Distribui\u00e7\u00e3o de Clock no DE1-SoC</p> Figura : Diagrama de blocos da distribui\u00e7\u00e3o de clock no DE1-SoC Fonte: Manual do usu\u00e1rio DE1-SoC - rev. F/G - p\u00e1g. 22 <p>Tabela 1: Atribui\u00e7\u00e3o de pinos de clock</p> Signal Name FPGA Pin No. Description I/O Standard CLOCK_50 PIN_AF14 50 MHz clock input 3.3V CLOCK2_50 PIN_AA16 50 MHz clock input 3.3V CLOCK3_50 PIN_Y26 50 MHz clock input 3.3V CLOCK4_50 PIN_K14 50 MHz clock input 3.3V HPS_CLOCK1_25 PIN_D25 25 MHz clock input 3.3V HPS_CLOCK2_25 PIN_F25 25 MHz clock input 3.3V <p>Driver no linux (Debian) - USB Blaster</p> <p>Quartus\u00ae II software does not need any specific usb drivers on Linux to access the USB-BlasterTM and USB-Blaster II download cable. By default, root is the only user allowed to use these devices.You must change the permissions on the device files before you can use the USB-Blaster or USB-Blaster IIdownload cable to program devices with Quartus II software.</p> <p>You must have system administration (root) privileges to add udev rules to correctly configure the access rights.</p> <p>Driver Setup for recent udev</p> <p>Add a new file /etc/udev/rules.d/92-usbblaster.rules file. Note that the 92 is important for e.g. Debian Wheezy as there is a default rule for \"usbfs-like\" devices /lib/udev/rules.d/91-permissions.rules specifying a MODE of 664. Because udev assigns priority to rules by the sort order of the file names theyappear in the USB Blaster rules have to be placed in an appropriate file.</p>"},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/#usb-blaster","title":"USB-Blaster","text":"<p>SUBSYSTEM==\"usb\", ATTRS{idVendor}\"09fb\", ATTRS{idProduct}\"6001\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}\"09fb\", ATTRS{idProduct}\"6002\", MODE=\"0666\"</p> <p>SUBSYSTEM==\"usb\", ATTRS{idVendor}\"09fb\", ATTRS{idProduct}\"6003\", MODE=\"0666\"</p>"},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/#usb-blaster-ii","title":"USB-Blaster II","text":"<p>SUBSYSTEM==\"usb\", ATTRS{idVendor}\"09fb\", ATTRS{idProduct}\"6010\", MODE=\"0666\" SUBSYSTEM==\"usb\", ATTRS{idVendor}\"09fb\", ATTRS{idProduct}\"6810\", MODE=\"0666\"</p> <p>Driver Setup for Ubuntu</p> <p>For Ubuntu 12.04/14.04/16.04 create the file /etc/udev/rules.d/51-usbblaster.rules with the following contents:</p>"},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/#usb-blaster_1","title":"USB Blaster","text":"<p>SUBSYSTEM==\"usb\", ENV{DEVTYPE}\"usb_device\", ATTR{idVendor}\"09fb\", ATTR{idProduct}\"6001\", MODE=\"0666\", NAME=\"bus/usb/\\(env{BUSNUM}/\\)env{DEVNUM}\", RUN+=\"/bin/chmod 0666 %c\" SUBSYSTEM\"usb\", ENV{DEVTYPE}\"usb_device\", ATTR{idVendor}\"09fb\", ATTR{idProduct}\"6002\", MODE=\"0666\", NAME=\"bus/usb/\\(env{BUSNUM}/\\)env{DEVNUM}\", RUN+=\"/bin/chmod 0666 %c\" SUBSYSTEM\"usb\", ENV{DEVTYPE}\"usb_device\", ATTR{idVendor}\"09fb\", ATTR{idProduct}==\"6003\", MODE=\"0666\", NAME=\"bus/usb/\\(env{BUSNUM}/\\)env{DEVNUM}\", RUN+=\"/bin/chmod 0666 %c\"</p>"},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/#usb-blaster-ii_1","title":"USB Blaster II","text":"<p>SUBSYSTEM==\"usb\", ENV{DEVTYPE}\"usb_device\", ATTR{idVendor}\"09fb\", ATTR{idProduct}\"6010\", MODE=\"0666\", NAME=\"bus/usb/\\(env{BUSNUM}/\\)env{DEVNUM}\", RUN+=\"/bin/chmod 0666 %c\" SUBSYSTEM\"usb\", ENV{DEVTYPE}\"usb_device\", ATTR{idVendor}\"09fb\", ATTR{idProduct}==\"6810\", MODE=\"0666\", NAME=\"bus/usb/\\(env{BUSNUM}/\\)env{DEVNUM}\", RUN+=\"/bin/chmod 0666 %c\"</p> <p>then insert, or reinsert the USB cable.</p> <p>See also https://www.intel.com/content/www/us/en/programmable/support/support-resources/download/drivers/dri-usb_b-lnx.html</p> <p>My First FPGA Tutorial</p>"},{"location":"digitais/Tecnologia/fpga/terasic_de1_soc/00-rascunho/#referencias","title":"Refer\u00eancias","text":"<p>1.</p> Figura : Questa Install Fonte: Autor Figura : Questa Install Fonte: Autor Figura : Modelsim Install Fonte: Autor Figura : Modelsim Install Fonte: Autor Figura : EDA licenseSetup_sim Fonte: Autor Figura : EDA tool Option_sim Fonte: Autor Figura : EDA tool Setting_sim Fonte: Autor .bashrc<pre><code>export LM_LICENSE_FILE=\"$HOME/intelFPGA_lite/24.1std/licenses/LR-NNNNNN_License.dat\"\n</code></pre> <p>QuestaSim: /home/josewrpereira/intelFPGA_lite/24.1std/questa_fse/bin Qesta Intel F?: /home/josewrpereira/intelFPGA_lite/24.1std/questa_fse/linux_x86_64 ModelSim: /home/josewrpereira/intelFPGA/20.1/modelsim_ase/bin</p>"},{"location":"digitais/Tecnologia/fpga/vhdl/v01-fundamentos/","title":"01 - Linguagem de Descri\u00e7\u00e3o de Hardware - HDL","text":"<p>1. Introdu\u00e7\u00e3o e Contexto Hist\u00f3rico do VHDL</p> <p>O VHDL (VHSIC Hardware Description Language) \u00e9 uma Linguagem de Descri\u00e7\u00e3o de Hardware (HDL) desenvolvida para descrever o comportamento de circuitos ou sistemas eletr\u00f4nicos, permitindo que o circuito f\u00edsico seja implementado a partir dessa descri\u00e7\u00e3o. A origem da linguagem remonta ao projeto VHSIC (Very High Speed Integrated Circuits), financiado pelo Departamento de Defesa dos EUA (DARPA) na d\u00e9cada de 1980, com o objetivo de criar uma ferramenta padr\u00e3o para projeto e documenta\u00e7\u00e3o de circuitos.</p> <p>O VHDL foi a primeira HDL a ser padronizada pelo IEEE (Institute of Electrical and Electronic Engineers). As principais vers\u00f5es e padr\u00f5es incluem:</p> <ul> <li>IEEE 1076 (1987 e 1993): O padr\u00e3o fundamental da linguagem. As altera\u00e7\u00f5es de 1993, embora significativas para arquivos, n\u00e3o trouxeram mudan\u00e7as cruciais para a s\u00edntese de circuitos.</li> <li>IEEE 1164: Introduziu o pacote <code>std_logic_1164</code>, que define tipos de dados (como <code>STD_LOGIC</code>) capazes de modelar condi\u00e7\u00f5es reais de circuitos, como alta imped\u00e2ncia (<code>Z</code>), n\u00edveis de for\u00e7a fraca (<code>L</code> e <code>H</code>), e estados desconhecidos (<code>U</code>, <code>X</code>, <code>W</code>).</li> <li>IEEE 1076.3: Define tipos num\u00e9ricos em formato de vetor (<code>signed</code> e <code>unsigned</code>) e fun\u00e7\u00f5es aritm\u00e9ticas para s\u00edntese, preenchendo a lacuna deixada pela limita\u00e7\u00e3o das opera\u00e7\u00f5es aritm\u00e9ticas em tipos <code>INTEGER</code> e <code>REAL</code>.</li> </ul> <p>Uma motiva\u00e7\u00e3o chave para o uso do VHDL \u00e9 sua natureza como um padr\u00e3o independente de tecnologia e fabricante, assegurando a portabilidade e a reusabilidade do c\u00f3digo.</p> <p>2. Aspectos Gerais e Estrutura da Linguagem</p> <p>Concorr\u00eancia vs. Sequencialidade</p> <p>A caracter\u00edstica fundamental do VHDL \u00e9 ser uma linguagem concorrente. Com exce\u00e7\u00e3o de regi\u00f5es espec\u00edficas do c\u00f3digo, os comandos s\u00e3o executados simultaneamente, refletindo o funcionamento paralelo de um sistema digital real, onde a ordem de apresenta\u00e7\u00e3o dos comandos \u00e9 irrelevante para o comportamento final.</p> <ul> <li>Simula\u00e7\u00e3o e Atraso Delta (\\(\\Delta\\)): Para coordenar a avalia\u00e7\u00e3o de eventos que ocorrem no mesmo instante em um c\u00f3digo concorrente, o simulador utiliza um atraso interno nulo, denominado \\(\\Delta\\). Um sinal recebe um novo valor ap\u00f3s um intervalo de \\(1\\Delta\\), garantindo a ordena\u00e7\u00e3o l\u00f3gica dos eventos.</li> </ul> <p>No entanto, o VHDL permite delimitar regi\u00f5es de c\u00f3digo sequencial usando comandos espec\u00edficos, onde a execu\u00e7\u00e3o dos comandos segue a ordem de sua apresenta\u00e7\u00e3o. Essas regi\u00f5es s\u00e3o tipicamente encontradas em subprogramas (fun\u00e7\u00f5es e procedimentos) e processos (<code>PROCESS</code>).</p> <p>Elementos Estruturais Fundamentais</p> <p>Uma descri\u00e7\u00e3o VHDL b\u00e1sica \u00e9 composta por:</p> <ol> <li>Entidade (<code>ENTITY</code>): A abstra\u00e7\u00e3o prim\u00e1ria de um circuito. Define a interface externa do projeto, listando as portas (<code>PORTs</code>) e, opcionalmente, os gen\u00e9ricos (<code>GENERIC</code>).</li> <li>Arquitetura (<code>ARCHITECTURE</code>): Descreve o comportamento ou a estrutura interna da entidade, especificando as rela\u00e7\u00f5es entre as entradas e sa\u00eddas. Uma entidade pode ter m\u00faltiplas arquiteturas, cada par (Entidade-Arquitetura) representando uma entidade distinta com a mesma interface.</li> </ol> <p></p> <p>Portas e Modos</p> <p>As portas definem a dire\u00e7\u00e3o e a natureza da transfer\u00eancia de informa\u00e7\u00e3o na interface da entidade:</p> <ul> <li>IN: Exclusivamente entrada.</li> <li>OUT: Sa\u00edda. O valor n\u00e3o pode ser lido internamente pela arquitetura.</li> <li>BUFFER: Sa\u00edda, cujo valor pode ser lido internamente. \u00c9 \u00fatil quando o valor de sa\u00edda precisa ser usado como entrada dentro da pr\u00f3pria arquitetura.</li> <li>INOUT: Porta bidirecional, usada para modelar barramentos de dados.</li> </ul> <p>Classes de Objetos</p> <p>Existem quatro classes de objetos em VHDL:</p> <ul> <li>Sinal (<code>SIGNAL</code>): Utilizado em regi\u00f5es concorrentes e sequenciais; o valor \u00e9 atualizado ap\u00f3s um \\(\\Delta\\) (na suspens\u00e3o do processo, se em regi\u00e3o sequencial).</li> <li>Vari\u00e1vel (<code>VARIABLE</code>): Utilizada em regi\u00f5es sequenciais; o valor \u00e9 assumido imediatamente ap\u00f3s a execu\u00e7\u00e3o do comando.</li> <li>Constante (<code>CONSTANT</code>): Valor est\u00e1tico, n\u00e3o alter\u00e1vel durante a execu\u00e7\u00e3o.</li> <li>Arquivo (<code>FILE</code>): Associado \u00e0 manipula\u00e7\u00e3o de arquivos no sistema hospedeiro (usado principalmente em testes).</li> </ul> <p>3. Aplica\u00e7\u00f5es do VHDL e Fluxo de Projeto</p> <p>O VHDL n\u00e3o foi concebido originalmente para a s\u00edntese de circuitos, mas sim para a descri\u00e7\u00e3o e simula\u00e7\u00e3o. Contudo, sua aplica\u00e7\u00e3o principal no desenvolvimento de hardware digital (ASICs, FPGAs) \u00e9 a s\u00edntese.</p> <p>Fluxo de S\u00edntese</p> <p>O processo de projeto com VHDL, do in\u00edcio ao fim, envolve tipicamente as seguintes etapas:</p> <ol> <li>Elabora\u00e7\u00e3o da Descri\u00e7\u00e3o VHDL (RTL): Cria\u00e7\u00e3o do c\u00f3digo com o n\u00edvel de abstra\u00e7\u00e3o adequado. Isso pode ser um processo iterativo, com simula\u00e7\u00f5es e detalhamento at\u00e9 que a descri\u00e7\u00e3o seja sintetiz\u00e1vel.</li> <li>Verifica\u00e7\u00e3o (Simula\u00e7\u00e3o): O c\u00f3digo \u00e9 validado via simula\u00e7\u00e3o, geralmente com est\u00edmulos de teste, para garantir que ele corresponda \u00e0 especifica\u00e7\u00e3o do projeto.</li> <li>S\u00edntese: Uma ferramenta de s\u00edntese interpreta o c\u00f3digo e infere as estruturas de hardware necess\u00e1rias (registradores, portas l\u00f3gicas) no n\u00edvel RTL (Register Transfer Level).</li> <li>Transposi\u00e7\u00e3o para a Tecnologia Alvo: O circuito RTL (que \u00e9 gen\u00e9rico) \u00e9 mapeado para elementos dispon\u00edveis na tecnologia de fabrica\u00e7\u00e3o espec\u00edfica (n\u00edvel de portas l\u00f3gicas), otimizando o circuito (velocidade vs. \u00e1rea).</li> <li>Posicionamento e Interliga\u00e7\u00e3o (Place and Route): Defini\u00e7\u00e3o do layout f\u00edsico dos componentes e roteamento das interconex\u00f5es no dispositivo alvo.</li> <li>Verifica\u00e7\u00e3o P\u00f3s-Layout: O circuito f\u00edsico com os atrasos de interconex\u00e3o (obtidos via arquivos SDF - Standard Delay Format) \u00e9 submetido novamente \u00e0 simula\u00e7\u00e3o para verificar temporiza\u00e7\u00e3o e restri\u00e7\u00f5es.</li> </ol> <p>Abstra\u00e7\u00e3o e Hierarquia Top-Down</p> <p>O VHDL suporta m\u00faltiplos n\u00edveis de abstra\u00e7\u00e3o e organiza\u00e7\u00e3o hier\u00e1rquica. O top-down design (do todo para as partes mais simples) \u00e9 facilitado pela capacidade de usar diferentes estilos de descri\u00e7\u00e3o (estrutural e comportamental) e pela modulariza\u00e7\u00e3o.</p> <p>A hierarquia \u00e9 constru\u00edda no VHDL principalmente pela declara\u00e7\u00e3o e solicita\u00e7\u00e3o de componentes. Um componente representa uma entidade (m\u00f3dulo) menor que \u00e9 interligada em uma arquitetura maior (estilo estrutural), permitindo o reuso e modularidade do c\u00f3digo.</p> <p>4. Comandos e Constru\u00e7\u00f5es Essenciais</p> <p>Comandos Concorrentes</p> <ul> <li>Atribui\u00e7\u00e3o de Sinal (<code>&lt;=</code>): A forma b\u00e1sica de atribuir valor a um sinal, sempre com um atraso de \\(1\\Delta\\) em rela\u00e7\u00e3o \u00e0 sua avalia\u00e7\u00e3o.</li> <li><code>WHEN ELSE</code> (Atribui\u00e7\u00e3o Condicional): Permite a transfer\u00eancia condicional de um sinal com prioridade: a primeira condi\u00e7\u00e3o verdadeira na lista define o valor do sinal.</li> <li><code>WITH SELECT</code> (Atribui\u00e7\u00e3o Selecionada): Transfere um valor a um sinal com base em uma express\u00e3o de escolha. As condi\u00e7\u00f5es devem ser mutuamente exclusivas e todas as possibilidades devem ser cobertas.</li> </ul> <p>Comandos Sequenciais</p> <p>Estes comandos s\u00e3o usados dentro de processos ou subprogramas:</p> <ul> <li>Atribui\u00e7\u00e3o de Vari\u00e1vel (<code>:=</code>): O valor \u00e9 assumido imediatamente.</li> <li><code>IF ELSE</code>: Permite a execu\u00e7\u00e3o condicional de comandos com prioridade definida pela ordem das cl\u00e1usulas (<code>IF</code>, <code>ELSIF</code>, <code>ELSE</code>).</li> <li><code>CASE WHEN</code>: Permite a execu\u00e7\u00e3o condicional de comandos baseada no valor de uma express\u00e3o de escolha. As condi\u00e7\u00f5es devem ser mutuamente exclusivas e todas as condi\u00e7\u00f5es devem ser cobertas, sendo ideal para m\u00e1quinas de estados.</li> <li><code>WAIT</code>: Suspende a execu\u00e7\u00e3o de um processo ou procedimento, podendo ser condicionado por eventos em sinais (<code>WAIT ON</code>), express\u00f5es booleanas (<code>WAIT UNTIL</code>), ou tempo (<code>WAIT FOR</code>).</li> <li><code>NULL</code>: N\u00e3o realiza nenhuma opera\u00e7\u00e3o; \u00fatil em constru\u00e7\u00f5es <code>CASE WHEN</code> para cobrir condi\u00e7\u00f5es sem a\u00e7\u00e3o necess\u00e1ria, ou para manter o valor anterior em registradores.</li> </ul> <p>Outras Estruturas de Controle</p> <ul> <li><code>GENERATE</code>: Repete comandos concorrentes (<code>FOR</code> ou <code>IF</code>), crucial para a cria\u00e7\u00e3o autom\u00e1tica de circuitos regulares (como somadores celulares).</li> <li><code>LOOP</code>: Repete comandos sequenciais (<code>FOR</code> ou <code>WHILE</code>), usado em rotinas de convers\u00e3o e gera\u00e7\u00e3o de vetores de teste. Pode ser controlado por comandos <code>NEXT</code> e <code>EXIT</code>.</li> </ul> <p>5. Conceitos Avan\u00e7ados</p> <p>Tipos Complexos e Padr\u00f5es IEEE</p> <ul> <li>Declara\u00e7\u00e3o de Tipos: O VHDL permite a cria\u00e7\u00e3o de novos tipos (escalares, enumerados, f\u00edsicos e compostos), sendo o tipo <code>RECORD</code> (registro) e <code>ARRAY</code> (vetor, incluindo multidimensional) particularmente \u00fateis.</li> <li>Vetor com Limites em Aberto (Unconstrained Array): Permite criar tipos de vetores cuja dimens\u00e3o \u00e9 definida apenas na declara\u00e7\u00e3o do objeto ou na chamada de um subprograma.</li> <li>Mem\u00f3rias: Mem\u00f3rias ROM e RAM s\u00e3o implementadas usando vetores compostos por elementos do tipo vetor, o que permite que a ferramenta de s\u00edntese infira e utilize blocos de mem\u00f3ria dedicados, se dispon\u00edveis na tecnologia alvo.</li> </ul> <p>Fun\u00e7\u00f5es de Resolu\u00e7\u00e3o</p> <p>Para que um sinal seja acionado por m\u00faltiplos controladores (como em um barramento), ele deve ser declarado com um tipo que inclua uma fun\u00e7\u00e3o de resolu\u00e7\u00e3o. Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por determinar o valor l\u00f3gico final do sinal em caso de conflito, com base no n\u00edvel de for\u00e7a e no valor l\u00f3gico de cada controlador (vide tipos <code>STD_LOGIC</code> do pacote IEEE 1164).</p> <p>Teste e Verifica\u00e7\u00e3o</p> <p>O VHDL fornece comandos e estruturas para criar entidades de teste completas:</p> <ul> <li><code>ASSERT</code>: Comando usado para notificar condi\u00e7\u00f5es ilegais durante a simula\u00e7\u00e3o. Se a condi\u00e7\u00e3o (o requisito correto) for falsa, uma mensagem \u00e9 exibida, com um n\u00edvel de gravidade (<code>FAILURE</code>, <code>ERROR</code>, <code>WARNING</code>, <code>NOTE</code>).</li> <li><code>REPORT</code>: Usado para relatar mensagens durante a simula\u00e7\u00e3o (dispon\u00edvel a partir do VHDL-1993).</li> <li>Comandos Pospostos (<code>POSTPONED</code>): Permitem que a execu\u00e7\u00e3o de comandos concorrentes (como <code>ASSERT</code> ou procedimentos) seja atrasada at\u00e9 que todas as itera\u00e7\u00f5es de \\(\\Delta\\) no instante atual da simula\u00e7\u00e3o tenham terminado, garantindo que a avalia\u00e7\u00e3o ocorra apenas com valores est\u00e1veis.</li> </ul> <p>Configura\u00e7\u00f5es</p> <p>As configura\u00e7\u00f5es gerenciam a hierarquia de um projeto, definindo os elos entre um componente solicitado em uma arquitetura e uma entidade de projeto espec\u00edfica.</p> <ul> <li>Especifica\u00e7\u00e3o de Configura\u00e7\u00e3o: Inserida na declara\u00e7\u00e3o da arquitetura.</li> <li>Declara\u00e7\u00e3o de Configura\u00e7\u00e3o: Uma unidade de projeto separada, permitindo que a configura\u00e7\u00e3o seja alterada sem recompilar as entidades que utilizam os componentes.</li> </ul> <p>Bibliotecas e Pacotes</p> <ul> <li>Bibliotecas (<code>LIBRARY</code>): Locais de armazenamento das unidades de projeto compiladas. <code>WORK</code> e <code>STD</code> s\u00e3o padr\u00e3o.</li> <li>Pacotes (<code>PACKAGE</code>): Usados para agrupar constantes, tipos, subprogramas e declara\u00e7\u00f5es de componentes, facilitando o reuso do c\u00f3digo. O acesso aos itens \u00e9 feito via cl\u00e1usula <code>USE</code>.</li> </ul> <p>A reusabilidade e modularidade s\u00e3o pilares do VHDL, permitindo a gest\u00e3o de projetos complexos atrav\u00e9s da hierarquia (top-down design) e do particionamento l\u00f3gico do c\u00f3digo em pacotes e entidades.</p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> <li>Curso VHDL - O C\u00f3digo da Eletr\u00f4nica</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/vhdl/v01-hdl0/","title":"Linguagem de Descri\u00e7\u00e3o de Hardware - HDL","text":"<p>Uma linguagem de descri\u00e7\u00e3o de hardware (Hardware Description Language - HDL) \u00e9 uma linguagem de computador especializada usada para descrever a estrutura e o comportamento de circuitos eletr\u00f4nicos e, mais comumente, circuitos l\u00f3gicos digitais.</p> <p>Uma linguagem de descri\u00e7\u00e3o de hardware descreve o que um hardware faz e como:</p> <ul> <li>Modelar</li> <li>Representar</li> <li>Simular</li> </ul> <p>Existem v\u00e1rias linguagens de descri\u00e7\u00e3o de hardware. As duas principais s\u00e3o:</p> <ul> <li>VHDL</li> <li>SystemVerilog</li> </ul> <p>VHDL</p> <p>O nome VHDL \u00e9 um acr\u00f4nimo de VHSIC Hardware Description Language. J\u00e1 o termo VHSIC \u00e9 o acr\u00f4nimo de Very High Speed Integrated Circuit. Assim podemos traduzir livremente o nome VHDL como \"linguagem de descri\u00e7\u00e3o de hardware para circuitos integrados de velocidade muito alta\".</p> <p>A linguagem VHDL foi originalmente desenvolvida por empresas contratadas pelo governo americano e agora \u00e9 um padr\u00e3o requerido por todos os ASICs projetados para o ex\u00e9rcito americano.</p> <p>1981: DoD (Department of Defense) patrocina o 1\u00ba encontro de especialistas com o objetivo de discutir m\u00e9todos para a descri\u00e7\u00e3o de circuitos.</p> <p>1983: DoD define os requisitos de uma linguagem padr\u00e3o e firma contrato com IBM, Texas e Intermetrics com objetivo de desenvolvimento da linguagem e programas.</p> <p>1985: Apresenta\u00e7\u00e3o da vers\u00e3o 7.2 com direitos autorais do manual transferidos para o IEEE \u2013 Institute of Electrical and Electronic Engineer - Incumb\u00eancias do IEEE:     - Definir um padr\u00e3o para a linguagem     - Manter futuros desenvolvimentos (novas vers\u00f5es etc.)</p> <p>1987: Ap\u00f3s revis\u00f5es propostas por acad\u00eamicos, representantes de ind\u00fastrias e o governo dos Estados Unidos, foi definido o padr\u00e3o IEEE 1076-1987.</p> <p>As vers\u00f5es mais utilizadas s\u00e3o as definidas em 1993 e 2008, junto com seus pacotes.</p> <p>Os pacotes tem o objetivo de adicionar facilidades \u00e0 linguagem, como:</p> <ul> <li>IEEE 1164: Pacote std_logic_1164</li> <li>IEEE 1076.3: Pacotes numeric_bit e numeric_std</li> </ul> <p>Todo arquivo VHDL requer ao menos duas estruturas:</p> <ul> <li>Entidade (entity)<ul> <li>Define os aspectos externos da fun\u00e7\u00e3o VHDL, isto \u00e9, os nomes das entradas e sa\u00eddas e o nome da fun\u00e7\u00e3o.</li> </ul> </li> <li>Arquitetura (architecture)<ul> <li>Define aspectos internos, funcionamento e rela\u00e7\u00e3o entre os sinais internos e declarados na entidade.</li> </ul> </li> </ul> <p>Exemplo</p> <p>Circuito combinacional simples:</p> <p></p> VHDL<pre><code>library IEEE;\nuse IEEE.std_logic_1164.all;\n\nentity circuito is\n    PORT( a,b,c: IN std_logic; s: OUT std_logic );\nend circuito;\n\narchitecture main of circuito is\nbegin\n    s &lt;= (a and b) or c;\nend main;\n</code></pre> <p>Vantagem do VHDL em rela\u00e7\u00e3o ao Esquem\u00e1tico</p> <ul> <li>Projeto independente da tecnologia;</li> <li>Pode-se utilizar a descri\u00e7\u00e3o do projeto em v\u00e1rios tipos de plataforma, de um simulador para outro;</li> <li>Pode-se utilizar um projeto em VHDL em diferentes projetos;</li> <li>Permite, atrav\u00e9s de simula\u00e7\u00e3o, verificar o comportamento do sistema digital;</li> <li>Facilidade na atualiza\u00e7\u00e3o dos projetos;</li> <li>Reduz tempo de projeto e custo;</li> <li>O objetivo do projeto fica mais claro do que na representa\u00e7\u00e3o por esquem\u00e1ticos;</li> <li>O volume de documenta\u00e7\u00e3o diminui, j\u00e1 que um c\u00f3digo bem comentado em VHDL substitui com vantagens o esquem\u00e1tico e a descri\u00e7\u00e3o funcional do sistema;</li> </ul> <p>Aspectos da linguagem</p> <ol> <li>Suporta diversos n\u00edveis de hierarquia: uma descri\u00e7\u00e3o pode ser um conjunto de descri\u00e7\u00f5es interligadas.</li> <li>Estilo de descri\u00e7\u00e3o:</li> <li>Diversas maneiras de descrever um circuito</li> <li>N\u00edveis de abstra\u00e7\u00e3o: comportamental, express\u00f5es l\u00f3gicas, redes de liga\u00e7\u00e3o;</li> <li>Linguagem concorrente</li> <li>Ordem dos comandos n\u00e3o importa;</li> <li>Mudan\u00e7a de valor em um sinal acarreta a execu\u00e7\u00e3o de todos os comandos envolvidos.</li> <li>Comandos sequenciais:</li> <li>Somente em regi\u00f5es delimitadas no c\u00f3digo, subprogramas e processos.</li> </ol> <p>Aspectos gerais da linguagem</p> <p>Hierarquia</p> <p>Suporta diversos n\u00edveis de hierarquia, sendo que a descri\u00e7\u00e3o pode ser a interliga\u00e7\u00e3o de um conjunto de descri\u00e7\u00f5es.</p> <p></p> <p>Estilo de descri\u00e7\u00e3o</p> <p>Um circuito pode ser descrito de diversas maneiras, com diferentes n\u00edveis de abstra\u00e7\u00e3o, entre eles comportamental, por express\u00f5es l\u00f3gicas e por redes de liga\u00e7\u00e3o.</p> comportamental<pre><code>if a = b then\n    equals &lt;= '1';\nelse\n    equals &lt;= '0';\nend if;\n</code></pre> express\u00f5es l\u00f3gicas<pre><code>equals &lt;= '1' when (a = b) else '0';\n</code></pre> redes de liga\u00e7\u00e3o (estrutural)<pre><code>U0: xnor port map (a(0), b(0), x(0));\nU1: xnor port map (a(1), b(1), x(1));\nU2: xnor port map (a(2), b(2), x(2));\nU3: xnor port map (a(3), b(3), x(3));\nU4: and4 port map (x(0), x(1), x(2), x(3), equals);\n</code></pre> <p>No estilo misto, os estilos mostrados acima s\u00e3o usados em um mesmo c\u00f3digo.</p> <p>Concorr\u00eancia</p> <p>Na concorr\u00eancia, a ordem dos comandos n\u00e3o importa, pois descrevem partes de um circuito, e uma mudan\u00e7a de valor em um sinal, acarreta a execu\u00e7\u00e3o de todos os comandos envolvidos.</p> <pre><code>x &lt;= a and b;\ny &lt;= c or x;\n</code></pre> <pre><code>y &lt;= c or x;\nx &lt;= a and b;\n</code></pre> <p>Assim, o resultado para os dois c\u00f3digos acima \u00e9 o mesmo, pois no circuito sintetizado, tudo acontece ao mesmo tempo.</p> <p>Comandos sequenciais</p> <p>Comandos sequenciais, como acontece em linguagens de programa\u00e7\u00e3o mais convencionais, podem ser declaradas somente em uma regi\u00e3o espec\u00edfica, subprogramas e processos, e delimitada do c\u00f3digo. Cada regi\u00e3o \u00e9 executada de forma concorrente \u00e0s demais.</p> <p></p> <p>S\u00edntese de circuitos</p> <p>A linguagem VHDL est\u00e1 voltada para o projeto e documenta\u00e7\u00e3o de circuitos digitais, ent\u00e3o n\u00e3o necessariamente a linguagem foi criada para s\u00edntese de circuitos. Assim, nem todo c\u00f3digo e nem toda constru\u00e7\u00e3o em HDL pode ser sintetizada em circuitos l\u00f3gicos.</p> <p>Nos circuitos digitais isso se deve a uma falta de correspond\u00eancia da descri\u00e7\u00e3o com o circuito digital real, a impossibilidade da s\u00edntese com precis\u00e3o, ou uma falta de detalhamento para uma s\u00edntese direta.</p> <p>Motivos da limita\u00e7\u00e3o:</p> <ul> <li>Falta de correspond\u00eancia entre: constru\u00e7\u00e3o x circuito real. A constru\u00e7\u00e3o do c\u00f3digo pode ser simulada, por\u00e9m n\u00e3o pode ser montado por n\u00e3o haver o correspondende componente real.</li> <li>Impossibilidade de s\u00edntese direta. Uma multiplica\u00e7\u00e3o de dois n\u00fameros reais, por exemplo, pode ser simulada, por\u00e9m a complexidade do circuito \u00e9 alta o suficiente para n\u00e3o poder ser montado, sintetizado.</li> </ul> <p>S\u00edntese da descri\u00e7\u00e3o</p> <ol> <li> <p>Elabora\u00e7\u00e3o da descri\u00e7\u00e3o e compila\u00e7\u00e3o.</p> </li> <li> <p>A mesma descri\u00e7\u00e3o \u00e9 interpretada por uma ferramenta de s\u00edntese que infere as estruturas necess\u00e1rias para um circuito que corresponda \u00e0 descri\u00e7\u00e3o.</p> </li> <li> <p>Verifica\u00e7\u00e3o de erros de sintaxe;</p> </li> <li> <p>Circuito n\u00edvel RTL (Register Transfer Level): n\u00e3o \u00e9 associado a nenhuma tecnologia,apenas \u00e0 l\u00f3gica digital;</p> </li> <li> <p>N\u00edvel de portas: portas l\u00f3gicas, somadores, comparadores etc. S\u00e3o componentes que existem no seu dispositivo de destino, por exemplo na sua FPGA ou no seu ASIC.</p> </li> <li> <p>Otimiza\u00e7\u00e3o: a depender do seu dispositivo final voc\u00ea pode escolher se quer uma velocidade maior ou uma \u00e1rea menor.</p> </li> </ol> <p></p> <p>Rede de Liga\u00e7\u00f5es</p> <p>O resultado dessa etapa \u00e9 um arquivo contendo uma rede de liga\u00e7\u00f5es de elementos b\u00e1sicos dispon\u00edveis na tecnologia do dispositivo empregado. Esse arquivo contendo a rede de liga\u00e7\u00f5es \u00e9 a base de dados para a ferramenta que realiza o posicionamento e a interliga\u00e7\u00e3o dos componentes, place and route.</p> <p>Uma nova simula\u00e7\u00e3o pode ser feita, agora com uma precis\u00e3o maior, envolvendo os tempos de atraso.</p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> <li>Curso VHDL - O C\u00f3digo da Eletr\u00f4nica</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/vhdl/v02-estrutura/","title":"02 - Estrutura, Objetos e Tipos de Dados","text":"<p>Aqui s\u00e3o apresentadas as bases da linguagem VHDL, essenciais para a descri\u00e7\u00e3o, simula\u00e7\u00e3o e s\u00edntese de circuitos digitais com os seus conceitos prim\u00e1rios que permitem aos projetistas e programadores come\u00e7ar a interagir com as ferramentas de desenvolvimento de circuitos.</p> <p>1. Entidade de Projeto (Design Entity)</p> <p>A abstra\u00e7\u00e3o fundamental de um circuito em VHDL \u00e9 a Entidade de Projeto (Design Entity). Uma entidade de projeto pode representar desde uma porta l\u00f3gica simples at\u00e9 um sistema completo, e \u00e9 estruturada em duas partes principais: a Declara\u00e7\u00e3o da Entidade e o Corpo da Arquitetura.</p> <p>1.1 Declara\u00e7\u00e3o da Entidade</p> <p>A Declara\u00e7\u00e3o da Entidade define a interface do circuito com o ambiente externo. Ela come\u00e7a com a palavra reservada <code>ENTITY</code>, seguida pelo nome que a identifica. Dentro da declara\u00e7\u00e3o, a cl\u00e1usula <code>PORT</code> \u00e9 utilizada para definir as portas de entrada e sa\u00edda, incluindo seu modo e tipo.</p> <p>Modos de Porta: Quatro modos s\u00e3o definidos para determinar a dire\u00e7\u00e3o e o comportamento de uma porta:</p> <ul> <li><code>IN</code>: Opera exclusivamente como entrada.</li> <li><code>OUT</code>: Opera como sa\u00edda. Uma caracter\u00edstica crucial \u00e9 que o valor apresentado na porta n\u00e3o pode ser lido (referenciado internamente) pela arquitetura.</li> <li><code>BUFFER</code>: Opera como sa\u00edda, mas, ao contr\u00e1rio de <code>OUT</code>, permite que o valor apresentado seja referenciado internamente pela arquitetura.</li> <li><code>INOUT</code>: Caracteriza uma porta bidirecional, ideal para modelar barramentos de dados.</li> </ul> <p>Gen\u00e9ricos (<code>GENERIC</code>): A cl\u00e1usula <code>GENERIC</code> permite a passagem de informa\u00e7\u00f5es est\u00e1ticas (como par\u00e2metros ou dimens\u00f5es) para a unidade de projeto. Internamente, esses par\u00e2metros s\u00e3o tratados como constantes.</p> <p>1.2 Corpo da Arquitetura</p> <p>O Corpo da Arquitetura especifica a l\u00f3gica interna e as rela\u00e7\u00f5es entre as entradas e sa\u00eddas da entidade. Inicia-se com a palavra reservada <code>ARCHITECTURE</code>, seguida por um nome identificador e o nome da entidade associada. O identificador permite que uma mesma declara\u00e7\u00e3o de entidade tenha m\u00faltiplas arquiteturas, cada par (declara\u00e7\u00e3o-arquitetura) representando uma entidade distinta com a mesma interface.</p> <p>A regi\u00e3o anterior ao <code>BEGIN</code> da arquitetura \u00e9 reservada para declara\u00e7\u00f5es de sinais, constantes, subprogramas e a identifica\u00e7\u00e3o de componentes externos. Os comandos concorrentes que descrevem o comportamento do circuito s\u00e3o posicionados entre as palavras reservadas <code>BEGIN</code> e <code>END</code>.</p> <p>2. Classes de Objetos</p> <p>Objetos s\u00e3o elementos da linguagem utilizados para armazenar valores. O VHDL define quatro classes principais de objetos:</p> <ol> <li><code>CONSTANT</code> (Constante): Possui um valor est\u00e1tico e imut\u00e1vel.</li> <li><code>VARIABLE</code> (Vari\u00e1vel): Seu valor pode ser alterado apenas em regi\u00f5es de c\u00f3digo sequencial. A atribui\u00e7\u00e3o de valor \u00e9 feita com o delimitador <code>:=</code>.</li> <li><code>SIGNAL</code> (Sinal): Seu valor pode ser alterado em regi\u00f5es de c\u00f3digo concorrente ou sequencial. A atribui\u00e7\u00e3o de valor \u00e9 feita com o delimitador <code>&lt;=</code>. No VHDL, a atribui\u00e7\u00e3o de valor a um sinal ocorre ap\u00f3s um pequeno intervalo de tempo (delta delay, \\(\\Delta\\)) na itera\u00e7\u00e3o dos comandos concorrentes.</li> <li><code>FILE</code> (Arquivo): Objeto associado \u00e0 cria\u00e7\u00e3o e manipula\u00e7\u00e3o de arquivos (abordado com mais profundidade no Cap\u00edtulo 13).</li> </ol> <p>A sintaxe de declara\u00e7\u00e3o para <code>CONSTANT</code>, <code>VARIABLE</code> e <code>SIGNAL</code> \u00e9 similar, exigindo a palavra reservada da classe, o nome do objeto, o tipo, e, opcionalmente, um valor inicial.</p> <p>3. Tipos</p> <p>Um tipo define o conjunto de valores que um objeto pode assumir e o conjunto de opera\u00e7\u00f5es permitidas. \u00c9 fundamental que todo objeto seja declarado com um tipo definido. A transfer\u00eancia direta de valores entre objetos de tipos diferentes n\u00e3o \u00e9 permitida sem uma opera\u00e7\u00e3o de convers\u00e3o expl\u00edcita.</p> <p>3.1 Tipos Escaladores Predefinidos</p> <p>Tipos escalares s\u00e3o ordenados e representam um \u00fanico valor, sendo essenciais para opera\u00e7\u00f5es de compara\u00e7\u00e3o. Os principais tipos predefinidos no pacote padr\u00e3o incluem:</p> <ul> <li><code>BIT</code>: Pode assumir apenas '0' ou '1'.</li> <li><code>BOOLEAN</code>: Assume <code>FALSE</code> ou <code>TRUE</code>.</li> <li><code>CHARACTER</code>: Caracteres ASCII (ou IS08859-1 na vers\u00e3o VHDL-1993).</li> <li><code>INTEGER</code>: Representa n\u00fameros inteiros. Por padr\u00e3o, pode abranger uma ampla faixa de valores, mas \u00e9 recomendado especificar limites (<code>RANGE</code>) para garantir um uso eficiente dos recursos na s\u00edntese de circuitos. Os subtipos <code>NATURAL</code> (inteiros n\u00e3o negativos) e <code>POSITIVE</code> (inteiros positivos) s\u00e3o derivados de <code>INTEGER</code>.</li> <li><code>REAL</code>: N\u00fameros de ponto flutuante. Geralmente n\u00e3o \u00e9 suportado por ferramentas de s\u00edntese devido \u00e0 complexidade da implementa\u00e7\u00e3o.</li> <li><code>TIME</code>: Tipo f\u00edsico usado para representar unidades de tempo (ex.: <code>ns</code>, <code>ms</code>, <code>sec</code>). \u00c9 ignorado pelas ferramentas de s\u00edntese.</li> </ul> <p>As atribui\u00e7\u00e3o de valores a sinais dos tipos <code>INTEGER</code> e <code>REAL</code>, incluindo diferentes bases num\u00e9ricas e faixas de valores.</p> <pre><code>ENTITY int_real IS\nPORT (\n        c11, c12      : OUT INTEGER RANGE    0 TO 31;\n        c13, c14      : OUT INTEGER RANGE   31 DOWNTO 0;\n        c15, c16, c17 : OUT INTEGER RANGE  -15 TO 15;\n        cr1, cr2      : OUT REAL    RANGE  0.0 TO 31.0;\n        cr3, cr4      : OUT REAL    RANGE 31.0 DOWNTO 0.0\n     );\nEND int_real;\n\nARCHITECTURE teste OF int_real IS\n    CONSTANT i1 : INTEGER := 11;\n    CONSTANT i2 : INTEGER := 10#11#;\n    CONSTANT i3 : INTEGER := 2#1011#;\n    CONSTANT i4 : INTEGER := 2#01_01_1#;\n    CONSTANT i5 : INTEGER := 5#21#;\n    CONSTANT i6 : NATURAL := 8#13#;\n    CONSTANT i7 : POSITIVE := 16#B#;\n    CONSTANT r1 : REAL := 11.0;\n    CONSTANT r2 : REAL := 1.1E01;\n    CONSTANT r3 : REAL := 2#1011.0#;\n    CONSTANT r4 : REAL := 8#13.0#E0;\n    CONSTANT r5 : REAL := 16#B.0#;\nBEGIN\n    c11 &lt;= i1; c12 &lt;= i2; c13 &lt;= i3; c14 &lt;= i4; c15 &lt;= i5; c16 &lt;= i6; c17 &lt;= i7;\n    cr1 &lt;= r1; cr2 &lt;= r2; cr3 &lt;= r3; cr4 &lt;= r4; cr5 &lt;= r5;\nEND teste;\n</code></pre> <p>Este exemplo demonstra a import\u00e2ncia da rigorosa defini\u00e7\u00e3o de faixas de valores (<code>RANGE</code>). Em descri\u00e7\u00f5es voltadas para s\u00edntese, essas restri\u00e7\u00f5es s\u00e3o vitais, pois comunicam \u00e0 ferramenta o n\u00famero m\u00ednimo de bits necess\u00e1rios para representar todos os valores que o objeto pode assumir, otimizando o uso de recursos de hardware.</p> <p>A inclus\u00e3o de constantes do tipo <code>REAL</code> inviabiliza a s\u00edntese direta da descri\u00e7\u00e3o, uma vez que exigiria estruturas complexas de ponto flutuante. Por outro lado, a nota\u00e7\u00e3o para bases num\u00e9ricas diferentes da base 10, como <code>2#1011#</code> ou <code>16#B#</code>, \u00e9 bem ilustrada, sendo a nota\u00e7\u00e3o <code>base#valor#</code> a forma padronizada.</p> <p>3.2 Tipos Compostos (<code>ARRAY</code>)</p> <p>O tipo composto fundamental introduzido \u00e9 o vetor (<code>ARRAY</code>). O VHDL predefine:</p> <ul> <li><code>BIT_VECTOR</code>: Um vetor cujos elementos s\u00e3o do tipo <code>BIT</code>.</li> <li><code>STRING</code>: Um vetor cujos elementos s\u00e3o do tipo <code>CHARACTER</code>.</li> </ul> <p>A ordem dos \u00edndices em um vetor \u00e9 definida usando <code>TO</code> (ascendente) ou <code>DOWNTO</code> (descendente).</p> <p>Agregados (Aggregates): Permitem atribuir valores a vetores por posi\u00e7\u00e3o ou por nome (usando a nota\u00e7\u00e3o <code>=&gt;</code>), sendo a palavra reservada <code>OTHERS</code> v\u00e1lida para cobrir elementos n\u00e3o especificados.</p> <p>Este c\u00f3digo demonstra a atribui\u00e7\u00e3o de valores a vetores de bits, a concatena\u00e7\u00e3o e a utiliza\u00e7\u00e3o de literais em diferentes bases, como hexadecimal.</p> <pre><code>ENTITY std_a IS\n    PORT( s1, s2, s3, s4, s5 : OUT BIT_VECTOR (4 DOWNTO 0) );\nEND std_a;\n\nARCHITECTURE teste OF std_a IS\n    CONSTANT c1 : BIT_VECTOR(4 DOWNTO 0) := \"01011\"; -- constante\n    CONSTANT zero : BIT := '0';\n    CONSTANT um : BIT := '1';\nBEGIN\n    s1 &lt;= c1;\n    s2 &lt;= \"01011\";\n    s3 &lt;= B\"010_11\";\n    s4 &lt;= zero &amp; x\"B\";                               -- x\"B\" : nota\u00e7\u00e3o hexadecimal\n    s5(4 DOWNTO 3) &lt;= \"01\";                          -- \"01xxx\"\n    s5(2 DOWNTO 0) &lt;= zero &amp; um &amp; zero;              -- \"01010\"\nEND teste;\n</code></pre> <p>O c\u00f3digo seguinte, ilustra o emprego do tipo <code>STRING</code> e a concatena\u00e7\u00e3o de sinais desse tipo, demonstrando a manipula\u00e7\u00e3o de dados de texto na arquitetura.</p> <pre><code>ENTITY hs_ta1 IS\n    PORT( c, d : OUT STRING(1 TO 9) );\nEND hs_ta1;\n\nARCHITECTURE teste OF hs_ta1 IS\n    SIGNAL x : STRING(1 TO 3) := \"Alo\";   -- sinais que poderiam ser CONSTANT\n    SIGNAL y : STRING(1 TO 5) := \"mundo\"; -- no entanto, foram declarados como SIGNAL\nBEGIN\n    c &lt;= x &amp; \" \" &amp; y;         -- concatena x, um espa\u00e7o e y: \"Alo mundo\"\n    d &lt;= x(1 TO 2) &amp; ' ' &amp; y; -- concatena parte de x, um espa\u00e7o e y: \"Al mundo\"\nEND teste;\n</code></pre> <p>O tipo <code>STRING</code> \u00e9 um vetor (<code>ARRAY</code>) predefinido de elementos do tipo <code>CHARACTER</code>. A concatena\u00e7\u00e3o (<code>&amp;</code>) \u00e9 utilizada para unir vetores e elementos de forma sequencial, resultando em uma string maior.</p> <p>Enquanto <code>SIGNAL</code> \u00e9 um objeto cujo valor pode ser alterado e \u00e9 empregado em regi\u00f5es concorrentes, <code>CONSTANT</code> possui um valor est\u00e1tico. Neste caso, como os valores de <code>x</code> e <code>y</code> n\u00e3o s\u00e3o alterados, a declara\u00e7\u00e3o como <code>CONSTANT</code> seria semanticamente mais apropriada e poderia auxiliar na otimiza\u00e7\u00e3o da descri\u00e7\u00e3o pelo compilador/sintetizador, embora o c\u00f3digo ainda funcione corretamente com <code>SIGNAL</code>.</p> <p>Este c\u00f3digo exemplifica o uso de agregados (<code>aggregate</code>) para atribuir valores a vetores (<code>BIT_VECTOR</code>), empregando tanto a nota\u00e7\u00e3o posicional quanto a nomeada, e ilustrando a cl\u00e1usula <code>OTHERS</code>.</p> <pre><code>ENTITY std_a1 IS\n    PORT( s2, s3, s4, s5 : OUT BIT_VECTOR(4 DOWNTO 0) );\nEND std_a1;\n\nARCHITECTURE teste OF std_a1 IS\n    CONSTANT zero : BIT := '0';\n    CONSTANT um   : BIT := '1';\nBEGIN\n    s2 &lt;= ('0', '0', '0', '1', '0');                  -- \"00010\"\n    s3 &lt;= (1=&gt;'1', 0=&gt;'1', OTHERS=&gt;'0');              -- \"00011\"\n    s4 &lt;= (zero, '0', um OR '0', '0', '0');           -- \"00100\"\n    s5 &lt;= (4 DOWNTO 3 =&gt;'0', 1=&gt;'0', OTHERS=&gt;'1');    -- \"00101\"\nEND teste;\n</code></pre> <p>O uso de agregados, como visto nas atribui\u00e7\u00f5es de <code>s3</code> e <code>s5</code>, \u00e9 uma t\u00e9cnica poderosa em VHDL para inicializar ou atribuir valores a tipos compostos, garantindo que todos os elementos sejam cobertos. Por exemplo, em <code>s5</code>, os bits nas posi\u00e7\u00f5es 4 e 3 recebem '0' (nota\u00e7\u00e3o de faixa discreta), a posi\u00e7\u00e3o 1 recebe '0', e todas as outras posi\u00e7\u00f5es (<code>OTHERS</code>) recebem '1'.</p> <p>3.3 Defini\u00e7\u00e3o de Novos Tipos e Subtipos</p> <p>\u00c9 poss\u00edvel criar novos tipos (enumerados, f\u00edsicos ou compostos) e subtipos. Um Subtipo restringe a faixa de valores de um tipo existente, mantendo a compatibilidade para troca de valores entre objetos do tipo base e do subtipo.</p> <p>4. Operadores</p> <p>Os operadores s\u00e3o essenciais para construir express\u00f5es e definir a l\u00f3gica do circuito. Eles s\u00e3o agrupados em classes que determinam sua ordem de preced\u00eancia. Em geral, os operandos em uma opera\u00e7\u00e3o devem ser do mesmo tipo.</p> <p>As classes de operadores, listadas por ordem crescente de preced\u00eancia, s\u00e3o:</p> Preced\u00eancia Classe Operadores Menor L\u00f3gicos <code>and</code>, <code>or</code>, <code>nand</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code> Relacionais <code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> Deslocamento <code>sll</code>, <code>srl</code>, <code>sla</code>, <code>sra</code>, <code>rol</code>, <code>ror</code> (Adicionados na VHDL-1993) Adi\u00e7\u00e3o <code>+</code>, <code>-</code>, <code>&amp;</code> (Concatena\u00e7\u00e3o) Sinal <code>+</code>, <code>-</code> (Identidade e Nega\u00e7\u00e3o) Multiplica\u00e7\u00e3o <code>*</code>, <code>/</code>, <code>mod</code>, <code>rem</code> Maior Diversos <code>**</code> (Exponencia\u00e7\u00e3o), <code>abs</code> (Valor Absoluto), <code>not</code> <p>Operadores L\u00f3gicos: Aplic\u00e1veis a tipos <code>BIT</code>, <code>BOOLEAN</code> e vetores desses tipos (como <code>BIT_VECTOR</code>). O <code>not</code> possui a maior preced\u00eancia.</p> <p>Operadores Relacionais: Testam igualdade (<code>=</code>), desigualdade (<code>/=</code>) e ordena\u00e7\u00e3o (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>). O resultado \u00e9 sempre um valor <code>BOOLEAN</code>.</p> <p>Operador de Concatena\u00e7\u00e3o (<code>&amp;</code>): Permite unir vetores ou elementos do mesmo tipo, resultando em um novo vetor cujo tamanho \u00e9 a soma dos operandos.</p> <p>O c\u00f3digo que segue exemplifica a necessidade de par\u00eanteses em express\u00f5es l\u00f3gicas para evitar ambiguidade ou erros de compila\u00e7\u00e3o, uma vez que <code>AND</code>, <code>OR</code>, <code>NAND</code>, <code>NOR</code>, <code>XOR</code> e <code>XNOR</code> t\u00eam a mesma preced\u00eancia, sendo apenas o <code>NOT</code> de preced\u00eancia mais elevada.</p> <pre><code>ENTITY std_xa1 IS\n    PORT( a, b, c, d :         IN    BIT;\n          x1, x2, x3, x4, x5 : OUT   BIT   );\nEND std_xa1;\n\nARCHITECTURE exemplo OF std_xa1 IS\nBEGIN\n    x1 &lt;= a OR NOT b;                -- Certo: operador NOT tem preced\u00eancia mais elevada\n    x2 &lt;= a AND b AND c;             -- Certo: operadores iguais\n -- x3 &lt;= a AND b OR c;              -- Errado: express\u00e3o amb\u00edgua x3=(a.b)+c ou x3=a.(b+c) ?\n    x3 &lt;= (a AND b) OR c;            -- Certo: empregando par\u00eantesis\n -- x4 &lt;= a AND b OR c AND d;        -- Errado: express\u00e3o amb\u00edgua, operadores com mesma preced\u00eancia\n    x4 &lt;= (a AND b) OR (c AND d);    -- Certo: x4 = a.b + c.d\n -- x5 &lt;= a NAND b NAND c;           -- Errado: operadores com nega\u00e7\u00e3o necessitam par\u00eantesis\n    x5 &lt;= (a NAND b) NAND c;         -- Certo: operador com nega\u00e7\u00e3o entre par\u00eantesis\nEND exemplo;\n</code></pre> <p>Este pr\u00f3ximo exemplo demonstra o uso do operador de concatena\u00e7\u00e3o (<code>&amp;</code>) e o operador de soma (<code>+</code>), que, no pacote padr\u00e3o, s\u00e3o definidos unicamente para tipos num\u00e9ricos, com o tipo <code>BIT_VECTOR</code> utilizando concatena\u00e7\u00e3o para combinar vetores.</p> <pre><code>ENTITY std_xc IS\n    PORT( bv_a, bv_b   : IN  BIT_VECTOR(1 DOWNTO 0);\n          int_a, int_b : IN  INTEGER RANGE -32 TO 31;\n          bv_c, bv_d   : OUT BIT_VECTOR(3 DOWNTO 0);\n          int_c        : OUT INTEGER RANGE -64 TO 63 );\nEND std_xc;\n\nARCHITECTURE teste OF std_xc IS\nBEGIN\n    bv_c  &lt;=  bv_a  &amp; bv_b;\n    bv_d  &lt;=  bv_a  &amp; '1' &amp; '0';\n    int_c &lt;= -int_a + int_b;\nEND teste;\n</code></pre> <p>Este c\u00f3digo ilustra a utiliza\u00e7\u00e3o dos operadores de multiplica\u00e7\u00e3o, divis\u00e3o (<code>*</code>, <code>/</code>), e os operadores de resto (<code>REM</code>, <code>MOD</code>), definidos para tipos inteiros e reais. Destaca-se a diferen\u00e7a no sinal do resultado entre <code>REM</code> (sinal do operando esquerdo, \\(L\\)) e <code>MOD</code> (sinal do operando direito, \\(R\\)).</p> <pre><code>ENTITY std_xd IS\n    PORT( l, r             : IN  INTEGER RANGE -32 TO 31;\n          l_mul_r, l_div_r : OUT INTEGER RANGE -32 TO 31;\n          l_rem_r, l_mod_r : OUT INTEGER RANGE -32 TO 31  );\nEND std_xd;\n\nARCHITECTURE teste OF std_xd IS\nBEGIN\n    l_mul_r &lt;= l * r;\n    l_div_r &lt;= l / r;\n    l_rem_r &lt;= l REM r; -- l = (l/r) * r + (l rem r)\n    l_mod_r &lt;= l MOD r; -- l = r * n + (l mod r) sendo n um valor inteiro\nEND teste;\n</code></pre> <p>A Figura 1 ilustra o uso de alguns dos elementos apresentados, como a estrutura da entidade e da arquitetura, a declara\u00e7\u00e3o dos pinos de acesso ao circuito, declara\u00e7\u00e3o de sinal e operadores l\u00f3gicos. </p> Figura 1: Exemplo de circuito e descri\u00e7\u00e3o em VHDL Fonte: Autor <p>Exerc\u00edcios</p> <p>1) Escreva o c\u00f3digo em VHDL para uma entidade que apresenta quatro entradas (\\(a,b,c,d\\)) e quatro sa\u00eddas (\\(x,y,z,w\\)), sendo todas elas do tipo <code>bit</code>. As express\u00f5es que relacional as entradas com as sa\u00eddas s\u00e3o as seguintes: </p> <ul> <li>\\(x = a + \\overline{b}\\)</li> <li>\\(y = a + b.\\overline{c} + d\\)</li> <li>\\(z = (a + \\overline{b}).(c + \\overline{d})\\)</li> <li>\\(w = (a + \\overline{b}) + \\overline{(c + a.d)}\\)</li> </ul> <p>2) Considerando a seguinte descri\u00e7\u00e3o:</p> <pre><code>ENTITY ex2 IS\n    PORT(\n            a, b: OUT BIT_VECTOR(2 DOWNTO 0);\n            c, d: OUT BIT_VECTOR(0 TO 2)\n        );\nEND ENTITY;\n\nARCHITECTURE teste OF ex2 IS\n    CONSTANT x: BIT_VECTOR(0 TO 7) := B\"11011001\";\n    SIGNAL   y: BIT_VECTOR(3 DOWNTO 0);\nBEGIN\n    a &lt;= x(1 TO 3);\n    b &lt;= y(3 DOWNTO 1);\n    c &lt;= x(5 DOWNTO 7);\n    d &lt;= x(2 DOWNTO 0);\n    y &lt;= x(2 TO 5);\nEND ARCHITECTURE;\n</code></pre> <p>Determine, sem aux\u00edlio de um simulador, qual \u00e9 o valor de cada porta de sa\u00edda. Note que todos os comandos s\u00e3o concorrentes, e, portanto, a ordem das linhas do c\u00f3digo n\u00e3o importa. </p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/vhdl/v02-vhdl-intro/","title":"Inicia\u00e7\u00e3o ao VHDL","text":"<p>A estrutura da descri\u00e7\u00e3o de hardware em VHDL consistem basicamente de tr\u00eas declara\u00e7\u00f5es: </p> <ul> <li>Bibliotecas e pacotes</li> <li>Entidade</li> <li>Arquitetura</li> </ul> <p>As bibliotecas e pacotes s\u00e3o padr\u00f5es definidos em norma para auxiliar na descri\u00e7\u00e3o de circuitos.</p> <p>A entidade \u00e9 a declara\u00e7\u00e3o de interface, onde s\u00e3o declaradas as entradas, sa\u00eddas, buffers e constantes utilizadas pelo circuito descrito.</p> <p>A arquitetura \u00e9 a descri\u00e7\u00e3o comportamental do circuito, em que s\u00e3o utilizadas express\u00f5es l\u00f3gicas, redes de liga\u00e7\u00e3o em comandos concorrentes ou ainda blocos de organiza\u00e7\u00e3o e processos sequenciais.</p> <p>Segue a estrutura b\u00e1sica de uma descri\u00e7\u00e3o em VHDL.</p> nome_da_entidade.vhdl<pre><code>-- --------------------------------------------------------\n--     Cabe\u00e7alho de c\u00f3digo em coment\u00e1rios de linha\n-- Sistemas Digitais Program\u00e1veis - 2025-2\n-- C\u00f3digo: Estrutura b\u00e1sica do c\u00f3digo em VHDL\n-- Autor: Jos\u00e9 W. R. Pereira\n-- Data: 2025-09-08\n-- --------------------------------------------------------\n\n-- Bibliotecas e Pacotes\n\n-- Entidade: interface de entradas e sa\u00eddas\nentity nome_da_entidade is\n    port(\n          -- variavel: direcao_de_dados tipo_de_dado;\n          -- variavel: direcao_de_dados tipo_de_dado\n        );\nend entity nome_da_entidade;\n\n\n-- Arquitetura: descri\u00e7\u00e3o de comportamento\narchitecture main of nome_da_entidade is\n-- declara\u00e7\u00e3o de objetos\nbegin\n    -- descri\u00e7\u00e3o do comportamento\nend architecture main;\n</code></pre> <p>\u00c9 uma boa pr\u00e1tica a inser\u00e7\u00e3o de um cabe\u00e7alho contendo informa\u00e7\u00f5es gerais sobre o c\u00f3digo. </p> <p>Segue o c\u00f3digo de uma porta l\u00f3gica E.</p> porta E<pre><code>-- --------------------------------------------------------\n-- Sistemas Digitais Program\u00e1veis - 2025-2\n-- C\u00f3digo: Porta l\u00f3gica E (AND)\n-- Autor: Jos\u00e9 W. R. Pereira\n-- Data: 2025-09-08\n-- --------------------------------------------------------\n\n-- Bibliotecas e Pacotes\n\n-- Entidade: interface de entradas e sa\u00eddas\nentity portaE is port( a, b: in bit; y: out bit );\nend entity portaE;\n\n\n-- Arquitetura: descri\u00e7\u00e3o de comportamento\narchitecture main of portaE is\nbegin\n    y &lt;= a and b;\nend architecture main;\n</code></pre> <p>Segue outro exemplo, agora para um somador de 4 bits. Note uma forma de realizar a declara\u00e7\u00e3o do vetor de bits para as entradas e sa\u00edda. </p> somador4bits<pre><code>-- --------------------------------------------------------\n-- Sistemas Digitais Program\u00e1veis - 2025-2\n-- C\u00f3digo: Somador de 4 bits\n-- Autor: Jos\u00e9 W. R. Pereira\n-- Data: 2025-09-08\n-- --------------------------------------------------------\n\n-- Bibliotecas e Pacotes\n\n-- Entidade\nentity somador4bits is\n    port(\n            a,b: in integer range 0 to 15;  -- declara\u00e7\u00e3o de entradas de 4 bits\n            y: out integer range 0 to 15    -- declara\u00e7\u00e3o de sa\u00edda de 4 bits\n        );\nend entity somador4bits;\n\n-- Arquitetura\narchitecture main of somador4bits is\nbegin\n    y &lt;= a + b;\nend architecture main;\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"digitais/Tecnologia/fpga/vhdl/v02-vhdl-intro/#interfaces","title":"Interfaces","text":"<p>S\u00e3o quatro os tipos de declara\u00e7\u00e3o de dire\u00e7\u00e3o de dados poss\u00edveis:</p> <ul> <li>Entrada</li> <li>Sa\u00edda</li> <li>Buffer</li> <li>Entrada/Sa\u00edda</li> </ul> <p>Um est\u00edmulo, sinal, \u00e9 recebido pelo circuito que se descreve atrav\u00e9s das entradas. </p> <p>A sa\u00edda possui o sinal ou valor resultante do circuito descrito. Sendo que este sinal/valor n\u00e3o pode ser usado internamente.</p> <p>O buffer por sua vez, permite a utiliza\u00e7\u00e3o do seu sinal, tanto para a sa\u00edda quanto para utiliza\u00e7\u00e3o interna do bloco descrito. </p> <p>Quanto um pino de interface, pode em algum momento receber um sinal, e em outro momento produzir um sinal, deve ser declarado como Entrada/Sa\u00edda (<code>inout</code>);</p> <p>\u00c9 poss\u00edvel a declara\u00e7\u00e3o, do que em outras linguagens s\u00e3o chamadas de constantes, como mostrado na se\u00e7\u00e3o <code>generic</code>, antes da declara\u00e7\u00e3o do <code>port</code> na entidade. </p> interfaces.vhdl<pre><code>entity interfaces is\n  generic (\n              n: tipo := valor -- constante\n          );\n  port    (\n              a, b:     in      tipo1;  -- entradas\n              y1,y2:    out     tipo2;  -- sa\u00eddas (n\u00e3o podem ser lidas)\n              w:        buffer  tipo3;  -- sa\u00edda  (pode ser lida)\n              z1, z2:   inout   tipo4   -- entrada/sa\u00edda\n          );\nend entity interfaces;\n\n\narchitecture nome_arc of interfaces is\n\n-- Declara\u00e7\u00f5es\n-- Sinais\n-- Componentes\n-- Subprogramas\n-- Novos tipos\n-- outros\n\nbegin\n\n-- Comandos concorrentes\n\nend architecture nome_arc;\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"digitais/Tecnologia/fpga/vhdl/v02-vhdl-intro/#classes-de-objetos","title":"Classes de objetos","text":"<p>VHDL possui quatro classes de objetos, que s\u00e3o elementos que armazenam valores.</p> Classe de objetos<pre><code>-- CONSTANT - Valor fixo\nconstant nome_da_constante : tipo := valor;\n\n-- SIGNAL - Meio f\u00edsico onde os dados podem transitar\nsignal nome_do_signal : tipo := valor_inicial;\n\n-- VARIABLE - Usado somente em c\u00f3digo sequencial\nvariable nome_da_variable : tipo := valor_inicial;\n\n-- FILE - Para a cria\u00e7\u00e3o e leitura de arquivos\nfile nome_do_file : tipo;\n</code></pre> <p>Exemplo de uso de redes de liga\u00e7\u00e3o com a classe de objetos do tipo <code>signal</code>.</p> <p>Segue ilustra\u00e7\u00e3o de um diagrama de portas l\u00f3gicas equivalente a um circuito do tipo Flip flop tipo D.</p> <p>Est\u00e3o destacados os pinos de entradas e sa\u00eddas para declara\u00e7\u00e3o nos <code>PORTS</code>. </p> <p>As linhas de conex\u00e3o internas s\u00e3o nomeadas como um vetor a com os \u00edndices de 0 a 1.</p> <p></p> <p>Segue c\u00f3digo que descreve o circuito de Flip flop tipo D. </p> FF D<pre><code>-- --------------------------------------------------------\n-- Sistemas Digitais Program\u00e1veis - 2025-2\n-- C\u00f3digo: FF tipo D\n-- Autor: Jos\u00e9 W. R. Pereira\n-- Data: 2025-09-18\n-- --------------------------------------------------------\n\n-- Bibliotecas e Pacotes\n\n-- Entidade\nentity ffd is\n    port(\n            d, clk:     in      bit;\n            q, q_bar:   buffer  bit\n        );\nend entity;\n\n-- Arquitetura\narchitecture main of ffd is\n    signal a: bit_vector(0 to 1);\nbegin\n    a(0) &lt;= d nand clk;\n    a(1) &lt;= not d nand clk;\n    q    &lt;= a(0) nand qbar;\n    qbar &lt;= a(1) nand q;\nend architecture main;\n</code></pre> <p>Perceba que o paradigma que segue \u00e9 completamente distinto aos programas tradicionais, inclusive porque aqui temos a descri\u00e7\u00e3o do circuito, e n\u00e3o um algoritmo sequencial de execu\u00e7\u00e3o de uma m\u00e1quina de estados.</p> <p>Entre o <code>begin</code> e o <code>end</code> da arquitetura, os camandos s\u00e3o executados de forma concorrente. </p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"digitais/Tecnologia/fpga/vhdl/v02-vhdl-intro/#comandos-concorrentes","title":"Comandos concorrentes","text":"<p>1. when else</p> Estrutura When Else<pre><code>architecture behavioral of ent is\nbegin\n    signal_name &lt;=  expression_1 when condition_1 else\n                    expression_2 when condition_2 else\n                    expression_3;\nend architecture behavioral;\n</code></pre> <p></p> <p>Exemplo de implementa\u00e7\u00e3o de um mux de quatro entradas (D0..D3), duas sele\u00e7\u00f5es (S0,S1) e uma sa\u00edda (Y). </p> <p></p> MUX 4x1 com when else<pre><code>entity mux4x1 is \n    port(\n            D0, D1, D2, D3: in  bit;\n            S0, S1:         in  bit;\n            Y:              out bit\n        );\nend entity mux4x1;\n\n\narchitecture main of mux4x1 is \nsignal sel : bit_vector(1 downto 0) := \"00\";\nbegin\n    sel &lt;= S1 &amp; S0; -- Concatena\u00e7\u00e3o de bits\n\n    Y &lt;=    D0 when sel = \"00\" else\n            D1 when sel = \"01\" else\n            D2 when sel = \"10\" else\n            D3;\nend architecture main;\n</code></pre> <p>2. with select</p> Estrutura With Select<pre><code>architecture behavioral of ent is\nbegin\n    with sel select\n        signal_name &lt;=  expression_1 when value_1,\n                        expression_2 when value_2,\n                        expression_N when value_N,\n                        other_expression when others;\nend architecture behavioral;\n</code></pre> <p></p> <p>O mesmo exemplo anteriormente mostrado, de implementa\u00e7\u00e3o de um mux de quatro entradas, duas sele\u00e7\u00f5es e uma sa\u00edda. Note as diferen\u00e7as entre as formas de descri\u00e7\u00e3o.</p> <p></p> MUX 4x1 com with select<pre><code>entity mux4x1 is \n    port(\n            D0, D1, D2, D3: in  bit;\n            S0, S1:         in  bit;\n            Y:              out bit\n        );\nend entity mux4x1;\n\narchitecture main of mux4x1 is \n    signal sel : bit_vector(1 downto 0) := \"00\";\nbegin\n    with sel select\n        Y   &lt;=      D0 when \"00\",\n                    D1 when \"01\",\n                    D2 when \"10\",\n                    D3 when others;\nend architecture;\n</code></pre> <p>3. for generate</p> <p>A estrutura <code>for generate</code> tem como objetivo a replica\u00e7\u00e3o de circuitos e componentes. </p> for generate<pre><code>label: for parameter in range generate\n    -- concurrent statements\nend generate label;\n</code></pre> <p></p> for generate<pre><code>library ieee;\nuse ieee.std_logic_1164.all;\n\nentity xor_generate is\n    generic( n: natural := 8 );\n    port(   i: in std_logic_vector(1 to n); \n            o: out std_logic \n        );\nend entity xor_generate;\n\narchitecture main of xor_generate is\n    signal a : std_logic_vector(1 to n);\nbegin\n    o &lt;= n(n);\n    a(1) &lt;= i(1);\n    g1: for x in 2 to n generate\n        a(x) &lt;= i(x) xor a(x - 1);\n    end generate g1;\nend architecture main;\n</code></pre> <p>4. if generate</p> <p>O objetivo da estrutura <code>if generate</code> \u00e9 a replica\u00e7\u00e3o de circuito de forma condicionada.</p> if generate<pre><code>label: if condition generate\n    -- concurrent statements\nend generate label;\n</code></pre> <p></p> if generate<pre><code>library ieee;\nuse ieee.std_logic_1164.all;\n\nentity xor_generate_if is\n    generic( n: natural := 8 );\n    port(   i: in std_logic_vector(1 to n); \n            o: out std_logic \n        );\nend entity xor_generate_if;\n\narchitecture main of xor_generate_if is\n    signal a : std_logic_vector(1 to n);\nbegin\n    g1: for x in 1 to n-1 generate\n\n        -- Primeira porta\n        g2: if x = 1 generate\n            a(1) &lt;= i(1) xor i(2);\n        end generate g2;\n\n        -- \u00daltima porta\n        g3: if x = n-1 generate\n            o &lt;= i(x) xor a(n-2);\n        end generate g3;\n\n        -- Demais portas\n        g4: if (x &gt; 1) and (x &lt; n -1 ) generate\n            a(x) &lt;= i(x+1) xor a(x-1);\n        end generate g4;\n    end generate g1;\nend architecture main;\n</code></pre> <p>5. Block</p> <p>A estrutura do tipo <code>block</code> tem a fun\u00e7\u00e3o b\u00e1sica de organizar o c\u00f3digo, assim como usar express\u00f5es de guarda, e possui s\u00edntese limitada, tornando seu uso pouco frequente. </p> <p>6. Process</p> <p>A estrutura do tipo <code>process</code> \u00e9 respons\u00e1vel pela execu\u00e7\u00e3o de c\u00f3digo sequencial e s\u00edntese de circuitos sequenciais, bem como a produ\u00e7\u00e3o de scripts de testes de bancada (testbenches). </p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> <li>Curso VHDL - O C\u00f3digo da Eletr\u00f4nica</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"digitais/Tecnologia/fpga/vhdl/v03-concorrencia/","title":"03 - Concorr\u00eancia","text":"<p>A caracter\u00edstica definidora do VHDL \u00e9 a concorr\u00eancia: exceto em regi\u00f5es de c\u00f3digo sequencial (como processos ou subprogramas), todos os comandos em uma arquitetura s\u00e3o executados simultaneamente. A ordem na qual esses comandos s\u00e3o apresentados no c\u00f3digo \u00e9 irrelevante para o comportamento da descri\u00e7\u00e3o, espelhando a opera\u00e7\u00e3o conjunta dos elementos em um circuito digital.</p> <p>1. O Conceito Cr\u00edtico de Atraso Delta (\\(\\Delta\\))</p> <p>Para manter a integridade da simula\u00e7\u00e3o em um ambiente onde a execu\u00e7\u00e3o \u00e9 concorrente, o simulador VHDL emprega um mecanismo interno de coordena\u00e7\u00e3o temporal conhecido como atraso delta (\\(\\Delta\\)).</p> <p>O \\(\\Delta\\) \u00e9 um intervalo de tempo nulo (\\(\\Delta=0\\)). Quando um evento ocorre em um sinal (ou seja, seu valor muda), todos os comandos sens\u00edveis a esse sinal s\u00e3o avaliados. O resultado dessas avalia\u00e7\u00f5es \u00e9 agendado para transfer\u00eancia ao sinal de destino em \\(1\\Delta\\) de tempo. Uma vez que esta primeira itera\u00e7\u00e3o (\\(\\Delta\\)) \u00e9 conclu\u00edda, a nova condi\u00e7\u00e3o de sinal pode ativar novos comandos, repetindo o processo em sucessivas itera\u00e7\u00f5es (\\(2\\Delta, 3\\Delta, \\ldots\\)) at\u00e9 que o circuito atinja uma condi\u00e7\u00e3o est\u00e1vel, onde nenhuma nova mudan\u00e7a \u00e9 agendada.</p> <p>A rigidez deste mecanismo \u00e9 vital para garantir que a l\u00f3gica e o comportamento do circuito simulado sejam independentes da ordem de avalia\u00e7\u00e3o sequencial interna do simulador. Em casos onde um circuito atinge um estado inst\u00e1vel (como um la\u00e7o com delay nulo), o simulador, ap\u00f3s um limite de itera\u00e7\u00f5es, aborta a simula\u00e7\u00e3o para evitar execu\u00e7\u00f5es infinitas.</p> <p>2. Atribui\u00e7\u00e3o de Valores a Sinais</p> <p>A atribui\u00e7\u00e3o de um valor a um objeto da classe sinal \u00e9 realizada pelo delimitador <code>&lt;=</code>, que \u00e9 a forma mais b\u00e1sica de comando concorrente, transferindo o valor de uma fonte ou express\u00e3o para um sinal de destino.</p> <p>N\u00e3o \u00e9 permitida a transfer\u00eancia de valores entre objetos declarados com tipos diferentes.</p> <p>3. Estruturas de Decis\u00e3o Concorrente para L\u00f3gica Combinacional</p> <p>Para a modelagem de circuitos de sele\u00e7\u00e3o e decodifica\u00e7\u00e3o na camada concorrente, s\u00e3o utilizadas as constru\u00e7\u00f5es <code>WHEN ELSE</code> e <code>WITH SELECT</code>. Embora ambas permitam o roteamento de dados com base em condi\u00e7\u00f5es, elas implicam estruturas de hardware fundamentalmente diferentes devido \u00e0 prioridade de avalia\u00e7\u00e3o.</p> <p>3.1. Constru\u00e7\u00e3o <code>WHEN ELSE</code> (Atribui\u00e7\u00e3o Condicional de Sinal)</p> <p>A constru\u00e7\u00e3o <code>WHEN ELSE</code> define uma transfer\u00eancia condicional que \u00e9 avaliada em ordem de prioridade. A sintaxe consiste em uma lista de op\u00e7\u00f5es, onde a primeira condi\u00e7\u00e3o que retorna o valor verdadeiro define o valor a ser transferido ao sinal de destino.</p> <p>Estrutura Implicada: Devido \u00e0 prioridade sequencial, o hardware inferido corresponde a uma cadeia de seletores, Figura 1, ou um codificador de prioridade. Ao modelar circuitos onde a preced\u00eancia das condi\u00e7\u00f5es \u00e9 inerente (como um decodificador de interrup\u00e7\u00e3o ou prioridade), o <code>WHEN ELSE</code> \u00e9 frequentemente mais sucinto e reflete melhor o comportamento desejado.</p> Figura 1: Cadeia de seletores Fonte: Autor <p>Segue c\u00f3digo gen\u00e9rico de implementa\u00e7\u00e3o da estrutura da cadeia seletora apresentada na Figura 1. Note que o tipo das entradas e sa\u00edda devem ser os mesmos, inclusive sua dimens\u00e3o, se forem declarados do tipo <code>bit_vector</code>. A vari\u00e1vel de sele\u00e7\u00e3o n\u00e3o precisam ser do mesmo tipo ou dimens\u00e3o das entradas e sa\u00edda. </p> When Else<pre><code>entity sel is\n    port(\n        Expression_1, Expression_2, Expression_3: in &lt;type&gt;;\n        Condition_1, Condition2: in &lt;type&gt;;\n        signal_name: out &lt;type&gt;\n    );\nend entity;\n\narchitecture behavioral of sel is\nbegin\n    signal_name &lt;=  expression_1 when condition_1 else\n                    expression_2 when condition_2 else\n                    expression_3;\nend architecture;\n</code></pre> <p>A Figura 2 ilustra uma simbologia de implementa\u00e7\u00e3o de um mux de quatro entradas (D0..D3), duas sele\u00e7\u00f5es (S0,S1) e uma sa\u00edda (Y), que ser\u00e1 usado para exemplificar as aplica\u00e7\u00f5es da estrutura <code>when else</code> e <code>with select</code>.</p> Figura 2: MUX 4x1 Fonte: Autor MUX 4x1 com when else<pre><code>entity mux4x1 is \n    port(\n            D0, D1, D2, D3: in  bit;\n            S0, S1:         in  bit;\n            Y:              out bit\n        );\nend entity mux4x1;\n\n\narchitecture main of mux4x1 is \n    signal sel : bit_vector(1 downto 0) := \"00\";\nbegin\n    sel &lt;= S1 &amp; S0; -- Concatena\u00e7\u00e3o de bits\n\n    Y &lt;=    D0 when sel = \"00\" else\n            D1 when sel = \"01\" else\n            D2 when sel = \"10\" else\n            D3;\nend architecture main;\n</code></pre> <p></p> <p>3.2. Constru\u00e7\u00e3o <code>WITH SELECT</code> (Atribui\u00e7\u00e3o Selecionada de Sinal)</p> <p>A constru\u00e7\u00e3o <code>WITH SELECT</code> utiliza uma express\u00e3o de escolha para definir o valor do sinal de destino. Ao contr\u00e1rio do <code>WHEN ELSE</code>, todas as condi\u00e7\u00f5es de sele\u00e7\u00e3o s\u00e3o avaliadas com a mesma prioridade e devem ser mutuamente exclusivas. \u00c9 obrigat\u00f3rio que todas as poss\u00edveis condi\u00e7\u00f5es da express\u00e3o de escolha sejam cobertas, frequentemente utilizando-se a cl\u00e1usula <code>OTHERS</code> para englobar as condi\u00e7\u00f5es restantes.</p> <p>Estrutura Implicada: O circuito equivalente corresponde a um circuito de sele\u00e7\u00e3o comandado por um decodificador que detecta as condi\u00e7\u00f5es.</p> MUX 4x1 com with select<pre><code>entity mux4x1 is \n    port(\n            D0, D1, D2, D3: in  bit;\n            S0, S1:         in  bit;\n            Y:              out bit\n        );\nend entity mux4x1;\n\narchitecture main of mux4x1 is \n    signal sel : bit_vector(1 downto 0) := \"00\";\nbegin\n    sel &lt;= S1 &amp; S0; -- Concatena\u00e7\u00e3o de bits\n\n    with sel select\n        Y   &lt;=      D0 when \"00\",\n                    D1 when \"01\",\n                    D2 when \"10\",\n                    D3 when others;\nend architecture;\n</code></pre> <p></p> <p>3.3. Infer\u00eancia de Elementos de Mem\u00f3ria (Latches)</p> <p>Um cuidado essencial na utiliza\u00e7\u00e3o destas constru\u00e7\u00f5es \u00e9 garantir que todas as combina\u00e7\u00f5es l\u00f3gicas que possam ocorrer sejam endere\u00e7adas pela atribui\u00e7\u00e3o de um novo valor. Se uma condi\u00e7\u00e3o de escolha n\u00e3o for coberta pelo c\u00f3digo, o sintetizador assume que o valor anterior do sinal deve ser mantido, o que implica a necessidade de um elemento de mem\u00f3ria sens\u00edvel a n\u00edvel (latch). Esse comportamento \u00e9 a base para a infer\u00eancia de latches.</p> <p>4. Delimita\u00e7\u00e3o de Regi\u00f5es Concorrentes</p> <p>O VHDL oferece comandos para organizar e modularizar o c\u00f3digo concorrente.</p> <p>4.1. Comando <code>BLOCK</code></p> <p>O comando <code>BLOCK</code> (<code>BLOCO</code>) permite dividir o c\u00f3digo em regi\u00f5es, melhorando a organiza\u00e7\u00e3o e clareza, mas n\u00e3o interfere no circuito sintetizado. Sinais declarados dentro de um bloco t\u00eam sua visibilidade restrita ao seu interior.</p> <p>Uma aplica\u00e7\u00e3o avan\u00e7ada do <code>BLOCK</code> \u00e9 a implementa\u00e7\u00e3o de sinais de guarda (<code>GUARDED</code>), onde um sinal dentro do bloco pode ser desabilitado sob certas condi\u00e7\u00f5es. Se o sinal for declarado como <code>BUS</code>, a desativa\u00e7\u00e3o pode inferir um estado de alta imped\u00e2ncia (<code>Z</code>). Caso contr\u00e1rio, o sintetizador pode inferir um latch. No entanto, esta constru\u00e7\u00e3o \u00e9 frequentemente considerada obsoleta e deve ser tratada com cautela em s\u00edntese.</p> <p>4.2. Comando <code>PROCESS</code></p> <p>O comando <code>PROCESS</code> (<code>PROCESSO</code>) delimita uma \u00e1rea contendo comandos sequenciais. Embora os comandos internos sejam sequenciais, o processo em si \u00e9 um comando concorrente, executado simultaneamente com outros comandos concorrentes (incluindo outros processos).</p> <p>A ativa\u00e7\u00e3o de um processo \u00e9 determinada pela lista de sensibilidade; se houver uma altera\u00e7\u00e3o de valor em qualquer sinal listado, o processo \u00e9 executado sequencialmente do in\u00edcio ao fim.</p> <p>5. Palavra Reservada <code>UNAFFECTED</code></p> <p>A palavra reservada <code>UNAFFECTED</code> (<code>N\u00c3O AFETADO</code>), v\u00e1lida apenas no VHDL-1993, pode ser usada em atribui\u00e7\u00f5es concorrentes (como <code>WHEN ELSE</code> ou <code>WITH SELECT</code>). Ela indica explicitamente que, sob uma determinada condi\u00e7\u00e3o, o valor do sinal de destino n\u00e3o deve ser alterado. Embora \u00fatil para clareza, ela n\u00e3o \u00e9 universalmente suportada pelas ferramentas de s\u00edntese.</p> <p>Tabela de Compara\u00e7\u00e3o de Comandos Concorrentes</p> Comando Execu\u00e7\u00e3o Prioridade Cobertura Total Estrutura L\u00f3gica Inferida <code>WHEN ELSE</code> Concorrente Priorit\u00e1ria (sequencial) Opcional Codificador de Prioridade (Encadeamento de Seletores) <code>WITH SELECT</code> Concorrente Paralela (Equivalente) Obrigat\u00f3ria Multiplexador (Seletor Decodificado) Atribui\u00e7\u00e3o <code>&lt;=</code> Concorrente N/A N/A L\u00f3gica Combinacional Direta <p>A Figura 5 apresenta o RTL gerado para cada um dos c\u00f3digos apresentados anteriormente, usando <code>WHEN ELSE</code> em (a) e  <code>WITH SELECT</code> em (b).  </p> Figura 5: RTL das duas vers\u00f5es de MUX 4x1 Fonte: Autor <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/vhdl/v04-sequencial/","title":"04 - Sequencial","text":"<p>Comandos Sequenciais B\u00e1sicos em VHDL</p> <p>A elabora\u00e7\u00e3o de projetos de Hardware Description Language (HDL) em VHDL frequentemente exige a delimita\u00e7\u00e3o de regi\u00f5es de c\u00f3digo que devem ser executadas em sequ\u00eancia, necess\u00e1rias para descrever o comportamento interno de estruturas digitais complexas, como m\u00e1quinas de estados e l\u00f3gica de controle.</p> <p>Comandos sequenciais s\u00e3o inerentemente localizados em contextos espec\u00edficos da linguagem, notadamente dentro de processos ou subprogramas (fun\u00e7\u00f5es e procedimentos). Uma vez iniciada a execu\u00e7\u00e3o em uma regi\u00e3o de c\u00f3digo sequencial, os comandos s\u00e3o avaliados na ordem em que aparecem, diferentemente dos comandos concorrentes, onde a ordem \u00e9 irrelevante.</p> <p>1. Processos e a Lista de Sensibilidade</p> <p>O comando PROCESS define uma regi\u00e3o de c\u00f3digo sequencial, mas ele pr\u00f3prio opera como um comando concorrente. Uma descri\u00e7\u00e3o VHDL pode conter m\u00faltiplos processos que, embora executados internamente em sequ\u00eancia, operam simultaneamente uns com os outros.</p> <p>A execu\u00e7\u00e3o de um processo \u00e9 governada pela Lista de Sensibilidade, um conjunto de sinais especificados ap\u00f3s a palavra-chave <code>PROCESS</code>. Uma altera\u00e7\u00e3o no valor de qualquer sinal listado ativa o processo, resultando na avalia\u00e7\u00e3o sequencial dos comandos internos. Ao t\u00e9rmino da execu\u00e7\u00e3o, o processo \u00e9 suspenso, aguardando um novo evento na lista.</p> <p>A lista de sensibilidade \u00e9 cr\u00edtica, pois a omiss\u00e3o de um sinal de entrada relevante pode levar a um comportamento sequencial indesejado (a manuten\u00e7\u00e3o do valor anterior), que nem sempre \u00e9 corretamente inferido como um elemento de mem\u00f3ria pelas ferramentas de s\u00edntese.</p> <p>Exemplo de Processo com Lista de Sensibilidade:</p> <pre><code>ENTITY exemplo IS\n    PORT ( a, b   : IN  BIT;\n           sa, sb : OUT BIT );\nEND ENTITY;\n\nARCHITECTURE teste OF exemplo IS\nBEGIN\n    abc: PROCESS (a) -- executado na alteracao do valor de 'a'\n    BEGIN\n        sa &lt;= a;\n        sb &lt;= b;\n    END PROCESS abc;\nEND ARCHITECTURE;\n</code></pre> <p></p> <p>2. Atribui\u00e7\u00e3o de Valor em Regi\u00f5es Sequenciais</p> <p>Em regi\u00f5es de c\u00f3digo sequencial, a atribui\u00e7\u00e3o de valor a um sinal utiliza o delimitador $<code>&lt;=</code>\\(. \u00c9 fundamental compreender que, embora o comando seja executado sequencialmente, a atualiza\u00e7\u00e3o do valor do sinal n\u00e3o \u00e9 imediata. Em vez disso, a atribui\u00e7\u00e3o \u00e9 **agendada** para ocorrer ap\u00f3s um intervalo de tempo nulo (\\)\\Delta$) na suspens\u00e3o do processo (ou seja, quando o simulador coordena as itera\u00e7\u00f5es dos comandos concorrentes).</p> <p>A ordem de execu\u00e7\u00e3o \u00e9 crucial. Se houver m\u00faltiplas atribui\u00e7\u00f5es a um sinal dentro do mesmo processo, todas as atribui\u00e7\u00f5es s\u00e3o avaliadas sequencialmente, mas apenas a \u00faltima agendada \u00e9 efetivada ap\u00f3s o atraso \\(\\Delta\\).</p> <p>Exemplo de Agendamento em Processo:</p> <p>Este exemplo ilustra como a ordem sequencial dos comandos interage com o agendamento de sinais, que se torna vis\u00edvel na itera\u00e7\u00e3o seguinte (devido ao \\(\\Delta\\)):</p> <pre><code>ENTITY exemplo IS\n    PORT (  a      : IN     BIT;\n            s0, s1 : BUFFER BIT  );\nEND ENTITY;\n\nARCHITECTURE teste OF exemplo IS\nBEGIN\n    PROCESS (a, s0)\n    BEGIN\n        s1 &lt;= s0;\n        s0 &lt;= a;\n    END PROCESS;\nEND ARCHITECTURE;\n</code></pre> <p></p> <p>3. Estruturas de Execu\u00e7\u00e3o Condicional</p> <p>Duas constru\u00e7\u00f5es principais permitem a execu\u00e7\u00e3o condicional de comandos sequenciais: <code>IF ELSE</code> e <code>CASE WHEN</code>.</p> <p>3.1. Constru\u00e7\u00e3o IF ELSE</p> <p>A estrutura <code>IF ELSE</code> permite avaliar uma lista de condi\u00e7\u00f5es em ordem de prioridade. Se a primeira condi\u00e7\u00e3o (<code>IF</code>) for verdadeira, o bloco de comandos associado \u00e9 executado, e a estrutura \u00e9 encerrada. Se n\u00e3o, as condi\u00e7\u00f5es subsequentes (<code>ELSIF</code>) s\u00e3o avaliadas sequencialmente at\u00e9 que uma seja verdadeira. Se nenhuma for verdadeira e uma cl\u00e1usula <code>ELSE</code> estiver presente, seu bloco de comandos \u00e9 executado.</p> <p>Esta constru\u00e7\u00e3o, devido \u00e0 sua natureza sequencial de avalia\u00e7\u00e3o e prioridade impl\u00edcita, \u00e9 frequentemente usada para descrever l\u00f3gica de prioridade ou elementos de mem\u00f3ria (como latches ou flip-flops).</p> <p>Exemplo de Multiplexador 4 para 1 com IF ELSE:</p> <pre><code>ENTITY mux_4x1 IS\n    PORT(   in0, in1, in2, in3 : IN  BIT;\n            s0, s1             : IN  BIT;\n            out0               : OUT BIT  );\nEND ENTITY;\n\nARCHITECTURE teste_if_else OF mux_4x1 IS\n    SIGNAL sel : BIT_VECTOR(1 DOWNTO 0);\nBEGIN\n    sel &lt;= s1 &amp; s0;\n    abc: PROCESS (in0, in1, in2, in3, sel) -- sinal \"sel\" inserido na lista\n    BEGIN\n        IF sel = \"00\" THEN\n            out0 &lt;= in0;\n        ELSIF sel = \"01\" THEN\n            out0 &lt;= in1;\n        ELSIF sel = \"10\" THEN\n            out0 &lt;= in2;\n        ELSE\n            out0 &lt;= in3;\n        END IF;\n    END PROCESS abc;\nEND teste_if_else;\n</code></pre> <p>3.2. Constru\u00e7\u00e3o CASE WHEN</p> <p>A estrutura <code>CASE WHEN</code> executa comandos sequenciais com base no valor de uma \u00fanica express\u00e3o de escolha. As condi\u00e7\u00f5es de escolha devem ser mutuamente exclusivas, e todas as possibilidades de valor da express\u00e3o devem ser cobertas, frequentemente utilizando a cl\u00e1usula OTHERS para englobar os valores restantes.</p> <p>O tipo de retorno da express\u00e3o de escolha deve ser discreto (como <code>INTEGER</code> ou <code>BIT_VECTOR</code>). Por n\u00e3o ter prioridade impl\u00edcita, o <code>CASE WHEN</code> \u00e9 frequentemente preferido para descrever estruturas de sele\u00e7\u00e3o ou decodifica\u00e7\u00e3o sem hierarquia de decis\u00e3o, resultando em circuitos mais eficientes do que estruturas complexas aninhadas de <code>IF ELSE</code>.</p> <p>Exemplo de Multiplexador 4 para 1 com CASE WHEN:</p> <pre><code>ENTITY mux_4x1 IS\n    PORT(   in0, in1, in2, in3 : IN  BIT;\n            s0, s1             : IN  BIT;\n            out0               : OUT BIT  );\nEND mux_4x1;\n\nARCHITECTURE teste_case_when OF mux_4x1 IS\n    SIGNAL sel : BIT_VECTOR(1 DOWNTO 0);\nBEGIN\n    sel &lt;= s1 &amp; s0;\n    abc: PROCESS (in0, in1, in2, in3, sel) -- sinal \"sel\" inserido na lista\n    BEGIN\n        CASE sel IS\n            WHEN \"00\" =&gt; out0 &lt;= in0;\n            WHEN \"01\" =&gt; out0 &lt;= in1;\n            WHEN \"10\" =&gt; out0 &lt;= in2;\n            WHEN OTHERS =&gt; out0 &lt;= in3;\n        END CASE;\n    END PROCESS abc;\nEND teste_case_when;\n</code></pre> <p>4. Comandos de Controle de Fluxo</p> <p>4.1. Comando WAIT</p> <p>O comando WAIT \u00e9 usado para suspender a execu\u00e7\u00e3o de um processo ou procedimento. \u00c9 uma alternativa fundamental \u00e0 Lista de Sensibilidade; um processo n\u00e3o pode conter ambos. As tr\u00eas formas de uso s\u00e3o:</p> <ol> <li>WAIT ON (Lista de Sinais): Suspende at\u00e9 que um evento ocorra em qualquer sinal especificado, funcionando de forma equivalente a uma lista de sensibilidade.</li> <li>WAIT UNTIL (Express\u00e3o Booleana): Suspende at\u00e9 que a express\u00e3o se torne verdadeira. \u00c9 crucial na infer\u00eancia de registradores sens\u00edveis \u00e0 borda.</li> <li>WAIT FOR (Express\u00e3o de Tempo): Suspende a execu\u00e7\u00e3o por um per\u00edodo definido, amplamente utilizado em entidades de teste.</li> </ol> <p>Exemplo de Uso de WAIT ON:</p> <pre><code>ENTITY mux_4x1 IS\n    PORT( in0, in1, in2, in3 : IN  BIT; \n          s0, s1             : IN  BIT;\n          out0               : OUT BIT);\nEND teste_wait;\n\nARCHITECTURE teste_wait OF mux_4x1 IS\n    SIGNAL int0, int1, int2, int3 : BIT;\nBEGIN\n    PROCESS\n    BEGIN\n        out0 &lt;= int0 OR int1 OR int2 OR int3;\n        int0 &lt;= in0 AND NOT s1 AND NOT s0;\n        int1 &lt;= in1 AND NOT s1 AND s0;\n        int2 &lt;= in2 AND s1 AND NOT s0;\n        int3 &lt;= in3 AND s1 AND s0;\n        WAIT ON in0, in1, in2, in3, s0, s1, int0, int1, int2, int3;\n    END PROCESS;\nEND teste_wait;\n</code></pre> <p>Exemplo de Uso de WAIT FOR:</p> <pre><code>ENTITY teste IS\n    PORT( in0  : IN  BIT; \n          out0 : OUT BIT);\nEND ENTITY;\n\nARCHITECTURE teste_wait_for OF teste IS\n    SIGNAL ck : BIT;\nBEGIN\n\n     out0 &lt;= ck and in0;\n\n    abc: PROCESS\n    BEGIN\n            ck &lt;= not ck;\n            wait for 10 ns;\n    END PROCESS;\n\nEND ARCHITECTURE;\n</code></pre> <p></p> <p>4.2. Comando NULL</p> <p>O comando NULL n\u00e3o realiza nenhuma opera\u00e7\u00e3o; ele simplesmente passa o fluxo de execu\u00e7\u00e3o para o pr\u00f3ximo comando. Sua utilidade prim\u00e1ria \u00e9 satisfazer as regras sint\u00e1ticas que exigem a cobertura de todas as condi\u00e7\u00f5es poss\u00edveis, como na cl\u00e1usula <code>WHEN OTHERS</code> em um <code>CASE WHEN</code>, quando nenhuma a\u00e7\u00e3o l\u00f3gica \u00e9 necess\u00e1ria para os valores restantes.</p> <p>A aus\u00eancia de atribui\u00e7\u00e3o de valor a um sinal em uma condi\u00e7\u00e3o resulta na infer\u00eancia de um elemento de mem\u00f3ria (latch), que mant\u00e9m o valor anterior. O <code>NULL</code> pode ser usado explicitamente para indicar que, em certas condi\u00e7\u00f5es, n\u00e3o h\u00e1 a\u00e7\u00e3o a ser tomada (o que pode levar \u00e0 infer\u00eancia de um latch se o sinal n\u00e3o for atribu\u00eddo em todos os caminhos poss\u00edveis).</p> <p>Exemplo de Uso de NULL com CASE WHEN:</p> <pre><code>ENTITY sel_op IS\n    PORT(   x   : IN  BIT_VECTOR(2 DOWNTO 0);\n            sel : IN  BIT_VECTOR(1 DOWNTO 0);\n            y   : OUT BIT  );\nEND ENTITY;\n\nARCHITECTURE teste_null_case_when OF sel_op IS\nBEGIN\n    abc: PROCESS (x, sel)\n    BEGIN\n        CASE sel IS\n            WHEN \"00\" =&gt; y &lt;= x(0) AND x(1);\n            WHEN \"10\" =&gt; y &lt;= x(2) XOR x(0);\n            WHEN OTHERS =&gt; NULL;\n        END CASE;\n    END PROCESS abc;\nEND teste_null_case_when;\n\nARCHITECTURE teste_null_if_else OF sel_op IS\nBEGIN\n    abc: PROCESS (x, sel)\n    BEGIN\n        IF sel = \"00\" THEN \n            y &lt;= x(0) AND x(1);\n        ELSIF sel = \"01\" THEN\n            y &lt;= x(2) XOR x(0);\n        ELSE \n            NULL;\n        END IF;\n    END PROCESS abc;\nEND teste_null_if_else;\n</code></pre> <p>Neste exemplo, se <code>sel</code> for <code>\"01\"</code> ou <code>\"11\"</code>, o <code>NULL</code> \u00e9 executado, e o valor do sinal <code>s</code> \u00e9 mantido, implicando a necessidade de um latch pelo sintetizador.</p> <p>Compara\u00e7\u00e3o de Estruturas Condicionais</p> <p>\u00c9 vital distinguir o uso das constru\u00e7\u00f5es concorrentes (<code>WHEN ELSE</code>, <code>WITH SELECT</code>) daquelas sequenciais (<code>IF ELSE</code>, <code>CASE WHEN</code>):</p> Constru\u00e7\u00e3o Natureza Prioridade Cobertura Total Necess\u00e1ria? <code>WHEN ELSE</code> Concorrente Sim (pela ordem) N\u00e3o (gera latch se incompleta) <code>IF ELSE</code> Sequencial Sim (pela ordem) N\u00e3o (gera latch se incompleta) <code>WITH SELECT</code> Concorrente N\u00e3o (m\u00fatua exclusividade) Sim (gera latch se incompleta) <code>CASE WHEN</code> Sequencial N\u00e3o (m\u00fatua exclusividade) Sim (gera latch se incompleta) <p>Para a s\u00edntese de circuitos combinacionais, quando todas as condi\u00e7\u00f5es s\u00e3o cobertas e a prioridade \u00e9 irrelevante, <code>CASE WHEN</code> ou <code>WITH SELECT</code> s\u00e3o geralmente preferidos, pois representam uma l\u00f3gica de decodifica\u00e7\u00e3o mais direta e evitam a complexidade desnecess\u00e1ria inerente \u00e0 prioridade das estruturas <code>IF ELSE</code>. Al\u00e9m disso, o uso de <code>CASE WHEN</code> ajuda o projetista a evitar a cria\u00e7\u00e3o acidental de elementos de mem\u00f3ria (latches), um erro comum quando nem todas as condi\u00e7\u00f5es s\u00e3o cobertas em estruturas <code>IF ELSE</code>..</p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/fpga/vhdl/v04_1-dff/","title":"04.1 - Latch RS e D / Flip-flop D","text":"<p>Os circuitos digitais s\u00e3o divididos em dois tipos, sendo eles os circuitos combinacionais e os circuitos sequencias.</p> <p>Os circuitos combinacionais produzem suas sa\u00eddas da combina\u00e7\u00e3o dos valores de suas entradas e da l\u00f3gica de constru\u00e7\u00e3o do circuito, de forma praticamente imediata. </p> <p>J\u00e1 o circuitos sequanciais tem como caracter\u00edstica a capacidade de armazenar um valor. </p> <p>Destre os circuitos sequenciais, que realizam a fun\u00e7\u00e3o de elemento de mem\u00f3ria ou de estado, podemos destacar:</p> <ul> <li>Latches: Set-Reset e D;</li> <li>Flip-flops: D e T;</li> <li>Registradores: Deslocamento e contadores;</li> <li>Mem\u00f3rias e Registradores.</li> </ul> <p>Talvez o principal elemento para armazenar um dado seja o flip-flop tipo D, que est\u00e1 sendo constru\u00eddo nesta sequencia utilizando circuitos menos complexos, at\u00e9 o nosso ponto de partida que \u00e9 o circuito do <code>latch SR</code>, um circuito que est\u00e1 representado na Figura 1, juntamente com sua tabela verdade.</p> <p>O Latch Set-Reset \u00e9 o mais simples e n\u00e3o possui sinal de clock como os demais.</p> Figura 1: Latch Set-Reset Fonte: Autor latch_sr.vhdl<pre><code>entity latch_sr is\n    port(   r,s:    in      bit; \n            q,qbar: buffer  bit);\nend entity;\n\narchitecture main of latch_sr is\nbegin\n    q &lt;= r nor qbar;\n    qbar &lt;= s nor q;\nend architecture;\n</code></pre> <p></p> <p>O sinal de clock \u00e9 um sinal peri\u00f3dico, de onda quadrada, sendo metade do ciclo em n\u00edvel alto e a outra metade em n\u00edvel baixo. O clock \u00e9 o que determina quando os eventos dos circuitos devem acontecer, seja por n\u00edvel ou por transi\u00e7\u00e3o (borda), como s\u00e3o chamados os modos de temporiza\u00e7\u00e3o.</p> <ul> <li>Level-triggered: as mudan\u00e7as de estado ou atualiza\u00e7\u00e3o do circuito ocorre em um dos n\u00edveis do clock, alto ou baixo.</li> <li>Edge-triggered: a mudan\u00e7a de estado ou atualiza\u00e7\u00e3o do circuito ocorre na transi\u00e7\u00e3o do clock, borda de subida ou descida.</li> </ul> <p>O Latch tipo D possui uma entrada de clock, que habilita a escrita do circuito, e a Figura 2 mostra o circuito equivalente.</p> <p>A sa\u00edda do latch tipo D \u00e9 atualizado com o valor da entrada D quando a entrada de clock est\u00e1 em n\u00edvel alto (1). Quando a entrada de clock est\u00e1 em n\u00edvel baixo (0), o sinal de sa\u00edda \u00e9 o valor armazenado no \u00faltimo instante em que o clock estava em n\u00edvel alto. </p> Figura 2: Latch tipo D Fonte: Autor <p>latch_d.vhdl<pre><code>entity latch_d is\n    port(d,clk: in bit; q,qbar: out bit);\nend entity;\n\narchitecture main of latch_d is\n    signal r,s: bit;\nbegin\n    r &lt;= not d and clk;\n    s &lt;= d and clk;\n\n    RS:     entity work.latch_sr(main) \n            port map(r=&gt;r,s=&gt;s,q=&gt;q,qbar=&gt;qbar);\n\nend architecture;\n</code></pre> </p> <p>Os flip-flops s\u00e3o elementos constru\u00eddos com latches e armazenam o valor de 1 bit mediante uma transi\u00e7\u00e3o do sinal de sincronismo, o clock. </p> <p>Diferente do Latch tipo D, a atualiza\u00e7\u00e3o da sa\u00edda somente ocorre no instante da transi\u00e7\u00e3o, borda de subida, no sinal de clock (clk). </p> <p>A Figura 3 apresenta o diagrama de um flip-flop tipo D com atualiza\u00e7\u00e3o pela borda de subida no sinal de clock. </p> Figura 3: Flip-flop tipo D com clock em borda de subida Fonte: Autor <p>d_ff.vhdl<pre><code>entity d_ff is \n    port(d,clk: in bit; q,qbar: out bit);\nend entity;\n\narchitecture rising of d_ff is\n    signal qd,clkbar: bit;\nbegin\n    clkbar &lt;= not clk;\n\n    LATCH_D_IN: entity work.latch_d(main) \n                    port map(d=&gt;d,clk=&gt;clkbar,q=&gt;qd,qbar=&gt;open);\n\n    LATCH_D_OUT:entity work.latch_d(main) \n                    port map(d=&gt;qd,clk=&gt;clk,q=&gt;q,qbar=&gt;qbar);\n\nend architecture;\n</code></pre> </p> <p>A Figura 4 apresenta o diagrama de um flip-flop tipo D com atualiza\u00e7\u00e3o pela borda de descida no sinal de clock. </p> Figura 4: Flip-flop tipo D com clock em borda de descida Fonte: Autor d_ff.vhdl<pre><code>entity d_ff is \n    port(d,clk: in bit; q,qbar: out bit);\nend entity;\n\narchitecture falling of d_ff is\n    signal qd,clkbar: bit;\nbegin\n    clkbar &lt;= not clk;\n\n    LATCH_D_IN: entity work.latch_d(main) \n                    port map(d=&gt;d,clk=&gt;clk,q=&gt;qd,qbar=&gt;open);\n\n    LATCH_D_OUT:entity work.latch_d(main) \n                    port map(d=&gt;qd,clk=&gt;clkbar,q=&gt;q,qbar=&gt;qbar);\n\nend architecture;\n</code></pre> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> <li>Curso VHDL - O C\u00f3digo da Eletr\u00f4nica</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"digitais/Tecnologia/fpga/vhdl/v05-atraso_atributos/","title":"05 - Atraso, Vari\u00e1vel e Atributos","text":"<p>Atraso, vari\u00e1vel e atributos</p> <p>Aprofunda conceitos fundamentais da linguagem VHDL, essenciais para a modelagem temporal e a manipula\u00e7\u00e3o detalhada de objetos. O objetivo \u00e9 refinar o conhecimento sobre estes t\u00f3picos, introduzindo conceitos como atrasos de propaga\u00e7\u00e3o e a distin\u00e7\u00e3o comportamental entre sinais e vari\u00e1veis, al\u00e9m de explorar a funcionalidade dos atributos.</p> <p>1. Atraso (Delay)</p> <p>O atraso em VHDL \u00e9 utilizado para a modelagem do comportamento din\u00e2mico de um circuito ou para a gera\u00e7\u00e3o de formas de onda em testes de descri\u00e7\u00f5es,. \u00c9 crucial notar que os comandos que modelam o atraso s\u00e3o, via de regra, ignorados pelas ferramentas de s\u00edntese,.</p> <p>A modelagem temporal pode ser realizada em dois modelos principais, definidos pela cl\u00e1usula <code>AFTER</code>:</p> <ol> <li>Modelo com In\u00e9rcia (Inertial Delay): Este \u00e9 o modelo assumido quando a op\u00e7\u00e3o <code>TRANSPORT</code> \u00e9 omitida. \u00c9 indicado para representar a propaga\u00e7\u00e3o de informa\u00e7\u00f5es atrav\u00e9s de circuitos l\u00f3gicos, onde pulsos com dura\u00e7\u00e3o inferior ao atraso de propaga\u00e7\u00e3o do circuito n\u00e3o s\u00e3o transferidos para a sa\u00edda,.</li> <li>Modelo com Transporte (Transport Delay): \u00c9 especificado pela cl\u00e1usula <code>TRANSPORT</code>. Neste modelo, a informa\u00e7\u00e3o \u00e9 sempre transmitida, independentemente da dura\u00e7\u00e3o do pulso,.</li> </ol> <p>A cl\u00e1usula <code>AFTER</code> encontra utilidade prim\u00e1ria na gera\u00e7\u00e3o de est\u00edmulos e formas de onda para auxiliar no teste e simula\u00e7\u00e3o de uma descri\u00e7\u00e3o, embora n\u00e3o seja sintetiz\u00e1vel.</p> <p>Segue c\u00f3digo de exemplo de teste. </p> Teste da cl\u00e1usula AFTER<pre><code>entity delay is \n    port(x: in bit; y0, y1, y2: out bit);\nend entity;\n\narchitecture main of delay is \nbegin\n    y0 &lt;= x after 100 ns;\n    y1 &lt;= transport x after 100 ns;\n    y2 &lt;= '1', '0' after 100 ns, '1' after 900 ns;\nend architecture;\n</code></pre> <p>Ao produzir um teste utilizando o <code>University VWF</code>, obtem-se um resultado insatisfat\u00f3rio, sendo esta forma de visualiza\u00e7\u00e3o inadequada para este n\u00edvel de simula\u00e7\u00e3o.</p> <p></p> <p>Uma forma adequada de realizar o teste \u00e9 tamb\u00e9m usar a cl\u00e1usula <code>after</code> em sua aplica\u00e7\u00e3o prim\u00e1ria, produzindo uma forma de onda de teste e aplicando \u00e0 entrada que se quer testar o comportamento. </p> <p>Uma entidade de teste, basicamente implementa a(s) entidade(s) testada(s), e conecta sinais(<code>signal</code>) aos quais \u00e9 poss\u00edvel produzir est\u00edmulos e visualizar os resultados.  </p> <p>A entidade <code>delay</code> produz tr\u00eas sa\u00eddas, sendo:</p> <ul> <li><code>y0</code>: copia o sinal de <code>x</code> se este permanecer ligado por pelo menos <code>100 ns</code>;</li> <li><code>y1</code>: copia o sinal de <code>x</code> com um atraso de <code>100 ns</code>, independente do per\u00edodo em que o sinal ficou ativado;</li> <li><code>y2</code>: produz um perfil de sa\u00edda independente do sinal de entrada <code>x</code>, iniciando em <code>1</code>, indo a <code>0</code> entre o per\u00edodo de 100 ns at\u00e9 900 ns, e voltando para <code>1</code> at\u00e9 o final da simula\u00e7\u00e3o. Este perfil \u00e9 comum em testes de sinais de <code>clear</code>, <code>preset</code> ou <code>reset</code>.</li> </ul> <p>A entidade <code>testbench</code> ou simplesmente <code>tb</code>, \u00e9 ilustrada na Figura 1, implementa a entidade <code>delay</code>, e produz atrav\u00e9s do sinal (<code>signal</code>) <code>tb_x</code> o est\u00edmulo de teste desejado. </p> Figura 1: Diagrama da entidade de teste de bancada (testbench) Fonte: Autor <p>Para exemplificar, um sinal com perfil an\u00e1logo ao produzido no teste utilizando o <code>University VWF</code> foi gerado em <code>tb_x</code>.</p> testbench<pre><code>entity tb is\nend entity;\n\narchitecture testbench of tb is\n    signal tb_x:    bit;\n    signal tb_y0, tb_y1, tb_y2: bit;\nbegin\n    DELAY:  entity work.delay(main) port map(x=&gt;tb_x, y0=&gt;tb_y0, y1=&gt;tb_y1, y2=&gt;tb_y2);\n\n    tb_x &lt;= '0',              \n            '1' after 100 ns, '0' after 250 ns, \n            '1' after 400 ns, '0' after 450 ns, \n            '1' after 500 ns, '0' after 520 ns, \n            '1' after 600 ns, '0' after 700 ns, '0' after 1000 ns;\nend architecture;\n</code></pre> <p>Assim como ilustrado na Figura 1 e no c\u00f3digo <code>testbench</code>, a entidade <code>tb</code> produz e conecta os sinais <code>tb_x</code>, <code>tb_y0</code>, <code>tb_y1</code> e <code>tb_y2</code> respectivamente em <code>x</code>, <code>y0</code>, <code>y1</code>, e <code>y2</code> da entidade <code>delay</code>.  Na arquitetura <code>testbench</code>, a entidade <code>delay</code> \u00e9 instanciada e os sinais, entradas e sa\u00eddas mapeados. Ao produzir est\u00edmulo em <code>tb_x</code>, estamos produzindo o sinal equivalente na entrada <code>x</code> da entidade <code>delay</code>, j\u00e1 que est\u00e3o conectados. </p> <p>Na visualiza\u00e7\u00e3o, Figura 2, selecionamos os sinais <code>tb_y0</code>, <code>tb_y1</code> e <code>tb_y2</code> para ver o resultado produzido pela entidade <code>delay</code>, al\u00e9m do sinal de est\u00edmulo produzido em <code>tb_x</code>.</p> Figura 2: Visualiza\u00e7\u00e3o dos sinais do <code>tb</code> no software GTKWave Fonte: Autor <p>Para a simula\u00e7\u00e3o do c\u00f3digo <code>delay.vhdl</code> usando o teste de bancada (testbench) <code>tb.vhdl</code>, \u00e9 necess\u00e1rio seguir as seguintes instru\u00e7\u00f5es:</p> <ul> <li>No Quartus, na janela Tasks, selecione RTL Simulation;</li> <li>Conforme ilustrado na Figura 3, clique em Edit Settings;</li> </ul> Figura 3: Simula\u00e7\u00e3o RTL e c\u00f3digo do teste de bancada Fonte: Autor <ul> <li>Siga a sequencia de passos da Figura 4 para incluir o arquivo <code>tb.vhdl</code> no simulador;</li> </ul> Figura 4: Inclus\u00e3o de teste de bancada no simulador QuestaSim Fonte: Autor <ul> <li>Ao executar a fun\u00e7\u00e3o RTL Simulation, o simulador configurado ser\u00e1 aberto. Neste caso o Questa Intel Starter FPGA Edition, como mostrado na Figura 5.</li> </ul> Figura 5: Forma de onda no simulador QuestaSim Fonte: Autor <p>O carregamento e execu\u00e7\u00e3o do testbench ocorre de forma autom\u00e1tica, por\u00e9m o ajuste das ondas n\u00e3o. Clique sobre a tela de exibi\u00e7\u00e3o das formas de onda e em seguida clique em <code>Zoom Full</code> para ajustar e visualizar toda a simula\u00e7\u00e3o.</p> <p>2. Sinal e Vari\u00e1vel (Signal and Variable)</p> <p>Sinal (<code>SIGNAL</code>) e Vari\u00e1vel (<code>VARIABLE</code>) s\u00e3o classes de objetos que armazenam valores, mas se diferenciam fundamentalmente na regi\u00e3o de declara\u00e7\u00e3o e no mecanismo de atribui\u00e7\u00e3o e atualiza\u00e7\u00e3o de valor.</p> Caracter\u00edstica Sinal (<code>SIGNAL</code>) Vari\u00e1vel (<code>VARIABLE</code>) Regi\u00e3o de Uso Concorrente e Sequencial. Exclusivamente Sequencial Declara\u00e7\u00e3o Geralmente fora de <code>PROCESS</code> (exceto para sinais locais em <code>BLOCK</code>) Dentro de <code>PROCESS</code> ou subprogramas Atribui\u00e7\u00e3o Usa o delimitador <code>&lt;=</code> O valor \u00e9 agendado e assume-o ap\u00f3s um intervalo de tempo \\(\\Delta\\) (delta delay), na itera\u00e7\u00e3o dos comandos concorrentes. Usa o delimitador <code>:=</code>  O valor \u00e9 assumido imediatamente ap\u00f3s a execu\u00e7\u00e3o do comando Visibilidade Pode ser vis\u00edvel em regi\u00f5es concorrentes. Vis\u00edvel apenas no processo em que foi declarada. <p>O tempo de atualiza\u00e7\u00e3o da vari\u00e1vel \u00e9 imediato, o que geralmente resulta em menor consumo de mem\u00f3ria e melhor desempenho durante a simula\u00e7\u00e3o, se comparado ao agendamento de eventos e \u00e0 constru\u00e7\u00e3o de tabelas de sinais requerida para as atribui\u00e7\u00f5es de sinais.</p> <p>A distin\u00e7\u00e3o no tempo de atribui\u00e7\u00e3o \u00e9 vital para a infer\u00eancia correta de hardware. Em regi\u00f5es sequenciais (processos), se uma vari\u00e1vel recebe um novo valor antes de ser referenciada, a ferramenta de s\u00edntese n\u00e3o infere um elemento de mem\u00f3ria; se a vari\u00e1vel \u00e9 referenciada (utilizada) antes de receber um novo valor, um registrador pode ser inferido para armazenar o valor anterior.</p> Diferen\u00e7a no uso de signal e variable<pre><code>entity vars is\n    port( y0, y1: out integer );\nend entity;\n\narchitecture main of vars is\n    signal z0 : integer := 0;\nbegin\n    sig: process\n    begin\n        z0 &lt;= z0 + 1;\n        y0 &lt;= z0;\n        wait for 100 ns;\n    end process;\n\n    var: process\n    variable z1 : integer := 0;\n    begin\n        z1 := z1 + 1;\n        y1 &lt;= z1;\n        wait for 100 ns;\n    end process;\nend architecture;\n</code></pre> testbench<pre><code>entity tb is\nend entity;\n\narchitecture testbench of tb is\n    signal tb_y0: integer;\n    signal tb_y1: integer;\nbegin\n    VRS: entity work.vars(main) port map(y0=&gt;tb_y0,y1=&gt;tb_y1);\nend architecture;\n</code></pre> Figura 6: Diferen\u00e7a entre <code>signal</code> e <code>variable</code> Fonte: Autor <p>A instru\u00e7\u00e3o <code>wait for 100 ns;</code> n\u00e3o tem suporte em ferramentas de s\u00edntese, apenas em ferramentas de simula\u00e7\u00e3o, dessa forma, para executar o teste da diferen\u00e7a entre <code>signal</code> e <code>variable</code>, esse comando foi substitu\u00eddo por <code>wait until clk'event;</code>, que \u00e9 sintetiz\u00e1vel na detec\u00e7\u00e3o do evento bordas de um sinal de clock (<code>clk</code>), inclu\u00eddo na interface e gerando sinal de sincronismo no teste de bancada (testbench).</p> Diferen\u00e7a no uso de signal e variable<pre><code>entity vars is\n    port(   clk: in bit;\n            y0, y1: out integer );\nend entity;\n\narchitecture main of vars is\n    signal z0 : integer := 0;\nbegin\n    sig: process\n    begin\n        z0 &lt;= z0 + 1;\n        y0 &lt;= z0;\n        wait until (clk'event and clk='1');\n    end process;\n\n    var: process\n    variable z1 : integer := 0;\n    begin\n        z1 := z1 + 1;\n        y1 &lt;= z1;\n        wait until (clk'event and clk='1');\n    end process;\nend architecture;\n</code></pre> testbench<pre><code>entity tb is\nend entity;\n\narchitecture testbench of tb is\n    signal tb_y0: integer;\n    signal tb_y1: integer;\n     signal ck: bit;\nbegin\n    VRS: entity work.vars(main) port map(y0=&gt;tb_y0,y1=&gt;tb_y1, clk=&gt;ck);\n\n     ck &lt;= not ck after 50 ns;\nend architecture;\n</code></pre> Figura 7: Diferen\u00e7a entre <code>signal</code> e <code>variable</code> no Questa Fonte: Autor <p>3. Atributos (Attributes)</p> <p>Atributos fornecem informa\u00e7\u00f5es adicionais associadas a tipos, objetos, subprogramas e unidades de projeto.</p> <p>3.1 Conceitos Fundamentais de Sinais para Atributos</p> <p>Tr\u00eas termos descrevem a condi\u00e7\u00e3o de um sinal durante um ciclo de simula\u00e7\u00e3o:</p> <ul> <li>Active: \u00c9 atribu\u00eddo um novo valor a um sinal, mesmo que esse valor seja id\u00eantico ao anterior (atribui\u00e7\u00e3o ativa).</li> <li>Quiet: O sinal n\u00e3o \u00e9 ativo no ciclo atual da simula\u00e7\u00e3o.</li> <li>Event: Representa uma mudan\u00e7a no valor que o sinal ir\u00e1 assumir.</li> </ul> Entidade superior de teste de atributos<pre><code>entity atributos is\n    port(a,b: in bit; z: out bit);\nend entity;\n\narchitecture main of atributos is\nbegin   \n    z &lt;= a xor b;\nend architecture;\n</code></pre> testbench<pre><code>entity tb is\nend entity;\n\narchitecture testbench of tb is\n    signal x0, x1: bit;\n    signal y0: bit;\n    signal ativo: bit;\n    signal quieto: bit;\n    signal evento: bit;\nbegin\n    ATRIB: entity work.atributos(main) port map(a=&gt;x0,b=&gt;x1,z=&gt;y0);\n\n    x0 &lt;= not x0 after 100 ns;\n    x1 &lt;= not x1 after 200 ns;\n\n    ATIV: process(x0, x1,ativo,quieto,evento)\n    begin\n        if x0'active then   ativo &lt;= '1';   else    ativo &lt;= '0';   end if;\n\n        if x0'quiet then    quieto &lt;= '1';  else    quieto &lt;= '0';  end if;\n\n        if x0'event then    evento &lt;= '1'; else     evento &lt;= '0'; end if;\n\n    end process;\n\nend architecture;\n</code></pre> Figura : Simula\u00e7\u00e3o de sinais de atributos: <code>active</code>, <code>quiet</code> e <code>event</code> Fonte: Autor <p>3.2 Atributos Predefinidos</p> <p>A. Atributos Relativos a Sinais que Resultam em Novos Sinais:</p> <ul> <li><code>s'DELAYED (t)</code>: Novo sinal equivalente a \\(s\\), mas atrasado em \\(t\\) unidades de tempo.</li> <li><code>s'STABLE (t)</code>: Novo sinal do tipo <code>BOOLEAN</code>; \u00e9 <code>TRUE</code> se n\u00e3o houve troca de valor por um per\u00edodo \\(t\\). Utilizado na s\u00edntese de circuitos sequenciais.</li> <li><code>s'QUIET (t)</code>: Novo sinal do tipo <code>BOOLEAN</code>; \u00e9 <code>TRUE</code> se nenhum valor foi atribu\u00eddo por um per\u00edodo \\(t\\) (n\u00e3o ativo).</li> <li><code>s'TRANSACTION</code>: Novo sinal do tipo <code>BIT</code>; seu valor \u00e9 complementado a cada atribui\u00e7\u00e3o (ativa).</li> </ul> <p>B. Atributos Relativos a Sinais que N\u00e3o Resultam em Novos Sinais:</p> <ul> <li><code>s'EVENT</code>: Retorna <code>TRUE</code> se ocorreu uma troca de valor no ciclo corrente de simula\u00e7\u00e3o.</li> <li><code>s'ACTIVE</code>: Retorna <code>TRUE</code> se foi atribu\u00eddo um valor durante o ciclo corrente de simula\u00e7\u00e3o.</li> <li><code>s'LAST_VALUE</code>: Retorna o valor do sinal antes do \u00faltimo evento.</li> <li><code>s'LAST_EVENT</code>: Retorna o tempo decorrido desde a \u00faltima troca de valor do sinal.</li> </ul> <p>Relev\u00e2ncia para a S\u00edntese: As ferramentas de s\u00edntese geralmente suportam apenas o atributo <code>s'EVENT</code> em conjunto com os comandos <code>IF</code> ou <code>WAIT</code>, sendo fundamental para a detec\u00e7\u00e3o de bordas de subida ou descida.</p> <p>C. Atributos Relativos a Vetores:</p> <p>Permitem determinar caracter\u00edsticas dimensionais do vetor, sendo comumente suportados pelas ferramentas de s\u00edntese:</p> <ul> <li><code>a'HIGH(n)</code> / <code>a'LOW(n)</code>: Limites superior e inferior da dimens\u00e3o \\(n\\).</li> <li><code>a'LEFT(n)</code> / <code>a'RIGHT(n)</code>: Limites esquerdo e direito da dimens\u00e3o \\(n\\).</li> <li><code>a'LENGTH(n)</code>: N\u00famero de elementos na dimens\u00e3o \\(n\\).</li> <li><code>a'RANGE(n)</code>: Faixa do vetor (ex: <code>x TO y</code> ou <code>y DOWNTO x</code>).</li> <li><code>a'REVERSE_RANGE(n)</code>: Faixa oposta a <code>a'RANGE(n)</code>.</li> </ul> <p>D. Atributos Predefinidos Relativos a Tipos e Subtipos:</p> <p>Identificam elementos de tipos escalares (discretos ou f\u00edsicos). Exemplos incluem <code>t'HIGH</code>, <code>t'LOW</code>, <code>t'SUCC(e)</code>, <code>t'PRED(e)</code>, <code>t'POS(e)</code> (posi\u00e7\u00e3o), e <code>t'VAL(p)</code> (valor). Estes atributos s\u00e3o, na maioria dos casos, n\u00e3o suportados pelas ferramentas de s\u00edntese.</p> <p>3.3 Atributos Definidos pelo Usu\u00e1rio</p> <p>Permitem associar informa\u00e7\u00f5es adicionais definidas pelo projetista a itens espec\u00edficos (tipos, sinais, fun\u00e7\u00f5es, componentes, etc.).</p> <p>A defini\u00e7\u00e3o ocorre em duas etapas obrigat\u00f3rias:</p> <ol> <li>Declara\u00e7\u00e3o: Define o nome do atributo e o tipo que ele retorna,.</li> <li>Especifica\u00e7\u00e3o: Associa o atributo declarado a um ou mais itens e define o seu valor. Permite a refer\u00eancia a classes de itens como <code>CONSTANT</code>, <code>VARIABLE</code>, <code>SIGNAL</code>, <code>TYPE</code>, <code>SUBTYPE</code>, <code>COMPONENT</code>, <code>FUNCTION</code>, <code>PROCEDURE</code> ou <code>UNITS</code>.</li> </ol> <p>Um uso pr\u00e1tico de atributos definidos pelo usu\u00e1rio \u00e9 na modelagem de tempos de propaga\u00e7\u00e3o para simula\u00e7\u00e3o.</p> <p>4. Cuidados na Descri\u00e7\u00e3o (Ordem de Atribui\u00e7\u00e3o)</p> <p>Um ponto cr\u00edtico \u00e9 a ordem de atribui\u00e7\u00e3o de valores em regi\u00f5es sequenciais, especialmente quando vari\u00e1veis s\u00e3o empregadas para descrever l\u00f3gica combinacional (como um circuito de sele\u00e7\u00e3o).</p> <p>Se a atribui\u00e7\u00e3o a um sinal de sa\u00edda (que armazena o resultado da l\u00f3gica) for avaliada antes que as vari\u00e1veis de controle (que cont\u00eam os valores das entradas) tenham sido atualizadas, o sinal de sa\u00edda ser\u00e1 avaliado com base em valores antigos das vari\u00e1veis. Isso pode levar a um comportamento sequencial indesejado (mantendo o valor anterior), o que n\u00e3o corresponde \u00e0 l\u00f3gica combinacional especificada. Al\u00e9m disso, se a descri\u00e7\u00e3o n\u00e3o for formulada corretamente, a ferramenta de s\u00edntese pode falhar em inferir elementos de mem\u00f3ria para manter os valores internos, resultando em um circuito f\u00edsico incorreto.</p> <p>Refer\u00eancias</p> <ol> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/","title":"1. Sistemas Embarcados","text":"","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#1-sistemas-embarcados","title":"1. Sistemas embarcados","text":"<p>A terceira revolu\u00e7\u00e3o industrial, que ocorreu ap\u00f3s o fim da Segunda Guerra Mundial, produzida pelo desenvolvimento e utiliza\u00e7\u00e3o em larga escala da microeletr\u00f4nica, possibilitou a constru\u00e7\u00e3o dos primeiros computadores, ainda de grande porte, que evolu\u00edram para os microcomputadores, que logo foram ligados em rede. Em seguida vieram os computadores port\u00e1teis, alcan\u00e7ando o que chamamos smartphones, mas que erroneamente ainda chamamos de celulares. </p> <p>Toda essa evolu\u00e7\u00e3o produziu diversos novos conceitos ao longo do tempo, entre eles o conceito  de Computa\u00e7\u00e3o Ub\u00edqua, sendo este um novo paradigma proposto em 1991 por Mark Weiser (1952-1999), em que o computador est\u00e1 em toda parte, de forma impercept\u00edvel (ou invis\u00edvel) aos usu\u00e1rios, embarcado (ou embutido) nos ambientes agindo e reagindo de forma inteligente a tudo o que acontece ao seu redor.</p> <p>\"As tecnologias mais profundas s\u00e3o aquelas desaparecem. Tecem-se no tecido da vida cotidiana at\u00e9 que s\u00e3o indistingu\u00edveis dela.\u201d</p> <p>Mark Weiser</p> Figura: Mark Weiser - Xerox Palo Alto Research Center Fonte: Design de Intera\u00e7\u00e3o &amp; Computa\u00e7\u00e3o Pervasiva <p>Em seu artigo intitulado  \u201cThe computer for the twenty-first century\"  publicado pela Scientific American em Setembro de 1991,  Weiser apresenta o que seriam os computadores no s\u00e9culo XXI. </p> <p>Mas a computa\u00e7\u00e3o ub\u00edqua s\u00f3 \u00e9 poss\u00edvel por conta do desenvolvimento derivado da computa\u00e7\u00e3o convencional, em que sistemas eletr\u00f4nicos dedicados realizam o trabalho de processar dados do mundo real. Em ingl\u00eas s\u00e3o chamados sistemas embedded e s\u00e3o chamados em portugu\u00eas de sistemas embarcados ou mesmo embutidos. </p> <p>Talvez a mais not\u00f3ria utiliza\u00e7\u00e3o de um sistema embarcado ocorreu em julho de 1969, com a chegada de Armstrong, Aldrin e Collins \u00e0 lua, sendo o \u201cApollo Guidance Computer (AGC)\u201d o grande respons\u00e1vel pelo controle dos sistemas do M\u00f3dulo Lunar.</p> Figura: Apollo Guidance Computer (AGC) da miss\u00e3o espacial Apollo 11 e Neil Armstrong pisando na lua. Fonte: Wikipedia <p>O AGC foi desenvolvido pelo Massachusetts Institute of Technology (MIT) e \u00e9 considerado o primeiro sistema embarcado, considerado na \u00e9poca um sistema de alto risco, devido aos circuitos integrados ainda serem uma novidade tecnol\u00f3gica, ainda pouco experimentados em condi\u00e7\u00f5es extremas. O AGC operava em tempo real, possu\u00eda mem\u00f3rias RAM de 2kB e ROM de 32 kB, com a velocidade de clock de 1,024 MHz, display e teclado apenas num\u00e9rico. </p> <p>Podemos notar que os sistemas embarcados evolu\u00edram de forma a atender necessidades ou mesmo vontades de aplica\u00e7\u00f5es diversas, assim como na biologia, a evolu\u00e7\u00e3o produz sistemas simples ou complexos a depender do ambiente, das necessidades, dos recursos e aplica\u00e7\u00f5es. </p> <p>Existem muitas defini\u00e7\u00f5es, mas podemos considerar que  um sistema embarcado basicamente \u00e9 um conjunto dedicado de circuitos, incluindo um controlador program\u00e1vel, de modo a atender uma aplica\u00e7\u00e3o espec\u00edfica. Como exemplos mais comuns, s\u00e3o citados os aparelhos de micro-ondas e m\u00e1quinas de lavar, como sistemas simples, ou ainda subsistemas em equipamentos mais complexos como em ve\u00edculos ou smartphones. Em todos os casos, um controlador est\u00e1 conectado aos seus perif\u00e9ricos de aplica\u00e7\u00e3o espec\u00edfica e \u00e9 programado para realizar sua tarefa seguindo uma s\u00e9rie de opera\u00e7\u00f5es l\u00f3gicas e de modo a atender o seu objetivo, seja aquecer um alimento, lavar roupas, monitorar o consumo de combust\u00edvel ou controlar o foco e satura\u00e7\u00e3o da imagem capturada pela c\u00e2mera em um smartphone. </p> <p>Note que em um smartphone, existem muitos circuito embarcados, dedicados as mais diversas fun\u00e7\u00f5es presentes no aparelho, sendo este considerado em sua totalidade um sistema computacional de uso geral, e n\u00e3o um sistema embarcado, como as partes que o integram. </p> <p>Como principais e fundamentais caracter\u00edsticas dos Sistemas Embarcados podemos destacar que s\u00e3o destinado a uma \u00fanica aplica\u00e7\u00e3o, sendo assim possuem poucas entradas e sa\u00eddas, apresentam uma Interface simples e alguma forma de comunica\u00e7\u00e3o para sua intera\u00e7\u00e3o com outros dispositivos ou com o usu\u00e1rio. </p> <p>Sistemas embarcados possuem, geralmente, um conjunto de requisitos e restri\u00e7\u00f5es que fazem dessa \u00e1rea de estudo/trabalho uma das mais desafiadoras, pois envolvem m\u00faltiplas habilidades e conhecimento interdisciplinar. Alguns exemplos de requisitos e restri\u00e7\u00f5es est\u00e3o associados \u00e0 tamanho e peso do sistema ou dispositivo, consumo e custos reduzidos, seguran\u00e7a e confiabilidade, devendo se recuperar de forma autom\u00e1tica ap\u00f3s erros e falhas, robustez ao ambiente e aplica\u00e7\u00e3o em tempo real. </p> <p>Um sistema embarcado basicamente \u00e9 composto por um processador, microcontrolador ou um circuito integrado de aplica\u00e7\u00e3o espec\u00edfica (ASIC), para executar a l\u00f3gica armazenada na mem\u00f3ria. Esta l\u00f3gica, quando em computadores de uso geral, \u00e9 chamada de software, em sistemas embarcados \u00e9 chamada de firmware. Possui ainda interfaces para entradas e sa\u00eddas do sistema, para conex\u00e3o com sensores e atuadores, espec\u00edficos \u00e0 aplica\u00e7\u00e3o do sistema, e interface de usu\u00e1rio, geralmente para realizar alguma parametriza\u00e7\u00e3o no comportamento do sistema. Ainda \u00e9 necess\u00e1rio um sistema de alimenta\u00e7\u00e3o, seja diretamente da rede ou por bateria. A Figura ilustra um diagrama de blocos com a composi\u00e7\u00e3o do sistema. </p> Figura: Arquitetura B\u00e1sica de Sistemas Embarcados Fonte: Pr\u00f3prio autor <p>A \u00e1rea de sistemas embarcados apresentam grandes desafios relacionados \u00e0 m\u00e3o de obra, desenvolvimento de projetos e concorr\u00eancia. Um projeto de sistema embarcado \u00e9 composto de um hardware com seus aspectos de eletr\u00f4nica, inv\u00f3lucro ou carca\u00e7a e a sua est\u00e9tica afetando a experi\u00eancia do usu\u00e1rio, firmware com sua infraestrutura, caracter\u00edsticas de aplica\u00e7\u00e3o e usabilidade e ainda a sua documenta\u00e7\u00e3o com regulamentos e normas a serem seguidas. Com tudo isso, faz-se necess\u00e1rio que o profissional possua um conhecimento plural das tecnologias e do neg\u00f3cio envolvidos no projeto. </p> <p>Como \u00e9 o mercado de trabalho para profissionais desta \u00e1rea? Para ilustrar tal quest\u00e3o o portal Embarcados, que traz informa\u00e7\u00f5es sobre esta \u00e1rea no Brasil, faz pesquisas de mercado com o seu p\u00fablico brasileiro. </p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#2-perfil-dos-profissionais-de-sistema-embarcados-e-iot","title":"2. Perfil dos profissionais de Sistema Embarcados e IoT","text":"<p>Com base nos relat\u00f3rios de 2021, 2023 e 2025, da pesquisa de perfil profissinal em sistemas embarcados e iot, realizada pelo portal embarcados, \u00e9 poss\u00edvel observar a evolu\u00e7\u00e3o do mercado brasileiro de sistemas embarcados em diversas categorias. Abaixo, as tabelas detalham essa progress\u00e3o:</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#21-perfil-demografico-e-academico","title":"2.1 Perfil Demogr\u00e1fico e Acad\u00eamico","text":"<p>O perfil dos profissionais mostra uma estabilidade no dom\u00ednio masculino e um aumento cont\u00ednuo no n\u00edvel de escolaridade, com destaque para a p\u00f3s-gradua\u00e7\u00e3o.</p> Categoria Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 G\u00eanero (Masculino) 95,84% 95,79% 94,9% P\u00f3s-gradua\u00e7\u00e3o (Conclu\u00edda) 36,74% 39,47% 41,99% Forma\u00e7\u00e3o em Engenharia (El\u00e9trica/Comp.) 67,24% 66,84% 67,98%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#22-carreira-e-modalidade-de-trabalho","title":"2.2 Carreira e Modalidade de Trabalho","text":"<p>Nota-se um decl\u00ednio no interesse em trabalhar para empresas no exterior e uma retomada gradual, por\u00e9m constante, do trabalho presencial ao longo dos anos.</p> Pergunta / Op\u00e7\u00e3o Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 Pretende trabalhar no exterior? (Sim) 45,06% 38,60% 32,0% Modalidade Presencial 43,52% 47,75% 51,4% Modalidade H\u00edbrida 40,98% 36,48% 34,7% Modalidade Remota 15,50% 15,78% 13,8%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#23-tecnologias-e-ferramentas-de-software","title":"2.3 Tecnologias e Ferramentas de Software","text":"<p>A linguagem C e a ferramenta Visual Studio Code consolidaram seu crescimento e lideran\u00e7a absoluta no setor de desenvolvimento.</p> Tecnologia / Ferramenta Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 Linguagem C (Priorit\u00e1ria) 74,72% 77,78% 80,45% Linguagem C++ (Padr\u00e3o) 45,79% 50,44% 53,01% Visual Studio Code (Codifica\u00e7\u00e3o) 58,50% 70,24% 79,26% Git (Controle de Vers\u00e3o) 73,02% 73,74% 76,30% <p>Outras linguagens e tecnologias de codifica\u00e7\u00e3o citadas ao longo dos anos incluem:</p> <ul> <li>C# e .NET: Em 2025, o C# foi utilizado por 9,02% dos respondentes e o ecossistema .NET por 4,51%</li> <li>JavaScript e Java: Ambas mant\u00eam uma fatia constante de usu\u00e1rios, com o JavaScript apresentando 7,52% e o Java 4,89% no levantamento de 2025</li> <li>Assembly: Esta linguagem de baixo n\u00edvel apresentou uma queda gradual, saindo de 6,00% em 2023 para 3,01% em 2025</li> <li>Rust: Focada em seguran\u00e7a de mem\u00f3ria, a linguagem Rust come\u00e7ou a aparecer nos relat\u00f3rios, alcan\u00e7ando 3,38% de utiliza\u00e7\u00e3o em 2025</li> <li>Frameworks e Variantes: O uso de Qt com C++ (6,77%), MicroPython (4,14%) e Wiring (Arduino) (3,76%) tamb\u00e9m \u00e9 reportado como parte das ferramentas de programa\u00e7\u00e3o atuais</li> </ul> <p>Al\u00e9m dessas linguagens de alto n\u00edvel, os projetos tamb\u00e9m envolvem linguagens de descri\u00e7\u00e3o de hardware, como VHDL e Verilog, embora em menor escala.</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#24-tipos-de-processadores-utilizados-bits","title":"2.4 Tipos de Processadores Utilizados (Bits)","text":"<p>O mercado brasileiro apresenta uma migra\u00e7\u00e3o cont\u00ednua para dispositivos de maior capacidade de processamento, com os microcontroladores de 32 bits atingindo seu maior patamar em 2025.</p> Tipo de Processador Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 Microcontrolador 32 bits 65,57%* 69,95% 76,77% Microcontrolador 8 bits 11,01% 37,39% 27,95% Microprocessador 32 bits - 30,05% 26,77% Microprocessador 64 bits 8,20% 24,31% 24,80% <p>*Em 2021, o dado de 32 bits englobava microcontroladores e microprocessadores na mesma categoria de destaque.</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#25-principais-fabricantes-uso-atual","title":"2.5 Principais Fabricantes (Uso Atual)","text":"<p>A STMicroelectronics retomou a lideran\u00e7a absoluta em 2025, enquanto a Espressif manteve um crescimento constante desde 2021, consolidando-se como uma das favoritas devido ao foco em IoT.</p> Fabricante Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 STMicroelectronics 47,78% 46,33% 58,27% Espressif 41,45% 47,94% 50,79% Microchip / Atmel 44,73% 41,74% 29,53% NXP 26,00% 26,61% 21,65% Texas Instruments 22,95% 23,17% 20,08%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#26-arquiteturas-de-preferencia-para-projetos-futuros","title":"2.6 Arquiteturas de Prefer\u00eancia para Projetos Futuros","text":"<p>A arquitetura ARM permanece dominante, mas o interesse por RISC-V apresentou um salto significativo, quase dobrando sua relev\u00e2ncia entre 2023 e 2025.</p> Arquitetura Pesquisa 2023 Pesquisa 2025 ARM 77,06% 80,71% RISC-V 27,29% 38,98% Xtensa - 21,26% Propriet\u00e1ria (AVR, PIC, etc) 31,88% 16,54%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#27-fatores-decisivos-na-escolha-do-chip","title":"2.7 Fatores Decisivos na Escolha do Chip","text":"<p>O custo continua sendo o fator primordial para os engenheiros brasileiros, seguido de perto pela disponibilidade de ecossistema de software.</p> Fator de Escolha Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 Custo do Chip 65,11% 62,39% 67,32% Disp. Ferramentas Software 59,48% 56,42% 54,33% Popularidade / Comunidade 50,59% 47,02% 45,28% Desempenho do Chip 43,56% 44,04% 42,13% <ul> <li>Raz\u00e3o para Troca: A principal motiva\u00e7\u00e3o para mudar de microcontrolador em um projeto \u00e9 a busca por melhores recursos e novos perif\u00e9ricos (58,66% em 2025), superando a press\u00e3o por pre\u00e7o.</li> <li>Migra\u00e7\u00e3o para 64 bits: Embora os 32 bits dominem, h\u00e1 uma tend\u00eancia de migra\u00e7\u00e3o para 64 bits em projetos futuros, citada por 34,25% dos profissionais em 2025.</li> <li>Hardware Pr\u00f3prio: O desenvolvimento de hardware nacional segue forte, com 78,52% das empresas optando por desenvolver seus pr\u00f3prios projetos em vez de terceirizar, o que influencia diretamente na escolha t\u00e9cnica dos componentes.</li> </ul>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#28-hardware-e-internet-das-coisas-iot","title":"2.8 Hardware e Internet das Coisas (IoT)","text":"<p>No desenvolvimento de hardware, a prefer\u00eancia por projetos pr\u00f3prios aumentou, enquanto o uso de plataformas de nuvem como a Amazon AWS apresentou oscila\u00e7\u00f5es, mas manteve a lideran\u00e7a.</p> Categoria Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 Desenvolve Hardware Pr\u00f3prio 75,74% 75,27% 78,52% Nuvem IoT: Amazon AWS 29,67% 35,38% 29,84% Uso de RTOS (Nenhum) 46,92% 40,89% 37,97% Principal Protocolo: MQTT 40,91% 48,11% 50,81%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#29-comparativo-das-principais-faixas-salariais-r","title":"2.9 Comparativo das Principais Faixas Salariais (R$)","text":"Faixa Salarial (Mensal) Pesquisa 2021 Pesquisa 2023 Pesquisa 2025 At\u00e9 R$ 3.000 12,53% 10,66% 4,96% R$ 3.001 a R$ 6.000 22,29% 19,06% 17,02% R$ 6.001 a R$ 9.000 20,81% 19,06% 18,44% R$ 9.001 a R$ 12.000 15,07% 20,29% 17,38% R$ 12.001 a R$ 15.000 9,98% 8,61% 11,35% R$ 15.001 a R$ 18.000 3,82% 4,71% 7,80%","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#material-complementar","title":"Material Complementar","text":"<ol> <li>Luiz Bitencourt - Projetos de sistemas embarcados: Uma r\u00e1pida discuss\u00e3o</li> <li>C\u00f3digo Fonte TV - Sistemas Embarcados (Embedded Systems) // Dicion\u00e1rio do Programador</li> <li>C\u00f3digo Fonte TV - Conhecimentos necess\u00e1rios para trabalhar com sistemas embarcados</li> <li>UniVESP - Eletr\u00f4nica Embarcada - Aula 01 - Introdu\u00e7\u00e3o aos Sistemas Embarcados Eletr\u00f4nica Embarcada em Ve\u00edculos</li> <li>Dobra Espacial - Como o computador da Apollo funcionava?</li> <li>Apollo Guidance Computer (AGC) Code - Github</li> <li>Coding with Dee - This is the code that sent Apollo 11 to the moon (and it\u2019s awesome)</li> <li>Apollo Guidance And Navigation - A Problem in Man and Machine Integration - David G. Hoag - MIT</li> <li>Rodrigo Maximiano Antunes de Almeida - 01 - Sistemas embarcados e Linguagem C</li> </ol>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu1-embarcados/#referencias","title":"Refer\u00eancias","text":"<ol> <li>EMBARCADOS. Pesquisa sobre o Mercado Brasileiro de Sistemas Embarcados e IoT 2021. [S. l.]: Embarcados, 2021. Dispon\u00edvel em: https://embarcados.com.br/relatorio-da-pesquisa-sobre-o-mercado-brasileiro-de-sistemas-embarcados-e-iot-2021/</li> <li>EMBARCADOS. Pesquisa sobre o Mercado Brasileiro de Sistemas Embarcados e IoT 2023. [S. l.]: Embarcados, 2023. Dispon\u00edvel em: https://embarcados.com.br/relatorio-da-pesquisa-sobre-o-mercado-brasileiro-de-sistemas-embarcados-e-iot-2023/</li> <li>EMBARCADOS. Pesquisa sobre o Mercado Brasileiro de Sistemas Embarcados e IoT 2025. [S. l.]: Embarcados, 2025. Dispon\u00edvel em: https://embarcados.com.br/relatorio-da-pesquisa-sobre-o-mercado-brasileiro-de-sistemas-embarcados-e-iot-2025/</li> </ol>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/","title":"2. Microcontroladores","text":"","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#1-microcontroladores","title":"1. Microcontroladores","text":"<p>Os Microcontroladores s\u00e3o uma deriva\u00e7\u00e3o dos Microprocessadores que surgiram para uso e  aplica\u00e7\u00f5es espec\u00edficas, principalmente em sistemas industriais e mais recentemente  eletrodom\u00e9sticos at\u00e9 os atuais dispositivos de Internet das coisas, ou IoT  (Internet of things).</p> <p>Basicamente, tanto os microprocessadores quanto os microcontroladores s\u00e3o circuitos l\u00f3gicos digitais que processam dados, realizam c\u00e1lculos e interagem com um conjunto de outros circuitos. Nos processadores, os demais circuitos est\u00e3o em um corpo distinto, formando as placas m\u00e3e como nos computadores de uso geral. No caso dos microcontroladores, h\u00e1 uma s\u00e9rie de circuitos perif\u00e9ricos montados no mesmo encapsulamento da unidade de processamento, ou seja, no mesmo corpo do circuito de controle tamb\u00e9m est\u00e3o presentes mem\u00f3rias, circuitos contadores, conversores, de comunica\u00e7\u00e3o entre outros, a combina\u00e7\u00e3o \u00e9 extremamente ampla. </p> Figura : Microcprocessador x Microcontrolador Fonte: Pr\u00f3prio autor <p>Em fun\u00e7\u00e3o principalmente do tipo de aplica\u00e7\u00e3o aos quais cada um desses dispositivos \u00e9  empregado, algumas de suas caracter\u00edsticas acabam sendo bem diferentes.  A Tabela mostra algumas diferen\u00e7as de caracter\u00edsticas entre os microprocessadores e os  microcontroladores.</p> <p>Tabela: Compara\u00e7\u00e3o entre MPU e MCU</p> Microprocessador (MPU) Microcontrolador (MCU) Mem\u00f3ria Requer mem\u00f3ria externa e armazenamento de dados. M\u00f3dulos de mem\u00f3ria no chip (ROM, RAM). Perif\u00e9ricos Precisa de pe\u00e7as adicionais. Conecta-se ao barramento externo. Perif\u00e9ricos no chip (timers, portas de E/S, conversor de sinal). Capacidade computacional Capaz de realizar tarefas computacionais complexas. Limitado \u00e0 l\u00f3gica espec\u00edfica da aplica\u00e7\u00e3o. Velocidade do rel\u00f3gio (Clock) Faixa de GHz. Faixa de kHz a MHz. Consumo de energia Alto consumo de energia. Sem modo de economia de energia. Consome energia m\u00ednima. Modos de economia de energia integrados. Sistema operacional Requer sistemas operacionais. O sistema operacional \u00e9 opcional para alguns microcontroladores. Conectividade Lida com transfer\u00eancia de dados em alta velocidade. Oferece suporte para USB 3.0 e Gigabit Ethernet. Oferece suporte para comunica\u00e7\u00e3o de velocidade baixa a moderada. Interface perif\u00e9rica serial (SPI) e I\u00b2C. Receptor-transmissor ass\u00edncrono universal (UART). Custo Caro por causa dos componentes adicionais. Mais barato porque um \u00fanico circuito integrado oferece v\u00e1rias funcionalidades. Caso de uso Para computa\u00e7\u00e3o gen\u00e9rica ou sistemas que exigem capacidade computacional robusta. Para sistemas compactos, alimentados por bateria ou dispositivos de processamento l\u00f3gico. <p>Fonte: AWS - Qual \u00e9 a diferen\u00e7a entre microprocessadores e microcontroladores?</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#2-contexto-historico","title":"2. Contexto Hist\u00f3rico","text":"","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#21-como-surgiu-a-ideia-do-primeiro-processador","title":"2.1 Como surgiu a ideia do primeiro processador?","text":"<p>No ano de 1971, Federico Faggin da Intel, respondeu a um pedido de 12 microchips  personalizados para uma calculadora do fabricante de eletr\u00f4nicos japon\u00eas Busicom com  um \u00fanico circuito de uso geral, que correspondia \u00e0 solicita\u00e7\u00e3o, chamado de Intel 4004  foi o precursor de uma significativa evolu\u00e7\u00e3o da computa\u00e7\u00e3o. Operava com frequ\u00eancia de  clock de 740 kHz e operava fluxos de 4 bits, nibbles e realizada at\u00e9 92 mil instru\u00e7\u00f5es  por segundo. </p> Figura: Intel 4004: prot\u00f3tipo, esquem\u00e1tico, chip em produ\u00e7\u00e3o e Calculadora Busicom 141-PF Fonte: Intel Marks 50th Anniversary of the Intel 4004 <p>Poucos meses ap\u00f3s o lan\u00e7amento do Intel 4004, foi a vez do segundo processador,  desenvolvido de forma independente e com especifica\u00e7\u00f5es distintas ao primeiro,  foi a vez do  Intel 8008,  primeiro processador de 8 bits, com 50 porcento mais transistores e um clock oito vezes maior,  com capacidade de manipula\u00e7\u00e3o de dados ou caracteres, sendo o antecessor capaz apenas de  manipula\u00e7\u00f5es aritm\u00e9ticas.</p> <p>Com relatos de clientes do 8008, sobre o projeto do chip estar restringindo a  escala e a complexidade do software que eles queriam criar, foi desenvolvido o  Intel 8080 que tornou real o que os seus antecessores criaram, segundo Federico Notebookgin,  designer-chefe da Intel para o 8080 os antecessores 4004 e 8008.</p> <p>O novo chip de 8 bits resultante foi mais eficiente, mais poderoso e mais flex\u00edvel, capaz de 290.000 opera\u00e7\u00f5es por segundo (10 vezes a do 8008). E com uma configura\u00e7\u00e3o de 40 pinos, tornou a conex\u00e3o a outros componentes mais f\u00e1cil do que o projeto de 18 pinos do 8008. O 8080 tamb\u00e9m integrou as fun\u00e7\u00f5es dos chips de suporte que os 4004 e 8008 precisavam, tornando-o um verdadeiro microprocessador de chip \u00fanico.</p> <p>H\u00e1 50 anos: celebrando o influente Intel 8080</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#22-uma-nova-era","title":"2.2 Uma nova era","text":"<p>O Intel 8080 abriu as portas de um novo mundo a ser explorado por programadores do  mundo inteiro de tecnologias a explorar, o que possibilitou o seu uso n\u00e3o s\u00f3 em  computadores ou calculadoras, mas permitiu o seu uso no famoso Altair 8800,  o primeiro computador port\u00e1til e de baixo custo, tornando mais acess\u00edvel a computa\u00e7\u00e3o  comercial e cient\u00edfica. Ainda substituindo toda uma l\u00f3gica discreta,  pela primeira vez para processar um jogo, o Gun Fight, da Midway Games,  foi o primeiro jogo de arcade dispon\u00edvel comercialmente a utilizar este processador. </p> Figura : Uso do 8080 em caixa eletr\u00f4nico, computador Altair 8800 e Gun Fight, da Midway Games. Fonte: H\u00e1 50 anos: celebrando o influente Intel 8080 <p>A evolu\u00e7\u00e3o e o avan\u00e7o tecnol\u00f3gico desde os primeiros passos com os processadores \u00e9  not\u00f3rio e ultrapassa quaisquer limites at\u00e9 ent\u00e3o pensados.  A figura a seguir ilustra as principais caracter\u00edsticas dos processadores depois de 50 anos,  desde o ic\u00f4nico 8080. </p> Figura : Compara\u00e7\u00e3o de 50 anos entre o 8080 e o Core Ultra 200S Fonte: H\u00e1 50 anos: celebrando o influente Intel 8080","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#23-o-lendario-8051","title":"2.3 O lend\u00e1rio 8051","text":"<p>Ainda no come\u00e7o dos anos 80, a Intel desenvolveu um controlador com tecnologia NMOS,  o famoso 8051, que logo evoluiu para tecnologia CMOS,  reduzindo drasticamente o consumo de energia, possibilitando dispositivos com fontes  reduzidas de energia, como baterias port\u00e1teis. Possui mem\u00f3ria para o seu programa,  temporizador, barramento de 8 bits, 32 entradas e sa\u00eddas digitais,  porta de comunica\u00e7\u00e3o serial, interrup\u00e7\u00f5es, entre outros. </p> Figura : Intel P8051 Por Konstantin Lanzet (with permission) - CPU collection Konstantin Lanzet, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=4774266 <p>O 8051 como ficou popular, se mostrou muito adequado para aplica\u00e7\u00f5es industriais, e ganhou o t\u00edtulo de mais usado no mundo com mais de dois mil fabricantes que o utilizam como base dos seus projetos, em milhares de aplica\u00e7\u00f5es embarcadas. </p> <p>A arquitetura do 8051 utiliza o trabalho proposto por Burks, Goldstine e von Neumann - 1946, sendo este \u00faltimo o mais not\u00f3rio que acabou batizando o nome da arquitetura: Von Neumann, utilizando um conjunto de instru\u00e7\u00f5es denominadas, CISC. A ideia base \u00e9 acessar as mem\u00f3rias de c\u00f3digo e de trabalho por um mesmo barramento de dados.  No computador com conjunto complexo de instru\u00e7\u00f5es \u00e9 poss\u00edvel realizar praticamente todos os acessos e opera\u00e7\u00f5es de forma direta, com uma \u00fanica instru\u00e7\u00e3o, sendo sua complexidade associada ao circuito que permite a vasta possibilidade de instru\u00e7\u00f5es diretas. </p> <p>Em oposi\u00e7\u00e3o ao modelo CISC, foi desenvolvido em Harvard uma arquitetura que utiliza uma arquitetura com dois barramentos de acesso distintos entre programa e dados, assim, praticamente todas as a\u00e7\u00f5es s\u00e3o executadas em pelo menos duas instru\u00e7\u00f5es, simplificando o circuito de acesso, reduzindo o n\u00famero de possiblidades de instru\u00e7\u00f5es, RISC, mas ganhando em velocidade, principalmente quando utilizada a t\u00e9cnica de pipeline. Esta tecnologia se tornou muito predominante em diversas aplica\u00e7\u00f5es de controladores. </p> <p>Com o passar do tempo essas tecnologias forma se fundindo, caracter\u00edsticas de uma foram incorporadas \u00e0 outra e vice-versa. </p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#24-avr","title":"2.4 AVR","text":"<p>No in\u00edcio dos anos 90 surge um projeto de estudantes noruegueses ganhou muito espa\u00e7o no mercado com seu controlador com arquitetura baseada em RISC, denominada AVR, que foi adquirida a licen\u00e7a pela Atmel, o maior fabricante de microcontroladores de 8 bits, na \u00e9poca, grande fornecedor de chips 8051, apesar de j\u00e1 ser um projeto aberto e fabricado por diversas outras empresas. </p> <p>A partir de 1996 a Atmel incorporou a linha propriet\u00e1ria ATMega com dispositivos AVR, competindo diretamente com os PICs da Microchip e outros fabricantes como Renesas, Texas Istruments, Motorolla, etc.</p> <p>No ano de 2016, a l\u00edder do mercado de semicondutores de 8 bits foi adquirida pela sua principal concorrente, e desde ent\u00e3o os PICs e AVRs fazem parte de uma mesma empresa fabricante. </p> Figura: Rela\u00e7\u00e3o entre as marcas AVR, Atmel e Microchip Fonte: Pr\u00f3prio autor","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#25-arduino","title":"2.5 Arduino","text":"<p>Em 2005 na It\u00e1lia foi desenvolvida a plataforma de prototipagem Arduino, que ganhou a mente e os cora\u00e7\u00f5es de estudantes, entusiastas e hobbistas no mundo todo, por sua facilidade de uso inclusive e principalmente para leigos, robustez e acesso \u00e0 informa\u00e7\u00f5es, simples, objetivas e claras. </p> <p>Dentre os diversos modelos de Arduino, o mais comum e popular \u00e9 o Uno, que utiliza um controlador AVR ATMega328P, que alavancou suas vendas e lhe deu uma grande sobrevida. </p> Figura: Placas de desenvolvimento Fonte: Pr\u00f3prio autor","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#26-arm","title":"2.6 ARM","text":"<p>Outra grande evolu\u00e7\u00e3o foi a ado\u00e7\u00e3o da arquitetura ARM, que apesar de ser dos anos 80, tornou-se popular tanto em processadores quanto em microcontroladores nos anos 2000. </p> <p>A quantidade de microcontroladores hoje \u00e9 imensa, cada fabricante possui diversas fam\u00edlias com dezenas ou centenas de modelos, cada um com alguma caracter\u00edstica de perif\u00e9rico que pode ser o mais adequado para cada aplica\u00e7\u00e3o. O mercado \u00e9 gigante bem como suas possibilidades, principalmente com a utiliza\u00e7\u00e3o de dispositivos de 32 bits a um pre\u00e7o menor do que os de 8 bits e a implementa\u00e7\u00e3o de sistemas de comunica\u00e7\u00e3o sem fio. </p> <p>Assim como h\u00e1 diversos microcontroladores, os fabricantes tamb\u00e9m investiram no modelo de desenvolvimento amplamente aceito pelo mercado com o Arduino, e disponibiliza placas de desenvolvimento para os desenvolvedores se familiarizarem com os seus dispositivos e poderem utilizar com mais seguran\u00e7a em projetos pr\u00f3prios. </p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#3-tipos-de-microprocessadores","title":"3. Tipos de Microprocessadores","text":"<p>Os microprocessadores variam em pot\u00eancia, desempenho, metodologias de arquitetura, tamanho, consumo de energia e muitas outras vari\u00e1veis e s\u00e3o projetados para todos os tipos de aplica\u00e7\u00f5es. Microprocessadores de uso geral s\u00e3o comuns em computadores pessoais e dispositivos m\u00f3veis, enquanto unidades especializadas de alto desempenho, como Processadores de Sinal Digital (DSPs), s\u00e3o projetadas para tarefas exigentes como processamento de \u00e1udio, fala, v\u00eddeo e imagem.  </p> <p>A seguir est\u00e3o alguns dos principais tipos de microprocessadores.</p> <ul> <li>Microprocessadores de uso geral: Esses microprocessadores vers\u00e1teis s\u00e3o encontrados em uma ampla gama de aplica\u00e7\u00f5es e dispositivos comuns, como notebooks e servidores.\u00a0</li> <li>Microcontroladores: Embora seja mais correto dizer que os microcontroladores cont\u00eam microprocessadores, esses tipos de chips tamb\u00e9m apresentam todos os componentes adicionais necess\u00e1rios para um computador funcional, ou seja, mem\u00f3ria interna. Microcontroladores funcionam como microcomputadores e s\u00e3o preferidos para controlar elementos espec\u00edficos dentro de sistemas de computadores embarcados. Microcontroladores pequenos e de baixo consumo de energia n\u00e3o exigem sistemas operacionais complexos para funcionar e s\u00e3o comumente usados na ind\u00fastria automotiva para otimizar Unidades de Controle do Motor (ECUs), Sistemas Avan\u00e7ados de Assist\u00eancia ao Motorista (ADAS) e unidades de infoentretenimento, bem como em uma vasta gama de dispositivos eletr\u00f4nicos de consumo e at\u00e9 mesmo em automa\u00e7\u00e3o industrial.</li> <li>Processadores de sinal digital (DSPs): Os DSPs s\u00e3o especializados em c\u00e1lculos num\u00e9ricos de alta velocidade e geralmente s\u00e3o usados para tarefas exigentes, como processamento de \u00e1udio, telecomunica\u00e7\u00f5es e processamento de imagens. Eles tamb\u00e9m podem ser encontrados em aplica\u00e7\u00f5es que requerem a interpreta\u00e7\u00e3o de sinais anal\u00f3gicos para digitais, como sensores meteorol\u00f3gicos. Os DSPs s\u00e3o comumente usados em aplica\u00e7\u00f5es militares, como drones de vigil\u00e2ncia e outras aeronaves aut\u00f4nomas.</li> <li>Circuitos integrados espec\u00edficos de aplica\u00e7\u00f5es (ASICs): Os microprocessadores ASIC s\u00e3o projetados para tarefas espec\u00edficas e s\u00e3o personalizados para atender \u00e0s demandas espec\u00edficas de diversas aplica\u00e7\u00f5es. Alguns exemplos de microprocessadores ASIC incluem chips personalizados para consoles de jogos ou minera\u00e7\u00e3o de criptomoedas. DSPs, GPUs e outros tipos de microprocessadores especializados tamb\u00e9m s\u00e3o tecnicamente ASICs.\u00a0\u00a0</li> <li>Unidades de processamento gr\u00e1fico (GPUs): Os microprocessadores de GPU s\u00e3o especialmente projetados para a exigente tarefa de renderizar v\u00eddeos e gr\u00e1ficos digitais que exigem desempenho de alta pot\u00eancia e processamento paralelo. Essencialmente importantes para jogos de \u00faltima gera\u00e7\u00e3o, os potentes microprocessadores de GPU tamb\u00e9m s\u00e3o comumente usados na minera\u00e7\u00e3o de criptomoedas e s\u00e3o conhecidos pelo alto consumo de energia.\u00a0</li> <li>Processadores de rede: Um tipo de microprocessador ASIC especificamente otimizado para o processamento de pacotes de dados de rede mais frequentemente utilizados em switches de telecomunica\u00e7\u00f5es, roteadores e dispositivos de seguran\u00e7a de rede.\u00a0</li> <li>Coprocessadores: Os coprocessadores, como as unidades de ponto flutuante (FPUs), s\u00e3o projetados para fornecer suporte auxiliar \u00e0 CPU principal de um sistema para aumentar o desempenho durante certas tarefas exigentes, como a realiza\u00e7\u00e3o de c\u00e1lculos cient\u00edficos avan\u00e7ados ou f\u00f3rmulas matem\u00e1ticas complicadas.</li> </ul> <p>Um microcontrolador (MCU) \u00e9 essencialmente um \"computador em um \u00fanico chip\", que integra em um \u00fanico encapsulamento a unidade de processamento, mem\u00f3rias e diversos perif\u00e9ricos. Para entender sua estrutura e intera\u00e7\u00f5es internas, podemos dividir o conceito em tr\u00eas pilares fundamentais:</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#4-estrutura-e-interacoes","title":"4. Estrutura e intera\u00e7\u00f5es","text":"<p>Para entender as estruturas e intera\u00e7\u00f5es internas, podemos dividir o conceito de microcontrolador em tr\u00eas pilares fundamentais</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#41-arquitetura-e-organizacao-de-barramentos","title":"4.1 Arquitetura e Organiza\u00e7\u00e3o de Barramentos","text":"<p>A forma como os componentes internos se comunicam \u00e9 definida por sua arquitetura de barramentos:</p> <ul> <li> <p>Von Neumann: Utiliza um \u00fanico barramento para tr\u00e1fego de dados e instru\u00e7\u00f5es, o que simplifica o design, mas pode criar um gargalo de processamento.</p> </li> <li> <p>Harvard: Possui barramentos e mem\u00f3rias fisicamente separados para dados e instru\u00e7\u00f5es, o que permite ao processador buscar uma instru\u00e7\u00e3o e acessar dados simultaneamente, aumentando o desempenho atrav\u00e9s do pipeline.</p> </li> </ul> Figura: Arquiteturas Von Neumann x Harvard Fonte: Pr\u00f3prio autor <ul> <li>ISA (Arquitetura de Conjunto de Instru\u00e7\u00f5es): Define as opera\u00e7\u00f5es que o processador pode executar, sendo as mais comuns a RISC (instru\u00e7\u00f5es simples e de tamanho fixo, focadas em velocidade) e a CISC (instru\u00e7\u00f5es complexas que realizam m\u00faltiplas opera\u00e7\u00f5es de uma vez).</li> </ul> Figura: Arquiteturas internas de microcontroladores Fonte: Datasheet STM32F103xx AT89C51ED2","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#42-partes-fundamentais-estrutura-interna","title":"4.2 Partes Fundamentais (Estrutura Interna)","text":"<p>Os componentes principais que residem dentro do chip s\u00e3o:</p> <ul> <li> <p>CPU (Unidade Central de Processamento): \u00c9 o \"c\u00e9rebro\" composto pela Unidade de Controle (CU), que coordena as opera\u00e7\u00f5es; pela Unidade L\u00f3gica e Aritm\u00e9tica (ALU), que realiza c\u00e1lculos e testes l\u00f3gicos; e por Registradores, que s\u00e3o mem\u00f3rias ultra-r\u00e1pidas para armazenamento tempor\u00e1rio de dados de trabalho.</p> </li> <li> <p>Mem\u00f3rias Internas:</p> <ul> <li>Flash: Mem\u00f3ria n\u00e3o vol\u00e1til onde o firmware (programa) \u00e9 armazenado.</li> <li>SRAM: Mem\u00f3ria vol\u00e1til de acesso r\u00e1pido para vari\u00e1veis e dados de execu\u00e7\u00e3o.</li> <li>EEPROM: Usada para armazenar dados que precisam ser preservados mesmo sem energia, como configura\u00e7\u00f5es.</li> </ul> </li> <li> <p>Perif\u00e9ricos: Os principais perif\u00e9ricos internos encontrados em microcontroladores modernos, como a fam\u00edlia AVR (ATMega328P) e ARM Cortex-M, incluem:</p> <ul> <li>Portas de Entrada e Sa\u00edda de Uso Geral (GPIO): S\u00e3o as interfaces mais comuns, permitindo a conex\u00e3o com dispositivos digitais como bot\u00f5es e LEDs. Elas s\u00e3o organizadas em registradores (como o DDR, que define a dire\u00e7\u00e3o, e o PORT, que define o n\u00edvel l\u00f3gico) e podem ser multiplexadas com outras fun\u00e7\u00f5es internas para otimizar o n\u00famero de pinos do componente.</li> <li>Temporizadores e Contadores (Timers/Counters): Essenciais para o gerenciamento de tempo, esses m\u00f3dulos permitem contar eventos externos ou gerar intervalos de tempo precisos para interrup\u00e7\u00f5es peri\u00f3dicas. Eles tamb\u00e9m s\u00e3o a base para a gera\u00e7\u00e3o de sinais PWM (Modula\u00e7\u00e3o por Largura de Pulso), fundamentais no controle de pot\u00eancia de motores e intensidade de luz.</li> <li>Conversores de Sinal: <ul> <li>ADC (Conversor Anal\u00f3gico-Digital): Traduz grandezas f\u00edsicas (como temperatura ou luz lidas por sensores anal\u00f3gicos) em valores bin\u00e1rios que o processador consegue interpretar.</li> <li>Comparador Anal\u00f3gico: Compara as tens\u00f5es em dois pinos de entrada, alterando sua sa\u00edda digital de acordo com qual sinal \u00e9 maior, o que \u00e9 \u00fatil para detec\u00e7\u00e3o de n\u00edveis de tens\u00e3o e alarmes.</li> </ul> </li> <li>Interfaces de Comunica\u00e7\u00e3o: Permitem que o microcontrolador troque dados com outros circuitos ou computadores. As mais comuns s\u00e3o:<ul> <li>USART/UART: Comunica\u00e7\u00e3o serial ass\u00edncrona, muito utilizada para terminais de depura\u00e7\u00e3o e m\u00f3dulos Bluetooth ou RF.</li> <li>SPI (Serial Peripheral Interface): Protocolo s\u00edncrono de alta velocidade, ideal para cart\u00f5es SD e displays gr\u00e1ficos.</li> <li>I2C ou TWI (Two-Wire Interface): Barramento de dois fios que permite conectar m\u00faltiplos dispositivos de baixa velocidade, como sensores de temperatura e rel\u00f3gios de tempo real (RTC).</li> </ul> </li> <li>M\u00f3dulos de Supervis\u00e3o e Seguran\u00e7a:</li> <li>Watchdog Timer (WDT): Funciona como um \"c\u00e3o de guarda\" que reinicializa o sistema automaticamente caso o programa trave devido a erros ou interfer\u00eancias, garantindo a confiabilidade de sistemas cr\u00edticos.</li> <li>Controlador de Interrup\u00e7\u00f5es (como o NVIC no ARM): Gerencia a prioridade e a execu\u00e7\u00e3o de tarefas que devem interromper o fluxo normal do programa para responder a eventos imediatos.</li> </ul> <p>Al\u00e9m desses, dependendo do modelo, podem estar integrados outros perif\u00e9ricos sofisticados como controladores USB, CAN (comum em ve\u00edculos) e at\u00e9 interfaces Ethernet para conectividade de rede direta. A integra\u00e7\u00e3o desses recursos no mesmo sil\u00edcio reduz drasticamente o custo, o tamanho f\u00edsico das placas de circuito impresso e o consumo de energia, tornando os microcontroladores a escolha ideal para sistemas embarcados e dispositivos de Internet das Coisas (IoT).</p> <p>Al\u00e9m disso, muitos microcontroladores modernos tamb\u00e9m incluem recursos de seguran\u00e7a, como criptografia e autentica\u00e7\u00e3o, para proteger dados e garantir a integridade dos sistemas. </p> </li> </ul>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu2-microcontroladores/#43-interacoes-internas-o-ciclo-de-operacao","title":"4.3. Intera\u00e7\u00f5es Internas: O Ciclo de Opera\u00e7\u00e3o","text":"<p>As intera\u00e7\u00f5es ocorrem de forma sincronizada por um sinal de Clock, que dita o ritmo das transfer\u00eancias de dados entre a CPU, a mem\u00f3ria e os perif\u00e9ricos. O processamento segue quatro etapas principais:</p> <ol> <li> <p>Buscar (Fetch): A CPU busca a instru\u00e7\u00e3o na mem\u00f3ria de programa no endere\u00e7o apontado pelo Contador de Programa (PC).</p> </li> <li> <p>Decodificar (Decode): A instru\u00e7\u00e3o \u00e9 carregada no Registrador de Instru\u00e7\u00e3o (IR) e traduzida pela Unidade de Controle em sinais el\u00e9tricos de comando.</p> </li> <li> <p>Executar (Execute): A ALU realiza a opera\u00e7\u00e3o matem\u00e1tica ou l\u00f3gica solicitada.</p> </li> <li> <p>Armazenar (Store): O resultado \u00e9 gravado de volta em um registrador ou na mem\u00f3ria de dados.</p> </li> </ol> <p>Al\u00e9m desse ciclo, o microcontrolador interage com o mundo externo atrav\u00e9s de interrup\u00e7\u00f5es, eventos de hardware que suspendem temporariamente a execu\u00e7\u00e3o do programa principal para atender a uma tarefa imediata e priorit\u00e1ria, garantindo a natureza reativa do sistema.</p> <p>Refer\u00eancias e complementos</p> <ol> <li>Como a AWS pode ajudar com suas necessidades de desenvolvimento de microprocessadores e microcontroladores? - AWS</li> <li>O que \u00e9 um microprocessador? - IBM</li> <li>Microcontroladores vs. microprocessadores: qual \u00e9 a diferen\u00e7a? - IBM</li> <li>Microprocessadores e Microcontroladores - Prof. Jos\u00e9 Wilson Lima Nerys - UFG</li> <li>Intel's First Microprocessor</li> <li>A hist\u00f3ria dos processadores - TecMundo</li> <li>Evolu\u00e7\u00e3o Dos Processadores Da Intel - miso</li> <li>The story of AVR - avrtvtube</li> <li>The Evolution Of CPU Processing Power Part 1: The Mechanics Of A CPU - New Mind</li> <li>How Amateurs created the world\u2019s most popular Processor (History of ARM Part 1) - LowSpecGamer</li> <li>ARM's Secret Weapon (History of ARM Part 2) - LowSpecGamer</li> <li>The potted history of ARM - Retro Bytes</li> <li>Explaining RISC-V: An x86 &amp; ARM Alternative - ExplainingComputers</li> <li>SAP-1</li> </ol>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu3-perifericos_internos/","title":"Perif\u00e9ricos","text":"<p>Um microcontrolador (MCU) \u00e9 um sistema microprocessado que integra, em um \u00fanico chip, a unidade de processamento, mem\u00f3rias e diversas funcionalidades conhecidas como perif\u00e9ricos. Diferente dos microprocessadores de uso geral (MPU), que requerem componentes externos para funcionar, o microcontrolador \u00e9 projetado para aplica\u00e7\u00f5es espec\u00edficas, onde a alta integra\u00e7\u00e3o reduz custo, tamanho e consumo de energia.</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu3-perifericos_internos/#perifericos-internos","title":"Perif\u00e9ricos Internos","text":"<p>Os perif\u00e9ricos internos s\u00e3o m\u00f3dulos de hardware integrados no mesmo encapsulamento da CPU, atuando como extens\u00f5es que realizam tarefas dedicadas sem a necessidade de componentes extras na placa. Eles incluem as portas de entrada e sa\u00edda de uso geral (GPIO), temporizadores e contadores (timers), comparadores anal\u00f3gicos e conversores de sinal, como o ADC (Anal\u00f3gico-Digital). Interfaces de comunica\u00e7\u00e3o como USART, SPI e I2C (ou TWI) tamb\u00e9m s\u00e3o perif\u00e9ricos internos comuns, permitindo que o chip se comunique com outros dispositivos. Esses m\u00f3dulos internos trocam informa\u00e7\u00f5es com o processador atrav\u00e9s de barramentos de dados e controle embutidos no sil\u00edcio, como o barramento de perif\u00e9ricos privados (PPB).</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu3-perifericos_internos/#perifericos-externos","title":"Perif\u00e9ricos Externos","text":"<p>Os perif\u00e9ricos externos, por outro lado, s\u00e3o dispositivos que residem fora do chip do processador e s\u00e3o conectados a ele atrav\u00e9s de seus pinos de entrada e sa\u00edda. Eles s\u00e3o utilizados para suplementar a funcionalidade do sistema e permitir a intera\u00e7\u00e3o com o mundo f\u00edsico. Exemplos t\u00edpicos incluem displays de cristal l\u00edquido (LCD), teclados matriciais, motores de passo, sensores de temperatura externos (como o TC72) e cart\u00f5es de mem\u00f3ria (SD/MMC). Para que o microcontrolador interaja com esses componentes, geralmente \u00e9 necess\u00e1rio um circuito de interface ou driver (como uma Ponte H para motores) que ajuste os n\u00edveis de tens\u00e3o ou corrente.</p> <p>Em resumo, a diferen\u00e7a fundamental \u00e9 que os perif\u00e9ricos internos fazem parte da arquitetura do chip, enquanto os externos s\u00e3o componentes de hardware conectados para atender \u00e0s necessidades da aplica\u00e7\u00e3o final. O programador gerencia ambos atrav\u00e9s de registradores de controle e status, que funcionam como o \"painel de controle\" do microcontrolador, permitindo ligar, desligar ou configurar cada funcionalidade.</p>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu3-perifericos_internos/#referencias","title":"Refer\u00eancias","text":"<ol> <li>LIMA, Charles Borges de; VILLA\u00c7A, Marco V. M. AVR e Arduino: t\u00e9cnicas de projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012..</li> <li>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. [S.l.]: Jonathan Valvano, 2014. v. 1..</li> <li>SAP-1 (Simple-As-Possible Computer 1).</li> </ol>","tags":["Microcontrolador","MCU","MCMP","AVR"]},{"location":"digitais/Tecnologia/mcu/mcu4-simuladores/","title":"Simuladores","text":"<p>Os simuladores para sistemas embarcados s\u00e3o aplicativos de software executados em um computador host (geralmente um PC comum) que modelam e imitam o comportamento do processador e do sistema de hardware alvo. Eles permitem a execu\u00e7\u00e3o de modelos de design para fins de valida\u00e7\u00e3o e avalia\u00e7\u00e3o funcional, sem a necessidade imediata do hardware f\u00edsico.</p> <p>Abaixo, detalho as caracter\u00edsticas dessas ferramentas:</p> <p>Aplica\u00e7\u00f5es</p> <ul> <li>Valida\u00e7\u00e3o de Design: Verifica\u00e7\u00e3o do comportamento funcional (entrada/sa\u00edda) e de propriedades n\u00e3o-funcionais, como comportamento t\u00e9rmico e compatibilidade eletromagn\u00e9tica (EMC).</li> <li>Desenvolvimento Precoce: Permite que programadores experimentem o software nos est\u00e1gios iniciais de um projeto, mesmo antes do hardware real existir.</li> <li>Simula\u00e7\u00e3o de Algoritmos: Teste de algoritmos complexos (como codifica\u00e7\u00e3o de v\u00eddeo MPEG) para avaliar a qualidade dos resultados antes da implementa\u00e7\u00e3o em hardware.</li> <li>Educa\u00e7\u00e3o: Ferramenta \u00fatil para o aprendizado de novas linguagens de programa\u00e7\u00e3o e arquiteturas de microcontroladores.</li> <li>Simula\u00e7\u00e3o de Falhas (Fault Simulation): Modifica\u00e7\u00e3o de modelos para prever como o sistema reagir\u00e1 na presen\u00e7a de erros espec\u00edficos.</li> </ul> <p>Vantagens</p> <ul> <li>Baixo Custo e Velocidade: \u00c9 mais barato e r\u00e1pido implementar um produto inicial em um simulador do que construir um prot\u00f3tipo f\u00edsico.</li> <li>Controle e Observabilidade: Oferecem visibilidade total do estado interno (registradores e mem\u00f3ria) e controle sobre a repetibilidade de eventos, o que \u00e9 dif\u00edcil em hardware real.</li> <li>Seguran\u00e7a: Permite testar sistemas cr\u00edticos, como controles automotivos ou de usinas, sem os perigos f\u00edsicos de um sistema real inst\u00e1vel.</li> <li>Depura\u00e7\u00e3o Facilitada: Permite isolar se um comportamento estranho \u00e9 erro de hardware ou interpreta\u00e7\u00e3o errada da documenta\u00e7\u00e3o do processador.</li> </ul> <p>Desvantagens</p> <ul> <li>Velocidade Reduzida: Simula\u00e7\u00f5es s\u00e3o tipicamente muito mais lentas do que o tempo de execu\u00e7\u00e3o real, o que pode causar viola\u00e7\u00f5es de restri\u00e7\u00f5es temporais se interfaceadas com o ambiente real.</li> <li>Falta de Precis\u00e3o em Tempo Real: Muitos simuladores n\u00e3o conseguem duplicar efetivamente as intera\u00e7\u00f5es complexas de tempo real entre hardware e software.</li> <li>Escopo Limitado: Frequentemente focam apenas no processador, ignorando perif\u00e9ricos externos complexos; criar modelos para esses perif\u00e9ricos pode ser mais trabalhoso do que o valor da simula\u00e7\u00e3o.</li> <li>Incompletude: N\u00e3o podem garantir a aus\u00eancia de erros, pois \u00e9 imposs\u00edvel simular todas as combina\u00e7\u00f5es de entradas e estados internos.</li> </ul> <p>Simuladores Comuns no Mercado</p> <ul> <li>Proteus (ISIS): Amplamente utilizado na academia e ind\u00fastria para simular microcontroladores (como a fam\u00edlia AVR) e circuitos eletr\u00f4nicos completos.</li> <li>MATLAB/Simulink: Popular para engenharia de controle e design baseado em modelos, permitindo simular sistemas din\u00e2micos e traduzi-los para c\u00f3digo C ou VHDL.</li> <li>AVR Simulator: Integrado ao ambiente profissional AVR Studio, permitindo depurar o c\u00f3digo vendo o estado dos registradores bit a bit.</li> <li>PSpice/SPICE: Padr\u00e3o industrial para simula\u00e7\u00e3o de circuitos ao n\u00edvel el\u00e9trico para an\u00e1lise de ru\u00eddo, distor\u00e7\u00e3o e transientes.</li> <li>Qemu: Ferramenta de c\u00f3digo aberto utilizada para emular diversos sistemas, incluindo arquiteturas ARM.</li> <li>Solu\u00e7\u00f5es Acad\u00eamicas e Profissionais: gem5, SimpleScalar e OpenModelica (acad\u00eamicos); Synopsys Virtualizer (comercial).</li> </ul>","tags":["Tinkercad","Simulador","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu4-simuladores/#1-tinkercad","title":"1. Tinkercad","text":"<p>O Tinkercad \u00e9 uma ferramenta online gratuita da Autodesk voltada para niciantes. Ele permite a modelagem 3D, mas \u00e9 amplamente conhecido na eletr\u00f4nica por seu simulador de circuitos, onde \u00e9 poss\u00edvel montar projetos com Arduino, LEDs, bot\u00f5es e sensores de forma virtual e program\u00e1-los em blocos ou em c\u00f3digo C/C++, antes da implmenta\u00e7\u00e3o em hardware real.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>","tags":["Tinkercad","Simulador","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu4-simuladores/#2-simulide","title":"2. SimulIDE","text":"<p>O SimulIDE \u00e9 um simulador de circuitos eletr\u00f4nicos de tempo real, de c\u00f3digo aberto e multiplataforma. Ele \u00e9 focado principalmente na simula\u00e7\u00e3o de microcontroladores (como AVR, Arduino e PIC) e componentes perif\u00e9ricos. \u00c9 uma alternativa leve a softwares profissionais, permitindo testar o c\u00f3digo e o hardware virtualmente antes da montagem f\u00edsica.</p> <p></p> <p></p> <p></p> <p></p> <p></p>","tags":["Tinkercad","Simulador","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu4-simuladores/#referencias","title":"Refer\u00eancias","text":"<ol> <li> <p>ANDERSON, Rick; CERVO, Dan. Pro Arduino: Arduino Expert Topics and Techniques. New York: Apress, 2013.</p> </li> <li> <p>BARR, Michael. Programming Embedded Systems in C and C++. 1. ed. [S. l.]: O'Reilly, 1999.</p> </li> <li> <p>LANGBRIDGE, James A. Professional Embedded ARM Development. Indianapolis: John Wiley &amp; Sons, 2014.</p> </li> <li> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> </li> <li> <p>MARWEDEL, Peter. Embedded System Design: Embedded Systems Foundations of Cyber-Physical Systems, and the Internet of Things. 4. ed. Dortmund: Springer Nature, 2021.</p> </li> <li> <p>NOERGAARD, Tammy. Embedded Systems Architecture: A Comprehensive Guide for Engineers and Programmers. Oxford: Elsevier, 2005.</p> </li> <li> <p>RUSSELL, David J. Introduction to Embedded Systems: Using ANSI C and the Arduino Development Environment. [S. l.]: Morgan &amp; Claypool, 2010.</p> </li> <li> <p>VALVANO, Jonathan W. Embedded Systems: Introduction to ARM\u00ae Cortex\u2122-M Microcontrollers. 5. ed. Austin: [s. n.], 2014. v. 1.</p> </li> <li> <p>Tinkercad url: https://www.tinkercad.com/</p> </li> <li> <p>SimulIDE url: https://simulide.com/p/</p> </li> </ol>","tags":["Tinkercad","Simulador","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu5-frameworks/","title":"5. Frameworks","text":"","tags":["Framework","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu5-frameworks/#1-framework","title":"1. Framework","text":"<p>Um framework ou plataforma como o Arduino \u00e9 um ecossistema de c\u00f3digo aberto que integra hardware (placas baseadas em microcontroladores) e software (um ambiente de desenvolvimento integrado - IDE e bibliotecas) para simplificar a computa\u00e7\u00e3o f\u00edsica. Ele atua como uma camada de abstra\u00e7\u00e3o de software, oferecendo uma interface amig\u00e1vel (um subconjunto de C/C++ conhecido como a biblioteca Wiring) que esconde os detalhes complexos do hardware e dos registradores.</p> <p>Fun\u00e7\u00e3o A principal fun\u00e7\u00e3o de um framework desse tipo \u00e9 servir como uma ferramenta de prototipagem r\u00e1pida e educa\u00e7\u00e3o. Ele permite que iniciantes, artistas e designers criem sistemas funcionais (chamados de sketches) que sentem e respondem ao mundo f\u00edsico sem a necessidade de profundos conhecimentos t\u00e9cnicos em eletr\u00f4nica ou programa\u00e7\u00e3o de baixo n\u00edvel.</p> <p>Vantagens</p> <ul> <li>Facilidade e Acessibilidade: Projetado para pessoas sem experi\u00eancia pr\u00e9via, incluindo farta documenta\u00e7\u00e3o e exemplos de c\u00f3digo.</li> <li>Baixo Custo: As placas s\u00e3o baratas e o software \u00e9 gratuito, de c\u00f3digo aberto e multiplataforma (roda em Windows, Mac e Linux).</li> <li>Comunidade Global: Possui uma vasta comunidade ativa que compartilha projetos e solu\u00e7\u00f5es em f\u00f3runs e wikis como o Arduino Playground.</li> <li>Hardware Aberto: Os esquemas das placas s\u00e3o p\u00fablicos, permitindo que qualquer pessoa fabrique suas pr\u00f3prias vers\u00f5es ou m\u00f3dulos de expans\u00e3o (shields).</li> <li>Desenvolvimento \u00c1gil: Favorece a implementa\u00e7\u00e3o imediata de ideias, permitindo testar conceitos rapidamente.</li> </ul> <p>Desvantagens</p> <ul> <li>Efici\u00eancia de Mem\u00f3ria: O uso das bibliotecas de abstra\u00e7\u00e3o consome significativamente mais mem\u00f3ria flash e RAM do que um c\u00f3digo escrito puramente em C ou Assembly.</li> <li>Desempenho Reduzido: Comandos abstratos como <code>digitalWrite</code> podem ser mais de 30 vezes mais lentos do que o acesso direto aos registradores do microcontrolador.</li> <li>Limita\u00e7\u00f5es de Depura\u00e7\u00e3o: A IDE padr\u00e3o n\u00e3o oferece ferramentas nativas para a depura\u00e7\u00e3o (debug) passo a passo no hardware, o que dificulta a resolu\u00e7\u00e3o de problemas em projetos profissionais complexos.</li> <li>Baixa Portabilidade: C\u00f3digos dependentes das fun\u00e7\u00f5es espec\u00edficas do framework (Wiring) geralmente n\u00e3o funcionam em outras plataformas de hardware que n\u00e3o suportam a mesma camada de abstra\u00e7\u00e3o.</li> </ul> <p>Exemplos de outros frameworks e ambientes</p> <ul> <li>chipKIT: Uma das primeiras plataformas a suportar a compila\u00e7\u00e3o de c\u00f3digo Arduino para microcontroladores PIC32.</li> <li>openFrameworks: Conjunto de bibliotecas C++ voltado para componentes de \u00e1udio, v\u00eddeo e gr\u00e1ficos, que interage com o Arduino para expandir suas capacidades.</li> <li>Atmel Software Framework (ASF): Biblioteca profissional que fornece milhares de exemplos e drivers para microcontroladores AVR e ARM.</li> <li>.NET Compact Framework: Sistema da Microsoft que permite a execu\u00e7\u00e3o de aplica\u00e7\u00f5es em linguagens como C# e Visual Basic em dispositivos embarcados.</li> </ul>","tags":["Framework","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu5-frameworks/#2-arduino-x-c-x-asm","title":"2 Arduino x C x Asm","text":"<p>A compara\u00e7\u00e3o foi desenvolvida comparando os arquivos .hex gerados pela compila\u00e7\u00e3o ap\u00f3s cada uma das tr\u00eas formas de codifica\u00e7\u00e3o propostas: Framework Arduino, C e Assembly. Sendo que os tr\u00eas c\u00f3digos executam o mesmo programa, que consiste em duas sa\u00eddas digitais piscando de forma alternada e condicionada ao valor de uma entrada digital, assim, quando a entrada possui o valor l\u00f3gico <code>1</code>, as sa\u00eddas piscam alternadamente com intervalo de aproximadamente 500 ms e a entrada com o valor l\u00f3gico <code>0</code> produz um desligamento das sa\u00eddas. </p> <p>Segue o c\u00f3digo feito das tr\u00eas formas propostas.</p> <p>C\u00f3digo utilizando o framework Arduino.</p> <pre><code>// C\u00f3digo .ino\n\nvoid setup()\n{\n  pinMode(13, OUTPUT);\n  pinMode(12, OUTPUT);\n  pinMode( 8, INPUT);\n}\n\nvoid loop()\n{\n  if( digitalRead(8) == 1 )\n  {\n    digitalWrite(12, HIGH);\n    digitalWrite(13, LOW);\n    delay(500);\n    digitalWrite(12, LOW);\n    digitalWrite(13, HIGH);\n    delay(500);\n  }\n  else\n  {\n    digitalWrite(12, LOW);\n    digitalWrite(13, LOW);\n  }\n}\n</code></pre> <p>C\u00f3digo fonte em linguagem C para AVR.</p> <pre><code>// C\u00f3digo .c\n\n#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;0))\n        {\n            PORTB |= (1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n            _delay_ms(500);\n            PORTB ^= (1&lt;&lt;4 | 1&lt;&lt;5);\n            _delay_ms(500);\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n        }\n    }\n}\n</code></pre> <p>C\u00f3digo fonte em linguagem Assembly para AVR.</p> <pre><code>; C\u00f3digo .asm\n\n            ; Inclus\u00e3o das defini\u00e7\u00f5es de pinos fornecidas pelo fabricante\n.include \"m328pdef.inc\"\n\n                ; Programa alocado no endera\u00e7o 0 da mem\u00f3ria de c\u00f3digo.\n.ORG 0X0000\n\n                ; PB5, PB4: out;    PB0: in;    0b00110000 = 0x30\n    LDI     R16,0x30\n    OUT     DDRB,R16\n\nDESLIGA_LEDS:\n    LDI     R16,0x00\n    OUT     PORTB,R16\n\nINICIO:\n    IN      R16,PINB\n    SBRS    R16,0\n    RJMP    DESLIGA_LEDS\n\n    RCALL   DELAY\n    SBI     PORTB,PB5\n    CBI     PORTB,PB4\n    RCALL   DELAY\n    CBI     PORTB,PB5\n    SBI     PORTB,PB4\n    RJMP    INICIO\n\nDELAY:\n    LDI     R16,0\n    LDI     R17,0\n    LDI     R18,41\nDELAY_LOOP:\n    INC     R16\n    BRNE    DELAY_LOOP\n    INC     R17\n    BRNE    DELAY_LOOP\n    DEC     R18\n    BRNE    DELAY_LOOP\n    RET\n</code></pre> <p>O arquivo de inclus\u00e3o do projeto em Assembly <code>m328pdef.inc</code> cont\u00e9m a defini\u00e7\u00e3o dos registradores e seus respectivos endere\u00e7os. Este arquivo \u00e9 fornecido pelo fabricante.</p> <p>Ap\u00f3s a compila\u00e7\u00e3o dos c\u00f3digos, s\u00e3o gerados arquivos .hex equivalentes em comportamento, por\u00e9m com uma diferen\u00e7a absurda em termos de ocupa\u00e7\u00e3o de mem\u00f3ria.</p> <p></p>","tags":["Framework","Arduino"]},{"location":"digitais/Tecnologia/mcu/mcu5-frameworks/#referencias","title":"Refer\u00eancias","text":"<ol> <li> <p>ANDERSON, Rick; CERVO, Dan. Pro Arduino: Arduino Expert Topics and Techniques. New York: Apress, 2013.</p> </li> <li> <p>LIMA, Charles Borges de; VILLA\u00c7A, Marco Val\u00e9rio Miorim. AVR e Arduino: T\u00e9cnicas de Projeto. 2. ed. Florian\u00f3polis: Edi\u00e7\u00e3o dos Autores, 2012.</p> </li> <li> <p>MARGOLIS, Michael. Arduino Cookbook. 2. ed. [S. l.]: O'Reilly Media, 2012.</p> </li> <li> <p>NOERGAARD, Tammy. Embedded Systems Architecture: A Comprehensive Guide for Engineers and Programmers. Oxford: Elsevier, 2005.</p> </li> <li> <p>PEREA, Francis. Arduino Essentials. Birmingham: Packt Publishing, 2015.</p> </li> <li> <p>PURDUM, Jack. Beginning C for Arduino: Learn C Programming for the Arduino and Compatible Microcontrollers. New York: Apress, 2012.</p> </li> <li> <p>RUSSELL, David J. Introduction to Embedded Systems: Using ANSI C and the Arduino Development Environment. [S. l.]: Morgan &amp; Claypool, 2010.</p> </li> </ol>","tags":["Framework","Arduino"]},{"location":"digitais/iot/esp32/esp32-1-intro/","title":"Introdu\u00e7\u00e3o","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/esp32-1-intro/#esp32","title":"ESP32","text":"<p>O ESP32 \u00e9 um microcontrolador com conex\u00e3o Wi-Fi e Bluetooth integrados, desenvolvido pela empresa Espressif, robusto para aplica\u00e7\u00f5es industriais, com baix\u00edssimo consumo de energia para aplica\u00e7\u00f5es mobile, wearables (vest\u00edveis) ou IoT (Internet of Things - Internet das coisas).</p> <p>Possui alto grau de integra\u00e7\u00e3o, podendo atuar sozinho como controlador ou como ponte de comunica\u00e7\u00e3o com um microcontrolador principal, reduzindo a sua carga de processamento de comunica\u00e7\u00e3o, tornando-se um \"perif\u00e9rico\". Possui v\u00e1rios meios de interface com outros dispositivos, entre eles SPI, SDIO, I2C e UART.</p> <p>O ESP32 pode ser adquirido em v\u00e1rios formatos, sendo eles:</p> <ul> <li>SoCs;</li> <li>M\u00f3dulos;</li> <li>Kits de Desenvolvimento.</li> </ul> <p>Em todos os casos a documenta\u00e7\u00e3o \u00e9 muito completa, desde os passos para instala\u00e7\u00e3o das ferramentas de desenvolvimento, at\u00e9 um conjunto amplo de bibliotecas dispon\u00edveis para uso nas mais diversas aplica\u00e7\u00f5es.</p>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/esp32-1-intro/#espressif-iot-development-framework-esp-idf","title":"Espressif IoT Development Framework (ESP-IDF)","text":"<p>O ESP-IDF \u00e9 o framework oficial da Espressif para a linha de controladores ESP32. Oferece recursos necess\u00e1rios para desenvolver aplica\u00e7\u00f5es de uso geral, em linguagem C e C++.</p> <p>\u00c9 um projeto open-source e pode ser baixado do GitHub.</p> <p>Disponibiliza os seguintes Componentes de software:</p> <p></p> <p>Caracter\u00edsticas</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/esp32-1-intro/#links-uteis","title":"Links \u00fateis","text":"<p>ESP-IDF Projetos de exemplo</p> <ul> <li>ESP-IDF Programming Guide</li> <li>API reference</li> <li>esp-idf examples Github</li> </ul> <p>ESP-IDF FreeRTOS</p> <p>FreeRTOS \u00e9 um n\u00facleo do Sistema Operacional de Tempo Real para sistemas embarcados.</p> <ul> <li>What is an RTOS?</li> <li>FreeRTOS Documentation</li> <li>ESP-IDF FreeRTOS</li> </ul> <p>ESP-IDF Tratamento de erros</p> <ul> <li>Espressif Documentation</li> </ul> <p>ESP-IDF Componentes &amp; Bibliotecas de Sensores</p> <ul> <li>Component Library</li> <li>Documentation</li> <li>Examples</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab-i2c/","title":"Lab - I2C","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab-i2c/#i2c","title":"I2C","text":"<p>I2C is a serial, synchronous, multi-device, half-duplex communication protocol that allows co-existence of multiple masters and slaves on the same bus. I2C uses two bidirectional open-drain lines: serial data line (SDA) and serial clock line (SCL), pulled up by resistors.</p> <p>ESP32 has 2 I2C controller(s) (also called port), responsible for handling communication on the I2C bus.</p> <p>A single I2C controller can be a master or a slave.</p> <p>Typically, an I2C slave device has a 7-bit address or 10-bit address. ESP32 supports both I2C Standard-mode (Sm) and Fast-mode (Fm) which can go up to 100 kHz and 400 kHz respectively.</p> <ul> <li> <p>The clock frequency of SCL in master mode should not be larger than 400 kHz.</p> </li> <li> <p>The frequency of SCL is influenced by both the pull-up resistor and the wire capacitance. Therefore, it is strongly recommended to choose appropriate pull-up resistors to make the frequency accurate. The recommended value for pull-up resistors usually ranges from 1 k\u2126 to 10 k\u2126. Keep in mind that the higher the frequency, the smaller the pull-up resistor should be (but not less than 1 k\u2126). Indeed, large resistors will decline the current, which will increase the clock switching time and reduce the frequency. A range of 2 k\u2126 to 5 k\u2126 is recommended, but adjustments may also be necessary depending on their current draw requirements.</p> </li> </ul> <p>Refer\u00eancias</p> <p>asdf</p> <ul> <li>Inter-Integrated Circuit (I2C) | Espressif -MPU-6000 and MPU-6050 Product Specification Revision 3.4</li> <li>MPU-6000 and MPU-6050 Register Map and Descriptions Revision 4.0</li> <li>MPU-6000/MPU-6050 9-Axis Evaluation Board User Guide</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab-mqtt/","title":"Lab - MQTT","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab-mqtt/#mqtt","title":"MQTT","text":"<p>Pesquisar: App smartphone: MQTT dash</p> <p>Refer\u00eancias</p> <ul> <li>88 - Broker MQTT no ESP32: Sim, isso \u00e9 real! | Embarcados TV</li> <li> </li> </ul>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab-mqtt/#protocolo-mqtt-o-que-e-como-funciona-e-projeto-pratico-inetec","title":"Protocolo MQTT: O Que \u00e9, Como Funciona e Projeto Pr\u00e1tico | INETEC","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab00-ambientacao/","title":"Lab00 - Ambienta\u00e7\u00e3o","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab00-ambientacao/#esp32","title":"ESP32","text":"<p>O ESP32 \u00e9 um sistema em chip \u00fanico que integra as seguintes caracter\u00edsticas:</p> <ul> <li>Wi-Fi (2.4 GHz band);</li> <li>Bluetooth;</li> <li>CPU Dual core Xtensa\u00ae 32-bit LX6; </li> <li>Co-processador de ultra baixa energia;</li> <li>Multiplos perif\u00e9ricos.</li> </ul> <p>Placas de desenvolvimento oficiais:</p> <ul> <li>ESP32-DevKitC</li> <li>ESP32-DevKitM-1</li> <li>ESP-WROVER-KIT</li> <li>ESP32-PICO-KIT</li> <li>ESP32-Ethernet-Kit</li> <li>ESP32-PICO-KIT-1</li> <li>ESP32-PICO-DevKitM-2</li> </ul> <p>Ambiente e ferramentas de desenvolvimento</p> <p>Para utilizar os ESP-IDF no ESP32, instale os seguintes softwares:</p> <ul> <li>Toolchain para compilar c\u00f3digo para ESP32;</li> <li>CMake e Ninja para constru\u00e7\u00e3o completa da aplica\u00e7\u00e3o para ESP32</li> <li>ESP-IDF cont\u00e9m essencialmente API (bibliotecas de software e c\u00f3digo-fonte) para ESP32 e scripts para operar o Toolchain.</li> </ul> <p></p> <p>Instala\u00e7\u00e3o em IDE</p> <ul> <li>Eclipse Plugin</li> <li>VSCode Extension</li> </ul> <p>Instala\u00e7\u00e3o Manual</p> <ul> <li>Windows installer</li> <li>Linux e MacOS</li> </ul> <p>Criando um primeiro projeto</p> <ul> <li>Iniciando um projeto no Windows</li> <li>Iniciando um projeto no Linux/MacOS</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab01-blink/","title":"Lab01 - PiscaLED","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab01-blink/#criando-o-primeiro-projeto-pisca-led-blink","title":"Criando o primeiro projeto: Pisca LED (blink)","text":"<p>O kit de desenvolvimento ESP32-DevKitC apresenta um LED conectado ao pino 2, de modo que se pode us\u00e1-lo para o famoso <code>Hello World</code> dos sistemas embarcados, o <code>blink</code> ou <code>PiscaLED</code>.</p> <p>Seguem os passos para criar um projeto de pisca LED para o ESP32.</p> <p>1) Abra o VSCode e clique em <code>View</code> &gt;&gt; <code>Explorer</code> ou tecle <code>Ctrl+Shift+E</code>:</p> <p>2) Clique em <code>Open Folder</code> e selecione um diret\u00f3rio para inclu\u00ed-lo ao <code>Explorer</code>.</p> <p>Caso ao menos um diret\u00f3rio j\u00e1 esteja no <code>Explorer</code>, clique com o bot\u00e3o direito do mouse sobre a \u00e1rea vazia do <code>Explorer</code> e selecione <code>Add Folder to Workspace</code>, selecione e inclua o diret\u00f3rio desejado.</p> Figura 1: Adicionando um diret\u00f3rio (ESP32) ao explorador de arquivos Fonte: Autor <p>Para este exemplo, estou utilizando o diret\u00f3rio denominado <code>esp32_piscaLED</code>, conforme ilustrado na Figura 2, como \u00e1rea de trabalho para o desenvolvimento deste projeto.</p> <p>3) Abra um terminal integrado no diret\u00f3rio de trabalho, conforme ilustrado na Figura 2 ou teclando <code>Ctrl+Shift+'</code>.</p> Figura 2: Abrir o diret\u00f3rio de trabalho em um terminal integrado Fonte: Autor <p>Deve aparecer um prompt de comandos com um endere\u00e7o deste tipo:</p> Figura 3: Terminal integrado aberto no diret\u00f3rio de trabalho Fonte: Autor <p>4) Crie um ambiente de desenvolvimento para o ESP-IDF com o seguinte comando:</p> PowerShell - Windows<pre><code>. C:\\Espressif\\frameworks\\esp-idf-v5.2.1\\export.ps1\n</code></pre> <p>Se na instala\u00e7\u00e3o da vers\u00e3o GNU/Linux foi criado o <code>alias</code> <code>get_idf</code>, basta digitar: Bash - GNU/Linux<pre><code>get_idf\n</code></pre> Se o <code>alias</code> <code>get_idf</code> n\u00e3o foi criado, digite: Bash - GNU/Linux<pre><code>. $HOME/espressif/esp-idf/export.sh\n</code></pre></p> <p>Obs1: Verifique a vers\u00e3o do esp-idf instalado em seu computador, e caso precise, altere o endere\u00e7o do arquivo <code>export.ps1</code> de forma adequada. Provavelmente a \u00fanica altera\u00e7\u00e3o ser\u00e1 na vers\u00e3o do esp-idf instalado, necessitando alterar apenas o <code>...\\esp-idf-v5.2.1\\...</code> do caminho citado.</p> <p>Obs2: Note que o comando \u00e9 iniciado com um <code>.</code>, indicando a execu\u00e7\u00e3o do <code>export.ps1</code> no diret\u00f3rio atual.</p> <p>O resultado da cria\u00e7\u00e3o do ambiente deve ser algo assim:</p> PowerShell - Windows<pre><code>PS C:\\Users\\professor\\git\\codeberg\\esp32_piscaLED&gt; . C:\\Espressif\\frameworks\\esp-idf-v5.2.1\\export.ps1\nSetting IDF_PATH: C:\\Espressif\\frameworks\\esp-idf-v5.2.1\nChecking Python compatibility\nAdding ESP-IDF tools to PATH...\n\nName                           Value\n----                           -----\nOPENOCD_SCRIPTS                C:\\Espressif\\tools\\openocd-esp32\\v0.12.0-esp32-20230921\\openocd-esp32\\share\\openocd\\scripts\nIDF_CCACHE_ENABLE              1\nESP_ROM_ELF_DIR                C:\\Espressif\\tools\\esp-rom-elfs\\20230320\\\nIDF_PYTHON_ENV_PATH            C:\\Espressif\\python_env\\idf5.2_py3.13_env\nESP_IDF_VERSION                5.2\nIDF_DEACTIVATE_FILE_PATH       C:\\Users\\PROFES~1\\AppData\\Local\\Temp\\tmpk4zf824kidf_19264\n\nAdded to PATH\n-------------\nC:\\Espressif\\tools\\xtensa-esp-elf-gdb\\12.1_20231023\\xtensa-esp-elf-gdb\\bin\nC:\\Espressif\\tools\\riscv32-esp-elf-gdb\\12.1_20231023\\riscv32-esp-elf-gdb\\bin\nC:\\Espressif\\tools\\xtensa-esp-elf\\esp-13.2.0_20230928\\xtensa-esp-elf\\bin\nC:\\Espressif\\tools\\riscv32-esp-elf\\esp-13.2.0_20230928\\riscv32-esp-elf\\bin\nC:\\Espressif\\tools\\esp32ulp-elf\\2.35_20220830\\esp32ulp-elf\\bin\nC:\\Espressif\\tools\\cmake\\3.24.0\\bin\nC:\\Espressif\\tools\\openocd-esp32\\v0.12.0-esp32-20230921\\openocd-esp32\\bin\nC:\\Espressif\\tools\\ninja\\1.11.1\\\nC:\\Espressif\\tools\\idf-exe\\1.0.3\\\nC:\\Espressif\\tools\\ccache\\4.8\\ccache-4.8-windows-x86_64\nC:\\Espressif\\tools\\dfu-util\\0.11\\dfu-util-0.11-win64\nC:\\Espressif\\python_env\\idf5.2_py3.13_env\\Scripts\nC:\\Espressif\\frameworks\\esp-idf-v5.2.1\\tools\nChecking if Python packages are up to date...\nConstraint file: C:\\Espressif\\espidf.constraints.v5.2.txt\nRequirement files:\n - C:\\Espressif\\frameworks\\esp-idf-v5.2.1\\tools\\requirements\\requirements.core.txt\nPython being checked: C:\\Espressif\\python_env\\idf5.2_py3.13_env\\Scripts\\python.exe\nPython requirements are satisfied.\n\nDone! You can now compile ESP-IDF projects.\nGo to the project directory and run:\n    idf.py build\n\nPS C:\\Users\\professor\\git\\codeberg\\esp32_piscaLED&gt;\n</code></pre> <p>Mensagem de erro:</p> <p>Durante a cria\u00e7\u00e3o do ambiente de desenvolvimento, pode ser que ocorra um erro com a seguinte descri\u00e7\u00e3o:</p> <p><pre><code>Checking if Python packages are up to date...\nERROR: C:\\Espressif\\python_env\\idf5.2_py3.13_env\\Scripts\\python.exe doesn't exist! Please run the install script or \"idf_tools.py install-python-env\" in order to create it\n</code></pre> Uma poss\u00edvel solu\u00e7\u00e3o \u00e9 executar o seguinte comando, conforme indica\u00e7\u00e3o na pr\u00f3pria mensagem de erro:</p> <pre><code>PS C:\\Espressif\\frameworks\\esp-idf-v5.2.1\\tools&gt; idf_tools.py install-python-env\n</code></pre> bash - GNU/Linux<pre><code>Checking \"python3\" ...\nPython 3.11.2\n\"python3\" has been detected\nActivating ESP-IDF 6.0\nSetting IDF_PATH to '/home/josewrpereira/espressif/esp-idf'.\n* Checking python version ... 3.11.2\n* Checking python dependencies ... OK\n* Deactivating the current ESP-IDF environment (if any) ... OK\n* Establishing a new ESP-IDF environment ... OK\n* Identifying shell ... bash\n* Detecting outdated tools in system ... OK - no outdated tools found\n* Shell completion ... Autocompletion code generated\n\nDone! You can now compile ESP-IDF projects.\nGo to the project directory and run:\n\n  idf.py build\n</code></pre> <p>5) Criando um novo projeto</p> <pre><code>idf.py create-project -p . piscaLED\n</code></pre> <p>A arvore do projeto criado fica da seguinte forma: <pre><code>ESP32_PISCALED\n |`--- main\n |       |`--- CMakeList.txt\n |        `--- piscaLED.c\n  `--- CMakeList.txt\n</code></pre></p> <p>Os arquivos produzidos s\u00e3o:</p> ESP32_PISCALED/main/CMakeList.txt<pre><code>idf_component_register( SRCS \"piscaLED.c\"\n                        INCLUDE_DIRS \".\")\n</code></pre> ESP32_PISCALED/main/piscaLED.c<pre><code>#include &lt;stdio.h&gt;\n\nvoid app_main(void)\n{\n\n}\n</code></pre> ESP32_PISCALED/CMakeList.txt<pre><code># For more information about build system see\n# https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html\n# The following five lines of boilerplate have to be in your project's\n# CMakeLists in this exact order for cmake to work correctly\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(piscaLED)\n</code></pre> <p>6) Definindo o dispositivo alvo</p> <p><pre><code>idf.py set-target esp32\n</code></pre> \u00c0 arvore do projeto s\u00e3o incluidos o diret\u00f3rio <code>build</code> e o arquivo de configura\u00e7\u00e3o <code>sdkconfig</code>.</p> <pre><code>ESP32_PISCALED\n |`--- build\n |`--- main\n |       |`--- CMakeList.txt\n |        `--- piscaLED.c\n |`--- CMakeList.txt\n  `--- sdkconfig\n</code></pre> <p>7) Acessando o menu de configura\u00e7\u00e3o (se necess\u00e1rio)</p> <pre><code>idf.py menuconfig\n</code></pre> Figura 4: Tela do <code>menuconfig</code> Fonte: Autor <p>8) Construa o projeto (build)</p> <pre><code>idf.py build\n</code></pre> <p>9) Edite o c\u00f3digo fonte</p> <p>Altere o arquivo <code>piscaLED.c</code> conforme o seguinte c\u00f3digo: ESP32_PISCALED \u2192 main \u2192 piscaLED.c<pre><code>#include \"freertos/FreeRTOS.h\"\n#include \"driver/gpio.h\"\n\n#define BLINK_GPIO  2\n#define BLINK_DELAY 500\n\nvoid app_main(void)\n{\n    gpio_reset_pin(BLINK_GPIO);\n    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);\n    while( 1 )\n    {\n        gpio_set_level(BLINK_GPIO, 0);\n        vTaskDelay(BLINK_DELAY / portTICK_PERIOD_MS);\n        gpio_set_level(BLINK_GPIO, 1);\n        vTaskDelay(BLINK_DELAY / portTICK_PERIOD_MS);\n    }\n}\n</code></pre></p> <p>10) Reconstrua o projeto</p> <p>O processo de constru\u00e7\u00e3o do projeto (build) quando realizado a primeira vez, \u00e9 bem demorado devido \u00e0 quantidade de componentes que s\u00e3o compilados. A partir segunda chamada de build, o processo \u00e9 bem mais r\u00e1pido pois a compila\u00e7\u00e3o ocorre apenas nos componentes modificados.</p> <pre><code>idf.py build\n</code></pre> <p>11) Gravando o projeto</p> <pre><code>idf.py -p &lt;port&gt; flash\n</code></pre> <p>Pode ser necess\u00e1rio pressionar o bot\u00e3o <code>BOOT</code> na placa do ESP32 para realizar a conex\u00e3o no processo de grava\u00e7\u00e3o. O bot\u00e3o deve ser solto apenas quando se iniciar a grava\u00e7\u00e3o dos blocos de mem\u00f3ria.</p> Figura 5: Grava\u00e7\u00e3o do programa no ESP32 Fonte: Autor <p>12) Monitorando o projeto</p> <p>O monitoramento do projeto \u00e9 interessante quando o c\u00f3digo produz mensagens de log, que podem ser visualizadas no terminal.</p> <pre><code>idf.py -p &lt;port&gt; monitor\n\n# Sair do monitoramento\n# Ctrl+[ ou Ctrl+]\n</code></pre> <p>Obs: Pode ser necess\u00e1rio mudar o teclado para o padr\u00e3o US para conseguir utilizar o comando <code>Ctrl+[</code>.</p> <p>13) Limpeza do processo de constru\u00e7\u00e3o</p> <p>Exclui todos arquivos produzidos no processo de build.</p> <pre><code>idf.py fullclean\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab02-componente/","title":"Lab02 - Componente","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab02-componente/#componentes","title":"Componentes","text":"<p>1. Crie um novo projeto</p> <ol> <li>Crie um novo diret\u00f3rio para o projeto;</li> <li>Abra-o no VSCode (ou no seu editor favorito);</li> <li>Abra o terminal integrado</li> </ol> Figura 1: Novo projeto e Terminal Integrado Fonte: Autor <p>Para abrir o terminal integrado:</p> <ol> <li>Pressione <code>Ctrl+Shift+'</code>, ou</li> <li>No menu suspenso, clique em <code>Terminal</code> &gt; <code>New Terminal</code>, ou</li> <li>Clique sob o nome do diret\u00f3rio com o bot\u00e3o direito do mouse, e depois <code>Open in integrated Terminal</code>, como ilustrado na Figura 1.</li> </ol> <p>2. Habilite o ambiente de desenvolvimento no diret\u00f3rio local</p> <p>PowerShell - Windows<pre><code>C:\\Espressif\\frameworks\\esp-idf-v5.2.1\\export.ps1 .\n</code></pre> Bash - GNU/Linux<pre><code>. $HOME/espressif/esp-idf/export.sh\n</code></pre></p> <p>Obs: O caminho do <code>export.ps1</code>/<code>export.sh</code> vai mudar em fun\u00e7\u00e3o do local escolhido durante a instala\u00e7\u00e3o do framework esp-idf.</p> <p>3. Criando um novo projeto</p> <pre><code>idf.py create-project -p . component_builtinLED\n</code></pre> <p>4. Definindo dispositivo alvo</p> <pre><code>idf.py set-target esp32\n</code></pre> <p>5. Construindo o projeto</p> <pre><code>idf.py build\n</code></pre> <p>6. Criando um componente (pela primeira vez)</p> <pre><code>idf.py -C ./components create-component builtinLED\n</code></pre> <p>7. Criando c\u00f3digo do componente</p> esp32_component_builtinLED/components/builtinLED/builtinLED.c<pre><code>#include &lt;stdio.h&gt;\n#include \"driver/gpio.h\"\n#include \"builtinLED.h\"\n\n\n/**********************************************************\n * @brief Inicializa pino conectado ao LED embarcado no m\u00f3dulo\n * @param -\n**********************************************************/\nvoid builtinLED_init( void )\n{\n    gpio_reset_pin(BUILTINLED_GPIO);\n    gpio_set_direction(BUILTINLED_GPIO, GPIO_MODE_OUTPUT);\n}\n\n\n\n/**********************************************************\n * @brief Liga/Desliga LED embarcado no m\u00f3dulo\n * @param b  1 LED ON, 0 LED OFF\n**********************************************************/\nvoid builtinLED(char b)\n{\n    gpio_set_level(BUILTINLED_GPIO, b);\n}\n</code></pre> esp32_component_builtinLED/components/builtinLED/include/builtinLED.h<pre><code>#ifndef BUILTINLED_H\n#define BUILTINLED_H\n\n#define BUILTINLED_GPIO         2\n\n\nvoid builtinLED_init( void );\nvoid builtinLED(char b);\n\n\n#endif\n</code></pre> esp32_component_builtinLED/components/builtinLED/CMakeLists.txt<pre><code>idf_component_register( SRCS            \"builtinLED.c\"\n                        REQUIRES        driver\n                        INCLUDE_DIRS    \"include\")\n</code></pre> <p>8. Criando c\u00f3digo principal</p> esp32_component_builtinLED/main/component_builtinLED.c<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"builtinLED.h\"\n\nvoid app_main(void)\n{\n    builtinLED_init();\n    while( 1 )\n    {\n        builtinLED( 1 );\n        vTaskDelay(500 / portTICK_PERIOD_MS);\n        builtinLED( 0 );\n        vTaskDelay(500 / portTICK_PERIOD_MS);\n    }\n}\n</code></pre> esp32_component_builtinLED/main/CMakeLists.txt<pre><code>idf_component_register( SRCS            \"component_builtinLED.c\"\n                        REQUIRES        builtinLED\n                        INCLUDE_DIRS    \".\")\n</code></pre> <p>9. CMakeLists inicial</p> esp32_component_builtinLED/CMakeLists.txt<pre><code># For more information about build system see\n# https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html\n# The following five lines of boilerplate have to be in your project's\n# CMakeLists in this exact order for cmake to work correctly\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(component_builtinLED)\n</code></pre> <p>10. Compilando o projeto</p> <pre><code>idf.py build\n</code></pre> <p>11. Gravando o programa no dispositivo alvo</p> <pre><code>idf.py -p COM3 flash\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab02-led_rgb/","title":"Lab02 - LED RGB","text":"","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/iot/esp32/lab02-led_rgb/#led-rgb","title":"LED RGB","text":"<p>Criando o primeiro componente</p> <pre><code>idf.py -C ./components create-component led_rgb\n</code></pre> <ul> <li>Arquivo: <code>.../main/CMakeLists.txt</code> <pre><code>idf_component_register( SRCS        \"piscaLED.c\"\n                        REQUIRES    led_rgb\n                        INCLUDE_DIRS \".\")\n</code></pre></li> </ul> <ul> <li>Arquivo: <code>.../components/led_rgb/CMakeLists.txt</code> <pre><code>idf_component_register( SRCS            \"led_rgb.c\"\n                        REQUIRES        driver\n                        INCLUDE_DIRS    \"include\")\n</code></pre></li> </ul> <ul> <li>Arquivo: <code>.../main/piscaLED.c</code> <pre><code>#include \"led_rgb.h\"\n</code></pre></li> </ul>","tags":["Sistemas Eletr\u00f4nicos","Conectividade","ESP32"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/","title":"Ambienta\u00e7\u00e3o","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/#ferramentas-de-desenvolvimento","title":"Ferramentas de Desenvolvimento","text":"Componente Modelo Descri\u00e7\u00e3o Microcontrolador AVR - ATMega328P Plataforma Arduino Uno como interface IDE MPLabX Ambiente de Desenvolvimento Integrado - Instala\u00e7\u00e3o Compilador XC8 Instala\u00e7\u00e3o Editor de c\u00f3digo Notepad++ v8.7.7 Construtor de projeto Makefile Power Shell<code>winget install Chocolatey.Chocolatey</code>  Power Shell Admin:  <code>choco install make</code> Gravador do AVR AVRDudess ZakKemble/AVRDUDESS/v2.18 Simulador eletr\u00f4nico SimulIDE Power Shell<code>winget install SimulIDE.SimulIDE</code> Versionamento git Power Shell<code>winget install --id Git.Git -e --source winget</code>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/#fluxo-de-trabalho-com-git-e-github","title":"Fluxo de trabalho com git e GitHub","text":"Fluxo simples de trabalho com git e GitHub Fonte: Autor","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/#metodologia-de-trabalho-baseada-em-projetos","title":"Metodologia de trabalho baseada em Projetos","text":"<p>0. Objetivo: Nome significativo para o projeto</p> <p>Descrever o que deve ser feito, de forma objetiva e clara.</p> <p>1. Requisitos da solu\u00e7\u00e3o</p> <ul> <li>Descrever caracter\u00edsticas fundamentais para opera\u00e7\u00e3o. </li> <li>Descrever comportamentos do sistema. </li> </ul> <p>2. Planejamento da solu\u00e7\u00e3o</p> <p>Definir como ser\u00e1 feita a entrega: simulador, montagem em prot\u00f3tipo, montagem em painel ou placa de circuito impresso (PCI), etc, listar os materiais e ferramentas em fun\u00e7\u00e3o do tipo de entrega e explicitar como, utilizando os materiais listados e manipulando as ferramentas, chega-se ao produto final, com um encadeamento l\u00f3gico das tarefas que integram o processo.</p> <ul> <li>2.1 - Planejamento do produto final</li> <li>2.2 - Planejamento das ferramentas e materiais</li> <li>2.3 - Planejamento do processo</li> </ul> <p>3. Solu\u00e7\u00e3o</p> <p>Produto ou processo que atinge o objetivo proposto, atrav\u00e9s da execu\u00e7\u00e3o do seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/#avr-pisca-led","title":"AVR Pisca LED","text":"<p>O primeiro programa para dispositivos embarcados, costuma ser um programa para piscar um LED, que serve para testar as ferramentas de compila\u00e7\u00e3o e grava\u00e7\u00e3o, verificando sua integridade e capacidade de execu\u00e7\u00e3o.</p> <p>Este projeto cont\u00e9m um programa m\u00ednimo para piscar um LED na plataforma Arduino Uno, por\u00e9m o seu desenvolvimento se d\u00e1 com a utiliza\u00e7\u00e3o e programa\u00e7\u00e3o do microcontrolador de forma direta, sem a utiliza\u00e7\u00e3o do que chamamos framework Arduino.</p> <p>Para testar a integridade das ferramentas de desenvolvimento aqui utilizadas, no seu computador, siga os passos: </p> <p>1. Baixar o projeto do servidor git (Codeberg ou Github);</p> <p>1.1 No terminal (Windows Power Shell), crie um diret\u00f3rio para armazenar os projetos:</p> <pre><code>mkdir projetos\n</code></pre> <p>1.2 Acesso o diret\u00f3rio criado: </p> <pre><code>cd projetos\n</code></pre> <p>1.3 Clone o projeto de teste:</p> <p>Github: <pre><code>git clone https://github.com/JoseWRPereira/avr_pisca_led.git\n</code></pre></p> <p>ou</p> <p>Codeberg: <pre><code>git clone https://codeberg.org/JoseWRPereira/avr_pisca_led.git\n</code></pre></p> <p>1.4 Acesse o diret\u00f3rio do projeto baixado: </p> <p><pre><code>cd avr_pisca_led\n</code></pre> 1.5 Resumo </p> <p>2. Abrindo arquivos de edi\u00e7\u00e3o:</p> <p>2.1 \u00c9 poss\u00edvel abrir o notepad++ com os arquivos .c e .h que houverem no diret\u00f3rio corrente, executando o seguinte comando:  <pre><code>make notepad\n</code></pre></p> <p>2.2 V\u00e1 em <code>Arquivo</code>, <code>Abrir...</code> e abra o arquivo <code>makefile.mak</code>. </p> <p>2.3 Verifique o local e a vers\u00e3o do compilador conforme ilustra\u00e7\u00e3o. </p> <p>2.4 Resumo </p> <p>3. Verificando porta de comunica\u00e7\u00e3o para grava\u00e7\u00e3o:</p> <p>3.1 Conecte o Arduino ao conector USB e verifique qual foi a porta alocada para ele: <code>Gerenciador de Dispositivos</code> e a aba <code>Portas(COM e LPT)</code> </p> <p></p> <p>3.2 Se necess\u00e1rio ajuste na linha 1 do <code>makefile.mak</code> com a porta de conex\u00e3o com o seu Arduino.</p> <p>4. Compilando e gravando o projeto: </p> <p>4.1 Se todos os programas estiverem instalados e nos locais apontados no <code>makefile.mak</code>, ent\u00e3o:</p> <p>4.1.1 Para compilar o projeto execute:  </p> <pre><code>make\n</code></pre> <p>4.1.2 Para fazer o a grava\u00e7\u00e3o do bin\u00e1rio no microcontrolador(ATmega328P) do Arduino.</p> <pre><code>make flash\n</code></pre> <p>4.2 Resumo </p> <p>5. Criando um circuito no SimulIDE</p> <p>5.1 Para criar um projeto no SimulIDE, basta abrir o software, e inserir os componentes.</p> <p>5.2 Para inserir um componente basta clicar sobre ele, na barra de ferramentas, e arrast\u00e1-lo at\u00e9 a \u00e1rea de trabalho, soltando-o na posi\u00e7\u00e3o desejada.</p> <p>5.3 Inserir:</p> <ul> <li>Componentes &gt; Microcontroladores &gt; Arduino &gt; Uno</li> <li>Componentes &gt; Passivos &gt; Resistors &gt; Resistor</li> <li>Componentes &gt; Sa\u00eddas &gt; Leds &gt; LED</li> <li>Componentes &gt; Fontes &gt; Terra (0 V)</li> </ul> <p>5.4 Ap\u00f3s inserir todos os componentes na \u00e1rea de trabalho, posicione-os de forma que o circuito fique leg\u00edvel e bem organizado. </p> <ul> <li>Girar: Para girar um componente, basta clicar com o bot\u00e3o direito sobre o elemento, e escolher uma das op\u00e7\u00f5es de girar ou inverter.</li> </ul> <p>5.5 A ferramenta de linha \u00e9 acionada ao posicionar o cursor sobre um terminal de componente, clicando sobre ele, \u00e9 iniciada uma linha de conex\u00e3o, que pode ser estendida, seguindo a orienta\u00e7\u00e3o vertical ou horizontal at\u00e9 o ponto de conex\u00e3o de destino. </p> <p>5.6 Resumo  </p> <p>6.0 Simula\u00e7\u00e3o de Pisca LED</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab00-ambientacao/#template-para-um-novo-projeto","title":"Template para um novo projeto","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab01-sinalizador_garagem/","title":"Lab 1 - Sinalizador de Garagem","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab01-sinalizador_garagem/#situacao-de-aprendizagem","title":"Situa\u00e7\u00e3o de Aprendizagem","text":"<p>1. Objetivo: Sinalizador de garagem</p> <p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de sinaliza\u00e7\u00e3o de seguran\u00e7a para sa\u00edda de ve\u00edculos em garagem.</p> <p></p> <p>2. Requisitos da solu\u00e7\u00e3o</p> <ol> <li>Intervalo de altern\u00e2ncia entre luzes: 1s;</li> <li>Luzes piscando enquanto o port\u00e3o estiver aberto.</li> </ol> <p>3. Planejamento da solu\u00e7\u00e3o</p> <ol> <li>Planejamento do produto final<ol> <li>Arquivo de simula\u00e7\u00e3o;</li> <li>Imagem de circuito de simula\u00e7\u00e3o como ilustra\u00e7\u00e3o;</li> <li>Montagem de prot\u00f3tipo funcional em matriz de contatos.</li> </ol> </li> <li> <p>Planejamento das ferramentas e materiais</p> <ul> <li>Ferramentas:<ul> <li>Simulador: SimulIDE (v1.1.0 Stable Version)</li> <li>Compilador: XC8</li> <li>Gravador: AVRDUDESS</li> <li>Editor de c\u00f3digo: Notepad++</li> <li>Construtor do projeto: Makefile</li> <li>Versionamento: git</li> </ul> </li> <li>Materiais:<ul> <li>01 - Arduino Uno + Cabo de conex\u00e3o;</li> <li>01 - Matriz de contatos (Protoboard);</li> <li>02 - LEDs (Vermelho e Amarelo);</li> <li>02 - Resistores para os LEDs;</li> <li>01 - Bot\u00e3o ou chave de sele\u00e7\u00e3o;</li> <li>01 - Resistor de pull-up.</li> </ul> </li> </ul> </li> <li> <p>Planejamento do processo</p> <ol> <li>Criar o projeto na plataforma de versionamento;</li> <li>Definir mapa de entradas e sa\u00eddas;</li> <li>Construir o circuito no simulador;</li> <li>Criar projeto de valida\u00e7\u00e3o do circuito no simulador;</li> <li>Criar programa(firmware) da aplica\u00e7\u00e3o;</li> <li>Montar circuito em matriz de contatos;</li> <li>Testar programa(firmware) na montagem do prot\u00f3tipo;</li> <li>Registrar resultado da atividade.</li> </ol> </li> </ol> <p>4. Solu\u00e7\u00e3o</p> <p>Produto ou processo que atinge o objetivo proposto, atrav\u00e9s da execu\u00e7\u00e3o do seu planejamento e satisfa\u00e7\u00e3o dos seus requisitos.</p> <p>Na etapa inicial da solu\u00e7\u00e3o, crie um projeto em uma plataforma de versionamento, seja ela codeberg, gitlab, github ou qualquer outra plataforma de sua prefer\u00eancia.</p> <p>4.1. Criando um projeto de versionamento no codeberg</p> <p></p> <p>Ap\u00f3s criar o projeto, fa\u00e7a o download para um reposit\u00f3rio local, que servir\u00e1 para alocar e armazenar a simula\u00e7\u00e3o e o firmware durante o desenvolvimento.</p> <p>4.2. Download do projeto criado em reposit\u00f3rio local</p> <p></p> <p>Crie um projeto no simulIDE, e salve-o em um diret\u00f3rio <code>sim</code> dentro do diret\u00f3rio do projeto.</p> <p>Em seguida, adicione-o ao <code>stage</code> e realize o <code>commit</code> da nova mudan\u00e7a, seguindo com o <code>push</code> para o reposit\u00f3rio remoto.</p> <p>4.3. Criando simula\u00e7\u00e3o e incluindo no reposit\u00f3rio</p> <p></p> <p>4.4. Definindo mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Entrada Fim-de-curso Acionado quando o port\u00e3o estiver aberto 8 14 PB0 Sa\u00edda LED Sinaleiro Amarelo 12 18 PB4 Sa\u00edda LED Sinaleiro Vermelho 13 19 PB5 <p>4.5. Construindo o circuito no simulador</p> <p></p> <p>Copie os arquivos <code>main.c</code> e <code>makefile.mak</code> de um projeto j\u00e1 existente (avr_pisca_led). Isso facilita a constru\u00e7\u00e3o do projeto, editando apenas no nome do projeto no arquivo de constru\u00e7\u00e3o e alterando o conte\u00fado de main.c, bem como incluindo c\u00f3digos ou outros arquivos de acordo com o desenvolvimento do projeto.</p> <p>4.6. Criando arquivos de c\u00f3digo fonte</p> <p></p> <p>C\u00f3digo fonte</p> <pre><code>#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;PINB0))\n        {\n            PORTB |= (1&lt;&lt;PORTB4);\n            PORTB &amp;= ~(1&lt;&lt;PORTB5);\n            _delay_ms(500);\n            PORTB ^= (1&lt;&lt;PORTB4 | 1&lt;&lt;PORTB5);\n            _delay_ms(500);\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;PORTB4);\n            PORTB &amp;= ~(1&lt;&lt;PORTB5);\n        }\n    }\n}\n</code></pre> <p>4.7. Carregando arquivo execut\u00e1vel na simula\u00e7\u00e3o</p> <p></p> <p>4.8. Incluindo mudan\u00e7as na plataforma de versionamento</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab01-sinalizador_garagem/#entradas-e-saidas-digitais","title":"Entradas e Sa\u00eddas Digitais","text":"<p>Sa\u00eddas Digitais</p> <p>O dispositivo respons\u00e1vel por acionar o LED \u00e9 o microcontrolador(uC), atrav\u00e9s de um pino configurado como sa\u00edda. Este pino pode estar fornecendo corrente como fonte (source) ao ramo ou drenando (sink) corrente dele.</p> Liga\u00e7\u00e3o do pino como fonte (Source) Liga\u00e7\u00e3o do pino como dreno (Sink) <p>O pino do uC possui limita\u00e7\u00e3o de corrente, que pode variar a depender do modelo ou fabricante.</p> <p>A corrente m\u00e1xima por pino \u00e9 de <code>40 mA</code>, de acordo com o Datasheet (AVR ATmega328P, cap\u00edtulo 28.1 Absolute maximum ratings, p\u00e1g. 258).</p> <p>A vantagem de utilizar o pino como fonte \u00e9 trabalhar com uma l\u00f3gica direta, em que o estado l\u00f3gico 1(verdadeiro, +5V) produz o acionamento do LED, enquanto que na configura\u00e7\u00e3o do pino como dreno a l\u00f3gica de acionamento \u00e9 invertida, pois o pino em estado l\u00f3gico 0(falso, 0V) produz o acionamento do LED.</p> <p>Entradas Digitais</p> <p>A entrada deve possuir um estado l\u00f3gico bem definido, mas um bot\u00e3o pulsador n\u00e3o garante esse estado l\u00f3gico, pois possui apenas dois contatos, podendo sua configura\u00e7\u00e3o ser normalmente aberto (NA) ou normalmente fechado(NF). Na figura abaixo \u00e9 utilizado um bot\u00e3o pulsador NA, que \u00e9 a configura\u00e7\u00e3o mais comum.</p> <p>Para garantir o tal estado l\u00f3gico bem definido, \u00e9 montado um ramo com o bot\u00e3o e um resistor, geralmente com 10k\u03a9, ligados em s\u00e9rie, entre o Vcc e o GND. No ponto de conex\u00e3o entre esses dois componentes temos, em rela\u00e7\u00e3o ao terra (GND), uma tens\u00e3o que \u00e9 a tens\u00e3o do componente conectado ao terra. Este ponto \u00e9 conectado ao pino do uC, assim a tens\u00e3o no pino \u00e9 a mesma tens\u00e3o sobre o componente ligado ao terra.</p> <p>As duas configura\u00e7\u00f5es poss\u00edves s\u00e3o mostradas na ilustra\u00e7\u00e3o abaixo, em que o bot\u00e3o est\u00e1 conectado ao Vcc e a outra em que o bot\u00e3o est\u00e1 conectado ao terra.</p> Liga\u00e7\u00e3o do resistor de pull-down Liga\u00e7\u00e3o do resistor de pull-up <p>Na configura\u00e7\u00e3o pull-down o resistor est\u00e1 conectado ao terra, o que garante, quando o bot\u00e3o estiver aberto, o n\u00edvel l\u00f3gico 0 (terra/GND) chegando no pino do uC.</p> <p>Ao pressionar o bot\u00e3o, ele fecha e conecta o ponto de conex\u00e3o com o pino ao Vcc, aplicando o n\u00edvel l\u00f3gico 1 a ele.</p> <p>Na configura\u00e7\u00e3o pull-up o resistor est\u00e1 conectado ao positivo da fonte, Vcc. O bot\u00e3o na condi\u00e7\u00e3o de n\u00e3o acionado est\u00e1 com contato aberto, assim a tens\u00e3o sobre ele \u00e9 a tens\u00e3o da fonte, nesse caso 5V, conforme a 2\u00aa lei de Kirchhoff, garantindo o n\u00edvel l\u00f3gico 1.</p> <p>Ao pressionar o bot\u00e3o, ele fecha, ligando o ponto de conex\u00e3o com o pino do uC ao GND, aplicando o n\u00edvel l\u00f3gico 0 a ele.</p> <p>A configura\u00e7\u00e3o com o resistor de pull-down \u00e9 a que proporciona uma l\u00f3gica direta a entrada do dado: bot\u00e3o pressionado.</p> <p></p> <p>Registradores de configura\u00e7\u00e3o dos pinos do PORTB</p> <p></p> <p></p> <p>Circuito geral dos pinos de entrada e sa\u00edda</p> <p></p> <p></p> <p>Acionamento do circuito de entrada e sa\u00edda em fun\u00e7\u00e3o do comando</p> <p></p> <p></p> <p>Configurando Entradas e Sa\u00eddas</p> <p>Para a configura\u00e7\u00e3o das entradas e sa\u00eddas, \u00e9 necess\u00e1rio que sejam definidos os pinos para cada fun\u00e7\u00e3o da interface na aplica\u00e7\u00e3o. Como exemplo, \u00e9 usado o mesmo mapa de entradas e sa\u00eddas da situa\u00e7\u00e3o de aprendizagem do sinalizador de garagem.</p> <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Entrada Fim-de-curso Acionado quando o port\u00e3o estiver aberto 8 14 PB0 Sa\u00edda LED Sinaleiro Amarelo 12 18 PB4 Sa\u00edda LED Sinaleiro Vermelho 13 19 PB5 <p>As colunas de pinagem, tanto da placa de desenvolvimento (Pino (Arduino Uno)) quanto do microcontrolador (Pino (ATmega328P)), facilitam a identifica\u00e7\u00e3o dos pontos de conex\u00e3o nas situa\u00e7\u00f5es em que \u00e9 realizada a montagem de circuito em matriz de contatos, para execu\u00e7\u00e3o de prot\u00f3tipos ou o roteamento de trilhas em placa de circuito impresso, respectivamente.</p> <p>A coluna PORT nos evidencia o registrador e o bit que deve ser  configurado no programa para implementa\u00e7\u00e3o da funcionalidade da aplica\u00e7\u00e3o.</p> <p>Sendo assim, para a configura\u00e7\u00e3o no programa (firmware), as colunas mais importantes inicialmente s\u00e3o as colunas de Fun\u00e7\u00e3o e PORT.</p> <p>A configura\u00e7\u00e3o dos pinos pode ser realizada de forma unit\u00e1ria ou atrav\u00e9s de uma escrita \u00fanica em cada registrador, configurando todos os pinos representados por ele de uma s\u00f3 vez.</p> <p>Para a configura\u00e7\u00e3o individual de pinos, \u00e9 necess\u00e1rio usar o seguinte padr\u00e3o de ligar um bit ou zer\u00e1-lo:</p> <p>Para ligar (setar) um bit dentro de um registrador: <pre><code>  registrador |= (1&lt;&lt;numero_do_bit);\n</code></pre></p> <p>Para zerar (resetar) um bit dentro de um registrador: <pre><code>  registrador &amp;= ~(1&lt;&lt;numero_do_bit);\n</code></pre> Sendo o <code>numero_do_bit</code> um valor de <code>0</code> a <code>7</code>, ou ainda, podem-ser utilizados os <code>defines</code> declarados na biblioteca, como: <code>PINB0</code> que corresponde ao <code>0</code>, <code>PINB1</code> correpondente ao <code>1</code> e assim por diante. Da mesma forma para os PORT e o DDR: <code>PORTB0</code>, <code>PORTB1</code>,..., e <code>DDRB0</code>, <code>DDRB1</code>, ... </p> <p>Para configurar um pino como entrada, \u00e9 necess\u00e1rio zerar o respectivo bit do registrador <code>DDRx</code> e ligar ou desligar o Resistor de Pull-up interno pelo registrador <code>PORTx</code>.</p> <p>No exemplo, temos que configurar o <code>PB0</code> como entrada. Assim, s\u00e3o utilizados os registradores <code>DDRB</code> para a dire\u00e7\u00e3o de entrada e o <code>PORTB</code> para desabilitar o Resistor de Pull-Up interno, pois no exemplo, \u00e9 utilizado um resistor de Pull-Up externo. <pre><code>    // Configura\u00e7\u00e3o das Entradas\n  DDRB &amp;= ~(1&lt;&lt;0);      // PB0 &lt;- 0\n  PORTB &amp;= ~(1&lt;&lt;0);     // PB0 Pull-up OFF\n</code></pre></p> <p>Ainda no exemplo, temos que configurar e inicializar os pinos de sa\u00edda: PB4 e PB5. Da mesma forma, s\u00e3o utilizados os registradores <code>DDRB</code> para configura\u00e7\u00e3o de sa\u00edda e <code>PORTB</code> para acionar um n\u00edvel l\u00f3gico no pino do microcontrolador.</p> <pre><code>    // Configura\u00e7\u00e3o das Sa\u00eddas\n  DDRB |= (1&lt;&lt;4);       // PB4 &lt;- 1\n  DDRB |= (1&lt;&lt;5);       // PB4 &lt;- 1\n    // Inicializa\u00e7\u00e3o do estado l\u00f3gico dos pinos\n  PORTB &amp;= ~(1&lt;&lt;4);      // PB4 &lt;- 0\n  PORTB &amp;= ~(1&lt;&lt;5);      // PB5 &lt;- 0\n</code></pre> <p>Note que a fun\u00e7\u00e3o do registrador <code>PORTx</code> depende da configura\u00e7\u00e3o do registrador <code>DDRx</code>.</p> <p>No nosso exemplo, todos os pinos utilizados pertencem ao mesmo PORT, assim, \u00e9 poss\u00edvel realizar a configura\u00e7\u00e3o dos tr\u00eas elementos todos de uma \u00fanica vez:</p> <p>O bit 0 (PB0) deve ser configurado como entrada (E) e os bits 4 e 5 (PB4 e PB5) devem ser configurados como sa\u00eddas (S).</p> <pre><code>  // Configura\u00e7\u00e3o do registrador de dire\u00e7\u00e3o de dados (Entrada / Sa\u00edda)\n\n  // DDRx = 0b--SS---E;\n\n  // Onde:\n  //      0b: Nota\u00e7\u00e3o que indica n\u00famero com nota\u00e7\u00e3o bin\u00e1ria.\n  //      E: Entradas (0)\n  //      S: Sa\u00edda (1)\n  //      -: Bit n\u00e3o utilizado.\n\n  // Reescrevendo com os valores adequados no Registrador dos pinos PB0, PB4 e PB5:\n\n  // DDRB = 0b--11---0;\n\n  // Os pinos n\u00e3o utilizados (-) devem ser configurados como entradas (0):\n\n  DDRB = 0b00110000;\n</code></pre> <p>Ap\u00f3s a configura\u00e7\u00e3o do <code>DDRx</code> \u00e9 a vez do <code>PORTx</code>.</p> <pre><code>  // Configura\u00e7\u00e3o de resistor de pull-up para entradas e estado l\u00f3gico para as sa\u00eddas.\n\n  // PORTB = 0b--SS---E;\n  // Onde:\n  //      E: Entradas (0)\n  //      S: Sa\u00edda (1)\n  //      -: Bit n\u00e3o utilizado.\n\n  // Como os bits n\u00e3o utilizados s\u00e3o entradas:\n\n  // PORTB = 0bEESSEEEE;\n\n  // Desligando os resistores de pull-up internos:\n\n  // PORTB = 0b00SS0000;\n\n  // Desligando o estado l\u00f3gico das sa\u00eddas PB4 e PB5:\n\n  PORTB = 0b00000000;\n</code></pre> <p>Os valores carregados nos registradores s\u00e3o costumeiramente notados com valores em hexadecimal:</p> <pre><code>  DDRB  = 0x30;\n  PORTB = 0x00;\n</code></pre> <p>Qualquer forma de configura\u00e7\u00e3o pode ser utilizada, tanto um bit por vez quanto a escrita integral dos registradores, anotados com valores em bin\u00e1rio, decimal ou hexadecimal.</p> <p>Resumo da configura\u00e7\u00e3o dos pinos no ATmega328P</p> <pre><code>///////////////////////////////////////////////////////////////////////////////\n//  Registradores de configura\u00e7\u00e3o e manipula\u00e7\u00e3o de dados nos pinos\n//\n//        DDRxn   :   Data Direction Register\n//        PORTxn  :   Data Register\n//        PINxn   :   Input Pin Address\n//\n//        ===================\n//        x |        n\n//        ===================\n//        B | 7 6 5 4 3 2 1 0\n//        C |   6 5 4 3 2 1 0\n//        D | 7 6 5 4 3 2 1 0\n//        E |         3 2 1 0\n//        ===================\n//\n//  Configura\u00e7\u00e3o e Manipula\u00e7\u00e3o de dados nos pinos\n//\n//        DDRxn = 1;          // Output\n//            {\n//                PORTxn = 1; //          High\n//                PORTxn = 0; //          Low\n//            }\n//\n//        DDRxn = 0;          // Input\n//            {\n//                PORTxn = 0; //          Pull-Up Resistor OFF\n//                PORTxn = 1; //          Pull-Up Resistor ON\n//                {\n//                    (PINxn == 1)    //  ON\n//                    (PINxn == 0)    //  OFF\n//                }\n//            }\n//        \n////////////////////////////////////////////////////////////////////////////////\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab01-sinalizador_garagem/#codigo-fonte-em-etapas","title":"C\u00f3digo fonte em etapas","text":"<p>1) Estrutura b\u00e1sica de um c\u00f3digo em linguagem C.</p> <pre><code>int main(void)\n{   \n  while (1)\n  {\n\n  }\n}\n</code></pre> <p></p> <p>2) Configura\u00e7\u00e3o de entradas e sa\u00eddas</p> <pre><code>#include &lt;avr/io.h&gt;\n\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n\n    }\n}\n</code></pre> <p>3) Acionamento do LED conectado ao pino de sa\u00edda (13 - PB5)</p> <pre><code>#include &lt;avr/io.h&gt;\n\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        PORTB &amp;= ~(1&lt;&lt;5);       // Desliga LED\n\n        PORTB ^=  (1&lt;&lt;5);       // Liga LED\n\n    }\n}\n</code></pre> <p>4) Inclus\u00e3o de atraso entre os acionamentos do LED</p> <pre><code>#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        PORTB &amp;= ~(1&lt;&lt;5);       // Desliga LED\n        _delay_ms(500);         // Atraso de 500ms\n        PORTB ^=  (1&lt;&lt;5);       // Liga LED\n        _delay_ms(500);         // Atraso de 500ms\n    }\n}\n</code></pre> <p></p> <p>5) Leitura da entrada: fim-de-curso (bot\u00e3o/sensor)</p> <pre><code>#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;0) )         // Leitura do fim-de-curso\n        {\n            PORTB &amp;= ~(1&lt;&lt;5);       // Desliga LED\n            _delay_ms(500);         // Atraso de 500ms\n            PORTB ^=  (1&lt;&lt;5);       // Liga LED\n            _delay_ms(500);         // Atraso de 500ms\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;5);       // Desliga LED\n        }\n    }\n}\n</code></pre> <p></p> <p>6) Inclus\u00e3o da segunda sa\u00edda (LED)</p> <pre><code>#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;0))\n        {\n            PORTB |= (1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n            _delay_ms(500);\n            PORTB ^= (1&lt;&lt;4 | 1&lt;&lt;5);\n            _delay_ms(500);\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n        }\n    }\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab01-sinalizador_garagem/#comparacao-entre-codigos-fonte-qual-e-o-melhor","title":"Compara\u00e7\u00e3o entre c\u00f3digos fonte: Qual \u00e9 o melhor?","text":"<p>C\u00f3digo utilizando o framework Arduino.</p> <pre><code>// C\u00f3digo .ino\n\nvoid setup()\n{\n  pinMode(13, OUTPUT);\n  pinMode(12, OUTPUT);\n  pinMode( 8, INPUT);\n}\n\nvoid loop()\n{\n  if( digitalRead(8) == 1 )\n  {\n    digitalWrite(12, HIGH);\n    digitalWrite(13, LOW);\n    delay(500);\n    digitalWrite(12, LOW);\n    digitalWrite(13, HIGH);\n    delay(500);\n  }\n  else\n  {\n    digitalWrite(12, LOW);\n    digitalWrite(13, LOW);\n  }\n}\n</code></pre> <p>C\u00f3digo fonte em linguagem C para AVR.</p> <pre><code>// C\u00f3digo .c\n\n#define F_CPU 16000000L\n#include &lt;avr/io.h&gt;\n#include &lt;util/delay.h&gt;\nint main(void)\n{   \n    DDRB = 0b00110000;\n    PORTB = 0;\n    while (1)\n    {\n        if( PINB &amp; (1&lt;&lt;0))\n        {\n            PORTB |= (1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n            _delay_ms(500);\n            PORTB ^= (1&lt;&lt;4 | 1&lt;&lt;5);\n            _delay_ms(500);\n        }\n        else\n        {\n            PORTB &amp;= ~(1&lt;&lt;4);\n            PORTB &amp;= ~(1&lt;&lt;5);\n        }\n    }\n}\n</code></pre> <p>C\u00f3digo fonte em linguagem Assembly para AVR.</p> <pre><code>; C\u00f3digo .asm\n\n            ; Inclus\u00e3o das defini\u00e7\u00f5es de pinos fornecidas pelo fabricante\n.include \"m328pdef.inc\"\n\n                ; Programa alocado no endera\u00e7o 0 da mem\u00f3ria de c\u00f3digo.\n.ORG 0X0000\n\n                ; PB5, PB4: out;    PB0: in;    0b00110000 = 0x30\n    LDI     R16,0x30\n    OUT     DDRB,R16\n\nDESLIGA_LEDS:\n    LDI     R16,0x00\n    OUT     PORTB,R16\n\nINICIO:\n    IN      R16,PINB\n    SBRS    R16,0\n    RJMP    DESLIGA_LEDS\n\n    RCALL   DELAY\n    SBI     PORTB,PB5\n    CBI     PORTB,PB4\n    RCALL   DELAY\n    CBI     PORTB,PB5\n    SBI     PORTB,PB4\n    RJMP    INICIO\n\nDELAY:\n    LDI     R16,0\n    LDI     R17,0\n    LDI     R18,41\nDELAY_LOOP:\n    INC     R16\n    BRNE    DELAY_LOOP\n    INC     R17\n    BRNE    DELAY_LOOP\n    DEC     R18\n    BRNE    DELAY_LOOP\n    RET\n</code></pre> <p>O arquivo de inclus\u00e3o do projeto em Assembly <code>m328pdef.inc</code> cont\u00e9m a defini\u00e7\u00e3o dos registradores e seus respectivos endere\u00e7os. Este arquivo \u00e9 fornecido pelo fabricante.</p> <p>Ap\u00f3s a compila\u00e7\u00e3o dos c\u00f3digos, s\u00e3o gerados arquivos .hex equivalentes em comportamento, por\u00e9m com uma diferen\u00e7a absurda em termos de ocupa\u00e7\u00e3o de mem\u00f3ria.</p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab02-partida_estrela_triangulo/","title":"Lab 2 - Partida Estrela-Tri\u00e2ngulo","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab02-partida_estrela_triangulo/#situacao-de-aprendizagem","title":"Situa\u00e7\u00e3o de Aprendizagem","text":"<p>1. Objetivo: Partida Estrela-Tri\u00e2ngulo</p> <p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de comando para partida Estrela-Tri\u00e2ngulo. </p> Figura 1: Diagramas de comando e pot\u00eancia da partida Estrela-Tri\u00e2ngulo Fonte: Wikipedia <p>2. - Requisitos da solu\u00e7\u00e3o</p> <ol> <li>Interface<ol> <li>Bot\u00e3o de partida: S1;</li> <li>Bot\u00e3o de parada: S0;</li> <li>Contatores de acionamento do motor: K1, K2 e K3.</li> </ol> </li> <li>Comportamento<ul> <li>Ao pressionar S1<ul> <li>Ligar K1, K2 (fechamento estrela);</li> <li>Temporizar 5 segundos</li> <li>Desligar K2 e ligar K3 (fechamento tri\u00e2ngulo).</li> </ul> </li> <li>Ao pressionar S0, em qualquer momento:<ul> <li>Desligar todos os contatores.</li> </ul> </li> </ul> </li> <li>Estrutura (Hardware): Circuito eletr\u00f4nico<ul> <li>Acionamento via Rel\u00e9 ou transistor;</li> <li>Tens\u00e3o opera\u00e7\u00e3o: 24V, 12V ou 5V.</li> </ul> </li> </ol> <p>3. Planejamento da solu\u00e7\u00e3o</p> <ol> <li> <p>Planejamento do produto final</p> <ol> <li>Projeto em plataforma de versionamento;</li> <li>C\u00f3digo fonte;</li> <li>Simula\u00e7\u00e3o;</li> <li>Prot\u00f3tipo (opcional);</li> <li>Circuito eletr\u00f4nico (opcional).</li> </ol> </li> <li> <p>Planejamento das ferramentas e materiais</p> </li> <li> <p>Planejamento do processo</p> <ol> <li>Criar o projeto na plataforma de versionamento;</li> <li>Definir mapa de entradas e sa\u00eddas;</li> <li>Construir o circuito no simulador;</li> <li>Criar projeto de valida\u00e7\u00e3o do circuito no simulador;</li> <li>Criar programa(firmware) da aplica\u00e7\u00e3o;</li> <li>Montar circuito em matriz de contatos;</li> <li>Testar programa(firmware) na montagem do prot\u00f3tipo;</li> <li>Registrar resultado da atividade.</li> </ol> </li> </ol> <p>4. Solu\u00e7\u00e3o</p> <p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab03-semaforo/","title":"Lab 3 - Sem\u00e1foro","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab03-semaforo/#situacao-de-aprendizagem","title":"Situa\u00e7\u00e3o de Aprendizagem","text":"<p>1. Objetivo: Sem\u00e1foro</p> <p>Desenvolver uma aplica\u00e7\u00e3o, projeto eletr\u00f4nico e programa, para um dispositivo de controle de tr\u00e1fego (sem\u00e1foro), a ser instalado em um cruzamento de pedestre. </p> Figura 1a: Exemplo de cruzamento de pedestres Figura 1b: Sem\u00e1foro para ve\u00edculos Fonte: freepik <p>2. Requisitos da solu\u00e7\u00e3o</p> <ol> <li>Interface<ol> <li>Sem\u00e1foro de ve\u00edculos (Vm, Am, Vd);</li> <li>Sem\u00e1foro de pedestres (Vd, Vm);</li> <li>Bot\u00e3o pulsador para pedestres.</li> </ol> </li> <li>Comportamento<ul> <li>Intervalo de tempo para o Sem\u00e1foro de Ve\u00edculos(sv):<ul> <li>Verde: 42s</li> <li>Amarelo: 3s</li> <li>Vermelho: 15s</li> </ul> </li> <li>Sem\u00e1foro de Pedestre(sp) sincronizado com o de ve\u00edculos:<ul> <li>Verde (sv) : Vermelho (sp)</li> <li>Amarelo (sv) : Vermelho (sp)</li> <li>Vermelho (sv) : Verde (sp)</li> <li>Piscar Vermelho (sp) 3x antes de mudar em definitivo.</li> </ul> </li> <li>Bot\u00e3o pulsador para antecipar libera\u00e7\u00e3o de passagem dos pedestres:<ul> <li>Se faltar mais do que 10s para o acionamento da cor amarela, reduzir para 10s.</li> <li>Se faltar menos do que 10s para o acionamento da cor amarela, manter o tempo restante.</li> </ul> </li> </ul> </li> <li>Estrutra (Hardware): Circuito eletr\u00f4nico<ul> <li>Pot\u00eancia por sinaleiro: 7W</li> <li>Tens\u00e3o de opera\u00e7\u00e3o: 24V</li> </ul> </li> </ol> <p>3. Planejamento da solu\u00e7\u00e3o</p> <ol> <li> <p>Planejamento do produto final</p> <ol> <li>Projeto em plataforma de versionamento;</li> <li>C\u00f3digo fonte;</li> <li>Simula\u00e7\u00e3o;</li> <li>Prot\u00f3tipo (opcional);</li> <li>Circuito eletr\u00f4nico (opcional).</li> </ol> </li> <li> <p>Planejamento das ferramentas e materiais</p> </li> <li> <p>Planejamento do processo</p> <ol> <li>Criar o projeto na plataforma de versionamento;</li> <li>Definir mapa de entradas e sa\u00eddas;</li> <li>Construir o circuito no simulador;</li> <li>Criar projeto de valida\u00e7\u00e3o do circuito no simulador;</li> <li>Criar programa(firmware) da aplica\u00e7\u00e3o;</li> <li>Montar circuito em matriz de contatos;</li> <li>Testar programa(firmware) na montagem do prot\u00f3tipo;</li> <li>Registrar resultado da atividade.</li> </ol> </li> </ol> <p>4. Solu\u00e7\u00e3o</p> <p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab04-display7seg/","title":"Lab 4 - Display 7 segmentos","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab04-display7seg/#display-7-segmentos","title":"Display 7-segmentos","text":"<p>Objetivo</p> <p>Acionar um display de 7 segmentos para exibir os 16 d\u00edgitos hexadecimais: <code>0,1,2,3,4,5,6,7,8,9,A,B,C,D,E e F</code>.</p> <p>O display</p> <p>O display de 7 segmentos basicamente \u00e9 um conjunto de LEDs dispostos de forma a cada um deles iluminar um segmento no encapsulamento. Existem v\u00e1rios modelos para diferentes necessidades, mas aqui usamos o mais comum.</p> <p>O display possui, al\u00e9m dos sete segmentos, um ponto, que pode ser utilizado para sinalizar um ponto decimal (v\u00edrgula) ao associar v\u00e1rios displays. Nesse projeto o ponto n\u00e3o ser\u00e1 utilzado.</p> <p>Existem dois modelos de display, Anodo comum e Catodo comum, que se referem aos terminais dos LEDs conectados em comum, conforme exemplo da Figura 1.</p> Figura 1: Segmentos do display Fonte: Autor <p>Cada segmento recebe uma identifica\u00e7\u00e3o em letra min\u00fascula de <code>a</code> a <code>g</code> e o <code>p</code>. O display possui um terminal para cada segmento do display.</p> <p>Note que cada segmento, composto por um LED, necessita de um resistor para limitar a corrente que percorre ele. Como cada pino do uC fornece uma tens\u00e3o de 5V para acionar o segmento. A queda de tens\u00e3o no LED \u00e9 de 2V, aproximadamente. Pode-se assim calcular o valor do resistor limitador de corrente:</p> \\[ R = \\frac{V_{pino} - V_{LED}}{I_{LED}} = \\frac{5-2}{0,02} = 150\\Omega \\] <p>O display aqui utilizado \u00e9 do tipo catodo comum, assim basta acionar os pinos que correspondam aos segmentos a serem acionados para formar o d\u00edgito que se deseja exibir.</p> <p>Para mostrar o d\u00edgito 0(zero), aciona-se os segmento a, b, c, d, e, f conforme mostrado na Figura 2.</p> Figura 2: C\u00f3digo de forma\u00e7\u00e3o do digito 0 (Zero) Fonte: Autor <p>\u00c9 importante notar a sequ\u00eancia de pinos do display e do PORT utilizado, pois uma altera\u00e7\u00e3o de ordem muda o que \u00e9 exibido no display.</p> <p>Para o d\u00edgito 1(um), Figura 3, \u00e9 necess\u00e1rio ligar apenas os segmentos b e c, mantendo os demais desligados.</p> Figura 3: C\u00f3digo de forma\u00e7\u00e3o do digito 1 (Um) Fonte: Autor <p>Para o d\u00edgito 2(dois), Figura 4, \u00e9 mais f\u00e1cil perceber os d\u00edgitos desligados, pois est\u00e3o em menor quantidade, sendo o <code>c</code> e o <code>f</code> desligados e os demais ligados (exceto o ponto como j\u00e1 foi citado).</p> Figura 4: C\u00f3digo de forma\u00e7\u00e3o do digito 2 (Dois) Fonte: Autor <p>A Figura 6 mostra uma tabela com todas as combina\u00e7\u00f5es para os d\u00edgitos decimais e seus valores correspondentes em hexadecimal. Ao atribuir ao PORT um dos valores em hexadecimal da tabela, o digito correspondente deve ser mostrado no display.</p> Figura 5: C\u00f3digo de forma\u00e7\u00e3o do d\u00edgitos <code>0</code> a <code>9</code> Fonte: Autor <p>Est\u00e3o faltando os dados dos d\u00edgitos que completam o conjunto hexadecimal, que podem te servir como exerc\u00edcios. </p> <p>Bom trabalho!</p> <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 <p>Circuito de Simula\u00e7\u00e3o</p> Figura 6: Montagem do circuito de contagem com display de 7 segmentos Fonte: Autor <p>C\u00f3digo</p> <pre><code>#define F_CPU   16000000\n#include &lt;util/delay.h&gt;\n#include &lt;avr/io.h&gt;\n\nchar digitos7seg[16] = {    0x3F, 0x06, 0x5B, 0x4F, \n                            0x66, 0x6D, 0x7D, 0x07, \n                            0x7F, 0x6F, 0x77, 0x7C, \n                            0x39, 0x5E, 0x79, 0x71  };\n\nvoid disp7seg_init( void )\n{\n    DDRD  = 0xFF;\n    PORTD = 0x00;\n}\n\nvoid disp7seg( unsigned char d )\n{\n    PORTD = digitos7seg[d];\n}\n\nint main(void) \n{\n    char i = 0;\n    disp7seg_init();\n    while( 1 )\n    {\n        disp7seg( i );\n        _delay_ms(500);\n\n        // Incremento limitado: 0..15\n        ++i;\n        if( i &gt;= 16 )\n            i = 0;\n    }\n}\n</code></pre> <p>H\u00e1 outras formas de realizar o incremento de forma limitada e retornar ao zero, reiniciando a contagem. </p> <p>Uma dessas formas \u00e9 utilizando o operador tern\u00e1rio.</p> <p>Incremento limitado: 0..15<pre><code>        i = (i&gt;=16) ? 0: (i+1);\n</code></pre> Outra forma de realizar um incremento limitado \u00e9 utilizando o operador <code>mod</code> que em linguagem C \u00e9 o s\u00edmbolo: <code>%</code>.</p> <p>O operador <code>%</code> produz o resto da divis\u00e3o. </p> Incremento limitado: 0..15<pre><code>        i = ++i % 16;\n</code></pre> <p>Problema de mem\u00f3ria</p> <p>Dado o trecho de c\u00f3digo destacado, o que acontece se a fun\u00e7\u00e3o for executada da seguinte forma: <code>disp7seg(16);</code>? </p> <pre><code>char digitos7seg[16] = {    0x3F, 0x06, 0x5B, 0x4F, \n                            0x66, 0x6D, 0x7D, 0x07, \n                            0x7F, 0x6F, 0x77, 0x7C, \n                            0x39, 0x5E, 0x79, 0x71  };\n\nvoid disp7seg( unsigned char d )\n{\n    PORTD = digitos7seg[d];\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab05-2displays7seg/","title":"Lab 5 - 2 Displays 7 segmentos","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab05-2displays7seg/#2-displays-7-segmentos","title":"2 Displays 7-segmentos","text":"<p>Raramente um \u00fanico display de 7 segmentos \u00e9 suficiente para exibir o valor de alguma grandeza. Assim faz-se necess\u00e1ria a liga\u00e7\u00e3o de ao menos outro d\u00edgito. Para acionar este outro d\u00edgito pode-se utilizar outro PORT de 8 pinos do uC. A quantidade de pinos utilizados para o display come\u00e7a a ficar invi\u00e1vel ao aumentar a quantidade de d\u00edgitos. Para viabilizar a utiliza\u00e7\u00e3o de v\u00e1rios d\u00edgitos, \u00e9 utilizada uma t\u00e9cnica chamada multiplexa\u00e7\u00e3o.</p> <p>Objetivo</p> <p>Acionar dois displays de 7 segmentos de forma multiplexada para exibir uma contagem de 0 a 99.</p> Figura 1: Contagem com 2 d\u00edgitos Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab06-deteccao_bordas/","title":"Lab 6 - Detec\u00e7\u00e3o de bordas","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab06-deteccao_bordas/#deteccao-de-bordas","title":"Detec\u00e7\u00e3o de bordas","text":"<p>A leitura simples de um bot\u00e3o implica em alguns comportamentos n\u00e3o desejados como um incremento maior do que a quantidade de vezes que um bot\u00e3o \u00e9 pressionado. Para solucionar esse problema pode-se utilizar n\u00e3o o estado l\u00f3gico do bot\u00e3o, mas sim o evendo associado a mudan\u00e7a de estado, evento \u00fanico dentro de um ciclo de opera\u00e7\u00e3o, que \u00e9 a borda de subida ou a borda de descida.</p> <p>A Figura 1 ilustra os sinais para a detec\u00e7\u00e3o de bordas de subida e descida em fun\u00e7\u00e3o de um sinal de entrada e intervalos discretos (t0, t1, ..., tn) representando o tempo de execu\u00e7\u00e3o de cada ciclo de execu\u00e7\u00e3o do programa principal. </p> Figura 1: Detec\u00e7\u00e3o de bordas de subida (rising) e descida (falling) Fonte: Autor <p>A detec\u00e7\u00e3o de uma borda, consiste em fazer a leitura do sinal de entrada no momento atual e comparar este valor com o valor da mesma entrada no ciclo anterior. </p> <p>Para a detec\u00e7\u00e3o da borda de subida, note que no instante de tempo t5, o sinal de entrada \u00e9 alto e no instante anterior, t4, o sinal era baixo, denotando uma transi\u00e7\u00e3o ascendente do sinal de entrada, ou seja, houve uma borda de subida. Assim, o sinal <code>rising</code>, que representa que houve tal transi\u00e7\u00e3o \u00e9 levada ao n\u00edvel alto. No instante seguinte, t6 o n\u00edvel se mant\u00e9m em n\u00edvel alto e no instante anterior, t5, tamb\u00e9m era n\u00edvel alto, n\u00e3o havendo mudan\u00e7a, e assim, deixando o sinal <code>rising</code> em n\u00edvel baixo. </p> <p>Na detec\u00e7\u00e3o de borda de descida,<code>falling</code>, ocorre o mesmo, por\u00e9m com a transi\u00e7\u00e3o do sinal de entrada do n\u00edvel alto para o n\u00edvel baixo, nos instantes t13 para o t14. </p> <p>Objetivo</p> <p>Detectar as bordas de subida e descida em bot\u00e3o pulsador, gerando um incremento e decremento de uma vari\u00e1vel de contagem.</p> Figura 2: Detec\u00e7\u00e3o de borda para incremento e decremento Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1 Entrada Bot\u00e3o pulsador NA B0 : incrementa contagem 13 19 PB5 Entrada Bot\u00e3o pulsador NA B1 : decrementa contagem 12 18 PB4","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab07-bibliotecas/","title":"Lab 7 - Bibliotecas","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab07-bibliotecas/#bibliotecas","title":"Bibliotecas","text":"<p>Quando um programa come\u00e7a a ganhar volume, ou seja, o n\u00famero de fun\u00e7\u00f5es come\u00e7a a aumentar, o c\u00f3digo come\u00e7a a ficar dif\u00edcil de manipular, com todas as fun\u00e7\u00f5es em um \u00fanico arquivo, a solu\u00e7\u00e3o \u00e9 separar as fun\u00e7\u00f5es em arquivos distintos, fazendo agrupamento de fun\u00e7\u00f5es por tipo de acionamento ou perif\u00e9rico. </p> <p>Esta organiza\u00e7\u00e3o facilita a manipula\u00e7\u00e3o do c\u00f3digo e a sua reutiliza\u00e7\u00e3o em outros projetos.</p> <p>Usando como exemplo o Lab 6 - Detec\u00e7\u00e3o de Borda, al\u00e9m da fun\u00e7\u00e3o principal <code>main</code>, existem fun\u00e7\u00f5es de manipula\u00e7\u00e3o dos displays de 7 segmentos, e das teclas de incremento e decremento. Podemos assim, separar todas as fun\u00e7\u00f5es em tr\u00eas arquivos, conforme ilustrado na Figura 1: </p> Figura 1: Diagrama de bibliotecas e declara\u00e7\u00e3o em programa principal Fonte: Autor <ul> <li>main.c: para a fun\u00e7\u00e3o principal e ponto de entrada da aplica\u00e7\u00e3o ou programa;</li> <li>disp7seg.c: para fun\u00e7\u00f5es de inicializa\u00e7\u00e3o e de manipula\u00e7\u00e3o dos pinos respons\u00e1veis por acionar corretamente o conjunto de displays de 7 segmentos;</li> <li>teclas.c: fun\u00e7\u00f5es para inicializar e manipular os pinos repons\u00e1veis pela leitura das teclas utilizados neste projeto. </li> </ul> <p>As vari\u00e1veis globais que forem utilzadas por um determinado perif\u00e9rico devem ser declaradas no respectivo arquivo.</p> <p>Neste caso, as fun\u00e7\u00f5es do display 7 segmentos e das teclas, formam uma camada que abstrai todo acesso aos perif\u00e9ricos, pinos de entrada e sa\u00edda e funcionalidades de exibi\u00e7\u00e3o dos d\u00edgitos e detec\u00e7\u00e3o de bordas nas teclas de uma \u00fanica vez, mas em muitos casos, estas camadas s\u00e3o separadas. </p> <p>Para cada arquivo <code>.c</code> deve haver um arquivo <code>.h</code> de mesmo nome, contendo os prot\u00f3tipos das fun\u00e7\u00f5es que podem ser acessadas/utilizadas.</p> <p>Objetivo</p> <p>Detectar as bordas de subida e descida em bot\u00e3o pulsador, gerando um incremento e decremento de uma vari\u00e1vel de contagem.</p> Figura 2: Detec\u00e7\u00e3o de borda para incremento e decremento Fonte: Autor <p>Mapa de entradas e sa\u00eddas</p> Fun\u00e7\u00e3o Dispositivo Descri\u00e7\u00e3o Pino  (Arduino Uno) Pino  (ATmega328P) PORT Sa\u00edda Diplay 7 segmentos Segmento a 0 2 PD0 Sa\u00edda Diplay 7 segmentos Segmento b 1 3 PD1 Sa\u00edda Diplay 7 segmentos Segmento c 2 4 PD2 Sa\u00edda Diplay 7 segmentos Segmento d 3 5 PD3 Sa\u00edda Diplay 7 segmentos Segmento e 4 6 PD4 Sa\u00edda Diplay 7 segmentos Segmento f 5 11 PD5 Sa\u00edda Diplay 7 segmentos Segmento g 6 12 PD6 Sa\u00edda Diplay 7 segmentos Segmento p 7 13 PD7 Sa\u00edda Diplay 7 segmentos Sel. Unidade 8 14 PB0 Sa\u00edda Diplay 7 segmentos Sel. Dezena 9 15 PB1 Entrada Bot\u00e3o pulsador NA B0 : incrementa contagem 13 19 PB5 Entrada Bot\u00e3o pulsador NA B1 : decrementa contagem 12 18 PB4 <p>Biblioteca</p> \u00c1rvore do diret\u00f3rio<pre><code>--- avr_bordas\n    |\n    |`-----build|\n    |`-----dist|\n    |`-----bits.h\n    |`-----disp7seg.c\n    |`-----disp7seg.h\n    |`-----main.c\n    |`-----makefile.mak\n    |`-----teclas.c\n     `-----teclas.h\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> disp7seg.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n#define DISP7SEG_UNI_ON     SETBIT(PORTB,0)\n#define DISP7SEG_UNI_OFF    CLRBIT(PORTB,0)\n#define DISP7SEG_DEZ_ON     SETBIT(PORTB,1)\n#define DISP7SEG_DEZ_OFF    CLRBIT(PORTB,1)\n\n#define DIGITOS7SEG_SIZE    16\n\nchar digitos7seg[DIGITOS7SEG_SIZE] = {  0x3F, 0x06, 0x5B, 0x4F, \n                                        0x66, 0x6D, 0x7D, 0x07, \n                                        0x7F, 0x6F, 0x77, 0x7C, \n                                        0x39, 0x5E, 0x79, 0x71  };\n\nvoid disp7seg_init( void )\n{\n    DDRD  = 0xFF;\n    PORTD = 0x00;\n    SETBIT(DDRB, 0);    // Sele\u00e7\u00e3o de Display das Unidades\n    SETBIT(DDRB, 1);    // Sele\u00e7\u00e3o de Display das Dezenas\n}\nunsigned char disp7seg_scan = 0;\nvoid disp7seg( unsigned char d )\n{\n    switch( disp7seg_scan )\n    {\n        case 0: // Unidade\n                    DISP7SEG_DEZ_OFF;\n                    PORTD = digitos7seg[d%10];\n                    DISP7SEG_UNI_ON;\n                    break;\n        case 1: // Dezena\n                    DISP7SEG_UNI_OFF;\n                    PORTD = digitos7seg[(d/10)%10];\n                    DISP7SEG_DEZ_ON;\n                    break;\n    }\n    disp7seg_scan = ++disp7seg_scan % 2;\n}\n</code></pre> disp7seg.h<pre><code>#ifndef DISP7SEG_H\n#define DISP7SEG_H\n\nvoid disp7seg_init( void );\nvoid disp7seg( unsigned char d );\n\n#endif\n</code></pre> teclas.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n#define B0      !BIT(PINB,5)\n#define B1      !BIT(PINB,4)\n\nvoid teclas_init( void )\n{\n    CLRBIT(DDRB, 5); // PB5 Input (+1)\n    CLRBIT(DDRB, 4); // PB4 Input (-1)\n    SETBIT(PORTB,5); // PB5 Pull-up ON (+1)\n    SETBIT(PORTB,4); // PB4 Pull-up ON (-1)\n}\n\nchar b0( void )\n{\n    return( B0 );\n}\n\nchar b0_prev = 0;\nchar b0_rising_edge( void )\n{\n    if( B0 &amp;&amp; !b0_prev )\n    {\n        b0_prev = B0;\n        return( 1 );\n    }\n    else\n    {\n        b0_prev = B0;\n        return( 0 );\n    }\n}\n\nchar b0_falling_edge( void )\n{\n    if( !B0 &amp;&amp; b0_prev )\n    {\n        b0_prev = B0;\n        return( 1 );\n    }\n    else\n    {\n        b0_prev = B0;\n        return( 0 );\n    }\n}\n\n\n\nchar b1( void )\n{\n    return( B1 );\n}\n\nchar b1_prev = 0;\nchar b1_rising_edge( void )\n{\n    if( B1 &amp;&amp; !b1_prev )\n    {\n        b1_prev = B1;\n        return( 1 );\n    }\n    else\n    {\n        b1_prev = B1;\n        return( 0 );\n    }\n}\n\nchar b1_falling_edge( void )\n{\n    if( !B1 &amp;&amp; b1_prev )\n    {\n        b1_prev = B1;\n        return( 1 );\n    }\n    else\n    {\n        b1_prev = B1;\n        return( 0 );\n    }\n}\n</code></pre> teclas.h<pre><code>#ifndef TECLAS_H\n#define TECLAS_H\n\nvoid teclas_init( void );\n\nchar b0( void );\nchar b0_rising_edge( void );\nchar b0_falling_edge( void );\n\nchar b1( void );\nchar b1_rising_edge( void );\nchar b1_falling_edge( void );\n\n#endif\n</code></pre> main.c<pre><code>#include \"disp7seg.h\"\n#include \"teclas.h\"\n\nvoid main(void) \n{\n    char i = 0;\n    disp7seg_init();\n    teclas_init();\n    while( 1 )\n    {\n        if( b0_rising_edge() )\n        {\n            i = i&lt;99 ? i+1 : i;\n        }\n\n        if( b1_falling_edge() )\n        {\n            i = i&gt;0 ? i-1 : i;\n        }\n\n        disp7seg( i );\n    }\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab08-semaforo_temporizado/","title":"Lab 8 - Sem\u00e1foro Temporizado","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab08-semaforo_temporizado/#situacao-de-aprendizagem","title":"Situa\u00e7\u00e3o de Aprendizagem","text":"<p>1. Objetivo: Sem\u00e1foro com temporizador</p> <p>Desenvolver uma aplica\u00e7\u00e3o, programa, para um ser executado na simula\u00e7\u00e3o de controle de tr\u00e1fego (sem\u00e1foro), a ser instalado em um cruzamento de pedestre. </p> Figura 1a: Exemplo de cruzamento de pedestres Figura 1b: Sem\u00e1foro para ve\u00edculos Fonte: freepik <p>2. Requisitos da solu\u00e7\u00e3o</p> <ol> <li>Interface<ol> <li>Sem\u00e1foro de ve\u00edculos (Vm, Am, Vd);</li> <li>Sem\u00e1foro de pedestres (Vd, Vm);</li> <li>Bot\u00e3o pulsador para pedestres;</li> <li>Display de temporiza\u00e7\u00e3o decrescente;</li> </ol> </li> <li>Comportamento<ul> <li>Intervalo de tempo para o Sem\u00e1foro de Ve\u00edculos(sv):<ul> <li>Verde: 42s</li> <li>Amarelo: 3s</li> <li>Vermelho: 15s</li> </ul> </li> <li>Sem\u00e1foro de Pedestre(sp) sincronizado com o de ve\u00edculos:<ul> <li>Verde (sv) : Vermelho (sp)</li> <li>Amarelo (sv) : Vermelho (sp)</li> <li>Vermelho (sv) : Verde (sp)</li> <li>Piscar Vermelho (sp) 3x antes de mudar em definitivo.</li> </ul> </li> <li>Bot\u00e3o pulsador para antecipar libera\u00e7\u00e3o de passagem dos pedestres:<ul> <li>Se faltar mais do que 10s para o acionamento da cor amarela, reduzir para 10s.</li> <li>Se faltar menos do que 10s para o acionamento da cor amarela, manter o tempo restante.</li> </ul> </li> <li>O display de temporiza\u00e7\u00e3o deve exibir a contagem decrescente com o tempo restante para atravessia do pedestre, ou o tempo restante da cor vermelha no sem\u00e1foro dos ve\u00edculos. <ul> <li>Em qualquer outra situa\u00e7\u00e3o, o display n\u00e3o deve mostrar contagem, apenas uma indica\u00e7\u00e3o de que est\u00e1 funcionando, n\u00e3o podendo ficar totalmente apagado. </li> </ul> </li> </ul> </li> <li>Estrutra (Hardware): Circuito eletr\u00f4nico<ul> <li>Pot\u00eancia por sinaleiro: 7W</li> <li>Tens\u00e3o de opera\u00e7\u00e3o: 24V</li> </ul> </li> </ol> <p>3. Planejamento da solu\u00e7\u00e3o</p> <ol> <li> <p>Planejamento do produto final</p> <ol> <li>Projeto em plataforma de versionamento;</li> <li>C\u00f3digo fonte;</li> <li>Simula\u00e7\u00e3o;</li> <li>Prot\u00f3tipo (opcional);</li> <li>Circuito eletr\u00f4nico (opcional).</li> </ol> </li> <li> <p>Planejamento das ferramentas e materiais</p> </li> <li> <p>Planejamento do processo</p> <ol> <li>Criar o projeto na plataforma de versionamento;</li> <li>Definir mapa de entradas e sa\u00eddas;</li> <li>Construir o circuito no simulador;</li> <li>Criar projeto de valida\u00e7\u00e3o do circuito no simulador;</li> <li>Criar programa(firmware) da aplica\u00e7\u00e3o;</li> <li>Montar circuito em matriz de contatos;</li> <li>Testar programa(firmware) na montagem do prot\u00f3tipo;</li> <li>Registrar resultado da atividade.</li> </ol> </li> </ol> <p>4. Solu\u00e7\u00e3o</p> <p>Bom trabalho!</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab09-displayLCD/","title":"Lab 9 - Display de Cristal L\u00edquido","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab09-displayLCD/#display-de-cristal-liquido-lcd-hd44780","title":"Display de Cristal L\u00edquido - LCD HD44780","text":"Figura 1: Simula\u00e7\u00e3o de acionamento manual e inser\u00e7\u00e3o de caracteres Fonte: Autor (SimulIDE-1.1.0-SR1) Figura 2: Mapa de caracteres Fonte: Sparkfun - Hitachi Definicao de Comandos ao LCD<pre><code>#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n</code></pre> <p>Atividade desafio</p> <p>Elabore fun\u00e7\u00f5es em linguagem C de acordo com os prot\u00f3tipos listados abaixo, de modo a controlar o LCD conforme orienta\u00e7\u00e3o do professor.</p> Figura 3: Simula\u00e7\u00e3o de LCD acionado pelo Arduino Uno Fonte: Autor lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void );\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i );\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d );\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col);\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void );\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\n\n#endif\n</code></pre> main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n\nvoid main(void) \n{\n    long t = 0;\n    lcd_init();\n    while( 1 )\n    {\n        switch( t )\n        {\n            case 0:         lcd_clr();                      break;\n            case 1000:      lcd(0,0,\"    HD44780    \");     break;\n            case 3000:      lcd(0,0,\" LCD 16x2 MMR  \");     break;\n            case 6000:      lcd(0,0,\"  IFSP Salto   \");     break;\n            case 20000:     t = 0;                          break;\n        }\n        _delay_ms(1);\n        ++t;\n    }\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab10-teclado/","title":"Lab 10 - Teclado Matricial","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab10-teclado/#teclado-matricial-4x4","title":"Teclado Matricial 4x4","text":"main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n#include \"teclado.h\"\n\nvoid main(void) \n{\n    char tecla;\n    char str[17] = \"Tecla:          \";\n\n    lcd_init();\n    teclado_init();\n\n    while( 1 )\n    {\n        tecla = teclado_scan();\n        str[7] = tecla;\n        lcd(0,0,str);\n    }\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> teclado.h<pre><code>#ifndef TECLADO_H\n#define TECLADO_H\n\nvoid teclado_init( void );\nunsigned char teclado_scan( void );\n\n#endif\n</code></pre> teclado.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    |Pino   |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 0     | Teclado Sa\u00edda   L0\n *  PB1     | 1     | Teclado Sa\u00edda   L1\n *  PB2     | 2     | Teclado Sa\u00edda   L2\n *  PB3     | 3     | Teclado Sa\u00edda   L3\n *  PB4     | 4     | Teclado Entrada C0\n *  PB5     | 5     | Teclado Entrada C1\n *  PB6     | 6     | Teclado Entrada C2\n *  PB7     | 7     | Teclado Entrada C3\n * -------------------------------------------------\n */\n\n#define NUM_COL         4\n#define NUM_LIN         4\n\n#define L0_MASK         0x01\n#define C0_MASK         0x10\n\n\nvoid teclado_init( void )\n{\n    DDRD = 0x0F;    // L_Mask\n    PORTD = 0xFF;   \n}\n\nconst char tecladoMatriz[4][4] =  { {'1','2','3','A'},\n                                    {'4','5','6','B'},\n                                    {'7','8','9','C'},\n                                    {'*','0','#','D'} };\n\n\n\nunsigned char teclado_scan( void )\n{\n    unsigned char aux = 0;\n    unsigned int l,c;\n\n    for( l=0; l&lt;NUM_LIN; l++ )\n    {\n        PORTD = ~(L0_MASK &lt;&lt; l);\n        for( c=0; c&lt;NUM_COL; c++ )\n        {\n            if( (~PIND) &amp; (C0_MASK&lt;&lt;c) )\n            {\n                aux = tecladoMatriz[l][c];\n            }\n        }\n    }   \n    return( aux );\n}\n</code></pre> lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\nvoid lcd_init( void );\nvoid lcd_clr( void );\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam );\n\n#endif\n</code></pre> lcd.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    | Pino  |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 8     | LCD_D4\n *  PB1     | 9     | LCD_D5\n *  PB2     | 10    | LCD_D6\n *  PB3     | 11    | LCD_D7\n *  PB4     | 12    | LCD_RS\n *  PB5     | 13    | LCD_EN\n * -------------------------------------------------\n */\n\n\n//***************** Interface com PORTs/Pinos\n#define LCD_ROWS        2\n#define LCD_COLS        16\n#define LCD_BUS(bus)    PORTB = ((PORTB &amp; 0xF0) | ((bus) &amp; 0x0F))\n#define LCD_RS(bit)     (bit) ? (SETBIT(PORTB,4)) : (CLRBIT(PORTB,4))\n#define LCD_EN(bit)     (bit) ? (SETBIT(PORTB,5)) : (CLRBIT(PORTB,5))\n\n//***************** Definicao de Comandos ao LCD \n#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n\n\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i )\n{   \n    LCD_RS(0);\n    LCD_BUS(i&gt;&gt;4);\n\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n\n    if( (i &amp; 0xF0) == (LCD_FUNCTION_SET | LCD_FS_DATA_LENGTH_4) )\n    {\n        LCD_BUS(i&gt;&gt;4);\n        LCD_EN(0);\n        _delay_us( 40 );\n        LCD_EN(1);\n    }\n\n    LCD_BUS(i);\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n}\n\n\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d )\n{\n    LCD_RS(1);\n    LCD_BUS(d &gt;&gt; 4);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n\n    LCD_BUS(d);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n}\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col)\n{\n    lcd_instReg( LCD_SET_DDRAM_ADDRS( ((LCD_ADDR_LINE_1 * lin) + (col + LCD_ADDR_LINE_0) ) ) );\n}\n\n\n\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void )\n{\n    DDRB |= 0x3F;\n    PORTB &amp;= ~0x3F;\n\n    LCD_EN(1);\n    lcd_instReg( LCD_FUNCTION_SET|LCD_FS_DATA_LENGTH_4|LCD_FS_LINE_NUMBER_2);\n    lcd_instReg( LCD_DISPLAY_CONTROL|LCD_DC_DISPLAY_ON|LCD_DC_CURSOR_OFF|LCD_DC_BLINK_OFF );\n    lcd_instReg( LCD_CLEAR_DISPLAY );\n    lcd_instReg( LCD_RETURN_HOME );\n}\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str )\n{\n    char pos = col;\n    lcd_lincol( lin, col );\n\n    while( *str )\n    {\n        lcd_dataReg( *str );\n        ++str;\n        ++pos;\n    }\n}\n\n// Escreve um n\u00famero inteiro no display\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam )\n{\n    int div;\n    unsigned char size;\n    char sinal; // 0:+ 1:-\n\n    sinal = (num &lt; 0);\n    if( sinal )\n        num = (~num) + 1;\n\n    lcd_lincol(lin, col);\n\n    div=10000;\n    size = 5;\n    while( div &gt; 1 )\n    {\n        if( num/div == 0 )\n            --size;\n        else\n            break;\n        div/=10;\n    }\n\n    while( tam &gt; (size+sinal) &amp;&amp; tam &gt; 1 )\n    {\n        lcd_dataReg(' ');\n        --tam;\n    }  \n\n    if( sinal )\n        lcd_dataReg('-');\n\n    do\n    {\n        lcd_dataReg( (num / div) + '0' );\n        num = num % div;\n        div/=10;\n    }\n    while( div &gt;= 1 );\n}\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void )\n{\n    lcd_instReg(LCD_CLEAR_DISPLAY);\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab11-ihm/","title":"Lab 11 - Interface Homem-M\u00e1quina","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab11-ihm/#interface-homem-maquina","title":"Interface Homem-M\u00e1quina","text":"<p>Elabore um programa que execute o que comportamento conforme ilustra\u00e7\u00e3o acima.</p> <p>Seguem c\u00f3digos de apoio para o display e teclado. </p> main.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include \"lcd.h\"\n#include \"teclado.h\"\n\n\nvoid main(void) \n{\n    char tecla;\n\n    lcd_init();\n    teclado_init();\n\n    while( 1 )\n    {\n        tecla = teclado_scan();\n\n    }\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BIT(reg,bit)        (reg &amp; (1&lt;&lt;bit))\n#define SETBIT(reg,bit)     reg |=  (1&lt;&lt;bit)\n#define CLRBIT(reg,bit)     reg &amp;= ~(1&lt;&lt;bit)\n\n#endif\n</code></pre> teclado.h<pre><code>#ifndef TECLADO_H\n#define TECLADO_H\n\nvoid teclado_init( void );\nunsigned char teclado_scan( void );\n\n#endif\n</code></pre> teclado.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    |Pino   |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 0     | Teclado Sa\u00edda   L0\n *  PB1     | 1     | Teclado Sa\u00edda   L1\n *  PB2     | 2     | Teclado Sa\u00edda   L2\n *  PB3     | 3     | Teclado Sa\u00edda   L3\n *  PB4     | 4     | Teclado Entrada C0\n *  PB5     | 5     | Teclado Entrada C1\n *  PB6     | 6     | Teclado Entrada C2\n *  PB7     | 7     | Teclado Entrada C3\n * -------------------------------------------------\n */\n\n#define NUM_COL         4\n#define NUM_LIN         4\n\n#define L0_MASK         0x01\n#define C0_MASK         0x10\n\n\nvoid teclado_init( void )\n{\n    DDRD = 0x0F;    // L_Mask\n    PORTD = 0xFF;   \n}\n\nconst char tecladoMatriz[4][4] =  { {'1','2','3','A'},\n                                    {'4','5','6','B'},\n                                    {'7','8','9','C'},\n                                    {'*','0','#','D'} };\n\n\n\nunsigned char teclado_scan( void )\n{\n    unsigned char aux = 0;\n    unsigned int l,c;\n\n    for( l=0; l&lt;NUM_LIN; l++ )\n    {\n        PORTD = ~(L0_MASK &lt;&lt; l);\n        for( c=0; c&lt;NUM_COL; c++ )\n        {\n            if( (~PIND) &amp; (C0_MASK&lt;&lt;c) )\n            {\n                aux = tecladoMatriz[l][c];\n            }\n        }\n    }   \n    return( aux );\n}\n</code></pre> lcd.h<pre><code>#ifndef LCD_H\n#define LCD_H\n\nvoid lcd_init( void );\nvoid lcd_clr( void );\nvoid lcd( unsigned char lin, unsigned char col, const char * str );\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam );\n\n#endif\n</code></pre> lcd.c<pre><code>#define F_CPU   16000000L\n#include &lt;util/delay.h&gt;\n#include &lt;avr/io.h&gt;\n#include \"bits.h\"\n\n\n/* -------------------------------------------------\n *          MAPA DE ENTRADAS E SAIDAS\n * -------------------------------------------------\n *  PORT    | Pino  |Conex\u00e3o\n * ---------|-------|-------------------------------\n *  PB0     | 8     | LCD_D4\n *  PB1     | 9     | LCD_D5\n *  PB2     | 10    | LCD_D6\n *  PB3     | 11    | LCD_D7\n *  PB4     | 12    | LCD_RS\n *  PB5     | 13    | LCD_EN\n * -------------------------------------------------\n */\n\n\n//***************** Interface com PORTs/Pinos\n#define LCD_ROWS        2\n#define LCD_COLS        16\n#define LCD_BUS(bus)    PORTB = ((PORTB &amp; 0xF0) | ((bus) &amp; 0x0F))\n#define LCD_RS(bit)     (bit) ? (SETBIT(PORTB,4)) : (CLRBIT(PORTB,4))\n#define LCD_EN(bit)     (bit) ? (SETBIT(PORTB,5)) : (CLRBIT(PORTB,5))\n\n//***************** Definicao de Comandos ao LCD \n#define LCD_CLEAR_DISPLAY           0x01\n\n#define LCD_RETURN_HOME             0x02\n\n#define LCD_ENTRY_MODE_SET          0x04\n#define LCD_EMS_CURSOR_RIGHT        0x02\n#define LCD_EMS_CURSOR_LEFT         0x00\n#define LCD_EMS_SHIFT_DISPLAY       0x01\n\n#define LCD_DISPLAY_CONTROL         0x08\n#define LCD_DC_DISPLAY_ON           0x04\n#define LCD_DC_DISPLAY_OFF          0x00\n#define LCD_DC_CURSOR_ON            0x02\n#define LCD_DC_CURSOR_OFF           0x00\n#define LCD_DC_BLINK_ON             0x01\n#define LCD_DC_BLINK_OFF            0x00\n\n#define LCD_CURSOR_SHIFT            0x10\n#define LCD_CS_LEFT                 0x00\n#define LCD_CS_RIGHT                0x04\n\n#define LCD_DISPLAY_SHIFT           0x10\n#define LCD_DS_LEFT                 0x08\n#define LCD_DS_RIGHt                0x0C\n\n#define LCD_FUNCTION_SET            0x20\n#define LCD_FS_DATA_LENGTH_8        0x10\n#define LCD_FS_DATA_LENGTH_4        0x00\n#define LCD_FS_LINE_NUMBER_1        0x00\n#define LCD_FS_LINE_NUMBER_2        0x08\n#define LCD_FS_DOTS_FORMAT_5x8      0x00\n#define LCD_FS_DOTS_FORMAT_5x11     0x04\n\n#define LCD_SET_CGRAM_ADDRS( adrs ) (0x40+(adrs &amp; 0x3F))\n\n#define LCD_SET_DDRAM_ADDRS( adrs ) (0x80+(adrs &amp; 0x7F))\n#define LCD_ADDR_LINE_0             0x00\n#define LCD_ADDR_LINE_1             0x40\n\n\n\n// Escreve um comando no display (Instruction Register)\nvoid lcd_instReg( unsigned char i )\n{   \n    LCD_RS(0);\n    LCD_BUS(i&gt;&gt;4);\n\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n\n    if( (i &amp; 0xF0) == (LCD_FUNCTION_SET | LCD_FS_DATA_LENGTH_4) )\n    {\n        LCD_BUS(i&gt;&gt;4);\n        LCD_EN(0);\n        _delay_us( 40 );\n        LCD_EN(1);\n    }\n\n    LCD_BUS(i);\n    LCD_EN(0);\n    if( i == LCD_CLEAR_DISPLAY || i == LCD_RETURN_HOME )\n        _delay_ms( 2 );\n    else\n        _delay_us( 40 );\n    LCD_EN(1);\n}\n\n\n\n// Escreve um dado no display (Data Register))\nvoid lcd_dataReg( unsigned char d )\n{\n    LCD_RS(1);\n    LCD_BUS(d &gt;&gt; 4);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n\n    LCD_BUS(d);\n    LCD_EN(0);\n    _delay_us( 40 );\n    LCD_EN(1);\n}\n\n// Posicionar o cursor na coordenada: linha e coluna \nvoid lcd_lincol( unsigned char lin, unsigned char col)\n{\n    lcd_instReg( LCD_SET_DDRAM_ADDRS( ((LCD_ADDR_LINE_1 * lin) + (col + LCD_ADDR_LINE_0) ) ) );\n}\n\n\n\n\n// Inicializa os pinos conectados ao display\nvoid lcd_init( void )\n{\n    DDRB |= 0x3F;\n    PORTB &amp;= ~0x3F;\n\n    LCD_EN(1);\n    lcd_instReg( LCD_FUNCTION_SET|LCD_FS_DATA_LENGTH_4|LCD_FS_LINE_NUMBER_2);\n    lcd_instReg( LCD_DISPLAY_CONTROL|LCD_DC_DISPLAY_ON|LCD_DC_CURSOR_OFF|LCD_DC_BLINK_OFF );\n    lcd_instReg( LCD_CLEAR_DISPLAY );\n    lcd_instReg( LCD_RETURN_HOME );\n}\n\n// Escreve uma string no display\nvoid lcd( unsigned char lin, unsigned char col, const char * str )\n{\n    char pos = col;\n    lcd_lincol( lin, col );\n\n    while( *str )\n    {\n        lcd_dataReg( *str );\n        ++str;\n        ++pos;\n    }\n}\n\n// Escreve um n\u00famero inteiro no display\nvoid lcd_num(  unsigned char lin, unsigned char col,\n                    int num, unsigned char tam )\n{\n    int div;\n    unsigned char size;\n    char sinal; // 0:+ 1:-\n\n    sinal = (num &lt; 0);\n    if( sinal )\n        num = (~num) + 1;\n\n    lcd_lincol(lin, col);\n\n    div=10000;\n    size = 5;\n    while( div &gt; 1 )\n    {\n        if( num/div == 0 )\n            --size;\n        else\n            break;\n        div/=10;\n    }\n\n    while( tam &gt; (size+sinal) &amp;&amp; tam &gt; 1 )\n    {\n        lcd_dataReg(' ');\n        --tam;\n    }  \n\n    if( sinal )\n        lcd_dataReg('-');\n\n    do\n    {\n        lcd_dataReg( (num / div) + '0' );\n        num = num % div;\n        div/=10;\n    }\n    while( div &gt;= 1 );\n}\n\n// Apaga todos os caracteres no display\nvoid lcd_clr( void )\n{\n    lcd_instReg(LCD_CLEAR_DISPLAY);\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab12-timer/","title":"Lab 12 - Timer","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab12-timer/#temporizadorcontador-2","title":"Temporizador/Contador 2","text":"<p>O perif\u00e9rico Timer/Counter2 \u00e9 um temporizador ou contador de uso geral, com m\u00f3dulo de contagem de 8 bits.</p> <p>Um diagrama simplificado pode ser visto na Figura 1.</p> Figura 1: Diagrama de blocos simplificado do Timer/Counter 2 Fonte: Adaptado pelo autor de Datasheet <p>O Timer/counter2 possui alguns registradores para configurar um comportamento de contagem espec\u00edfico, produzindo temporiza\u00e7\u00e3o ou contagem, inclusive podendo implementar sa\u00eddas com o comportamento de modula\u00e7\u00e3o de largura de pulso (PWM - Pulse Width Modulation).</p> <p>A interface com a contagem ou temporiza\u00e7\u00e3o, se d\u00e1 por meio de sinais de requisi\u00e7\u00e3o de interrup\u00e7\u00e3o(Interrupt Request)  (TOVn, OCnA e OCnB) e clock, ou atrav\u00e9s de pinos para entrada de pulsos (pino Tn) do contador ou sa\u00eddas PWM (pinos OCnA e OCnB).</p> <p>Dentre as v\u00e1rias possibilidades que esta interface possibilita, usaremos apenas a configura\u00e7\u00e3o de temporiza\u00e7\u00e3o, tendo na Figura 2 o principal segmento do circuito que implementa esta funcionalidade.</p> Figura 2: Diagrama de blocos de contagem Fonte: Datasheet <p>Os sinais internos apresentados no diagrama s\u00e3o:</p> <ul> <li>\\(count\\): Incrementa ou decrementa o registrador de contagem TCNT2 em 1 unidade;</li> <li>\\(direction\\): Sele\u00e7\u00e3o entre incremento e decremento;</li> <li>\\(clear\\): Inicializa o registrador de contagem com o valor 0;</li> <li>\\(clk_{Tn}\\): Sinal de clock utilizado no Timer/Counter2;</li> <li>\\(top\\): Sinaliza que o registrador de contagem TCNT2 alcan\u00e7ou o seu valor m\u00e1ximo;</li> <li>\\(bottom\\): Sinaliza que o registrador de contagem TCNT2 alcan\u00e7ou o seu valor m\u00ednimo, zero.</li> </ul> <p>Dependendo do modo de opera\u00e7\u00e3o, o registrador TCNT2 \u00e9 zerado, incrementado ou decrementado em cada pulso no \\(clk_{Tn}\\). Este sinal pode ter origem no sinal de fonte de clock do controlador ou de uma fonte externa atrav\u00e9s de um pino (\\(Tn\\)).</p> <p>O modo mais simples de opera\u00e7\u00e3o \u00e9 denominado modo normal (normal mode), em que a dire\u00e7\u00e3o de contagem \u00e9 sempre incremental e n\u00e3o h\u00e1 um reset for\u00e7ado do contador, simplesmente o contador ao chegar em seu valor m\u00e1ximo (TOP) e ser incrementado retorna ao valor zero (BOTTON), conforme ilustrado na Figura 3, sendo este evento chamado de overflow, acionando uma sinaliza\u00e7\u00e3o (TOV2).</p> Figura 3: Diagrama de tempo da contagem (superior sem prescaler, inferior com prescaler de 8) Fonte: Datasheet <p>A Figura 4 ilustra o diagrama de blocos do circuito do divisor de frequ\u00eancia, o prescaler, com os poss\u00edveis divisores 8, 32, 64, 128 e 256. Sendo ainda poss\u00edvel a utiliza\u00e7\u00e3o de sinal de clock obtido diretamente do cristal que pode estar instalado junto ao microcontrolador. O escopo aqui aborda apenas a funcionalidade em que o clock prov\u00e9m do sinal de clock principal do microcontrolador, identificado como \\(clk_{I/O}\\).</p> Figura 4: Prescaler do Timer 2 Fonte: Datasheet <p>A configura\u00e7\u00e3o do comportamento \u00e9 realizada atrav\u00e9s dos seguintes registradores:</p> Figura 5: TCCR2B \u2013 Timer/Counter Control Register B Fonte: Datasheet Figura 6: TCNT2 \u2013 Timer/Counter Register Fonte: Datasheet Figura 7: TIMSK2 \u2013 Timer/Counter2 Interrupt Mask Register e  TIFR2 \u2013 Timer/Counter2 Interrupt Flag Register Fonte: Datasheet <p>Exemplo de simula\u00e7\u00e3o de temporiza\u00e7\u00e3o</p> <p></p> <p>C\u00f3digo de teste do Temporizador</p> main.c<pre><code>#include \"lcd.h\"\n#include \"teclado.h\"\n#include \"timer2.h\"\n\nint main(void)\n{\n    char tecla;\n    unsigned long t = 0;\n\n    timer2_init();\n    teclado_init();\n    lcd_init();\n\n    lcd(0,0,\" Temporizador:  \");\n    lcd(1,0,\"   h   min   s  \");\n    while( 1 )\n    {\n        tecla = teclado_scan();\n\n        if( timer2_status() == 0 )\n        {\n            timer2_set( 1000 );\n            t++;\n            lcd_num(1, 0,t/(60*60),3);\n            lcd_num(1, 5,t/(60),2);\n            lcd_num(1,11,t%(60),2);\n        }\n    }\n    return( 0 );\n}\n</code></pre> timer2.h<pre><code>#ifndef TIMER2_H\n#define TIMER2_H\n\nvoid timer2_init( void );\nvoid timer2_set( unsigned long t );\nunsigned long timer2_status( void );\n\n#endif\n</code></pre> timer2.c<pre><code>#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n\n#define T2INT_OVERFLOW_EN   0x01\n#define T2COUNT_RELOAD      (256-250)\n#define T2NO_CLK            0x00\n#define T2CLK_DIV_8         0x01\n#define T2CLK_DIV_16        0x02\n#define T2CLK_DIV_32        0x03\n#define T2CLK_DIV_64        0x04\n#define T2CLK_DIV_128       0x05\n#define T2CLK_DIV_256       0x06\n#define T2CLK_DIV_1024      0x07\n\nunsigned long t2_t = 0;\n\nvoid timer2_init( void )\n{\n    cli();\n    TCCR2B  = T2CLK_DIV_64;\n    TCNT2   = T2COUNT_RELOAD;\n    TIMSK2  = T2INT_OVERFLOW_EN;\n    t2_t = 0;\n    sei();\n}\n\nISR(TIMER2_OVF_vect) // 1ms\n{\n    TCNT2 = T2COUNT_RELOAD;\n    if( t2_t )\n        --t2_t;\n}\n\nvoid timer2_set( unsigned long t )\n{\n    t2_t = t;\n}\n\nunsigned long timer2_status( void )\n{\n    return( t2_t );\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab13-adc/","title":"Lab 13 - ADC","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab13-adc/#conversor-analogico-digital-adc","title":"Conversor Anal\u00f3gico Digital (ADC)","text":"<p>O conversor anal\u00f3gico digital realiza convers\u00e3o por aproxima\u00e7\u00e3o sucessiva utilizando uma resolu\u00e7\u00e3o de 10 bits.</p> <p>Possui 8 canais, associados ao PORTA, multiplexados ao conversor, com circuito que garante o valor da amostra durante o tempo de convers\u00e3o.</p> <p>A refer\u00eancia de tens\u00e3o do conversor \u00e9 o GND e a tens\u00e3o de fundo de escala pode ser aplicada ao pino <code>AVcc</code> ou atrav\u00e9s de uma tens\u00e3o de refer\u00eancia interna de <code>1.1V</code>.</p> <p>Um diagrama simplificado pode ser visto na Figura 1.</p> Figura 1: Diagrama de blocos simplificado do ADC Fonte: Adaptado pelo autor de Datasheet <p>Os registradores de configura\u00e7\u00e3o do ADC s\u00e3o:</p> Figura 2: ADC Multiplexer Selection Register Fonte: Datasheet Figura 3: DC Control and Status Register A Fonte: Datasheet Figura 4: Digital Input Disable Register 0 Fonte: Datasheet <p>C\u00f3digo fonte de exemplo</p> main.c<pre><code>#include \"lcd.h\"\n#include \"adc.h\"\n\nint main(void)\n{\n    adc_init();\n    lcd_init();\n\n    lcd(0,0,\" x:      y:     \");\n\n    while( 1 )\n    {\n        if( adc_available() )\n        {\n            lcd_num(0, 4,adc_ch0(),4);\n            lcd_num(0,11,adc_ch1(),4);\n            adc_start();\n        }\n    }\n    return( 0 );\n}\n</code></pre> bits.h<pre><code>#ifndef BITS_H\n#define BITS_H\n\n#define BITVAL(bit)         (1&lt;&lt;bit)\n\n#define SETBIT(var,bit)     (var |=  (1&lt;&lt;bit))\n#define CLRBIT(var,bit)     (var &amp;= ~(1&lt;&lt;bit))\n#define TOGBIT(var,bit)     (var ^=  (1&lt;&lt;bit))\n#define TSTBIT(var,bit)     (var &amp;   (1&lt;&lt;bit))\n\n#endif\n</code></pre> adc.h<pre><code>#ifndef ADC_H\n#define ADC_H\n\nvoid adc_init();\nvoid adc_start( void );\nchar adc_available( void );\nint adc_ch0( void );\nint adc_ch1( void );\n\n#endif\n</code></pre> adc.c<pre><code>#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include \"adc.h\"\n#include \"bits.h\"\n\n\n// -------------------------------------- Vars\nunsigned int adc0_value = 0;\nunsigned int adc1_value = 0;\nunsigned int adc_value;\nunsigned char adc_available_flag = 0;\n\n\n\n// -------------------------------------- adc_init\n    // Sele\u00e7\u00e3o de tens\u00e3o de refer\u00eancia\n#define ADC_AVCC    BITVAL(REFS0)\n#define ADC_1V1     (BITVAL(REFS1)|BITVAL(REFS0))\n#define ADC_AREF    0\n\n// Sele\u00e7\u00e3o de canal para conversao\n#define ADC_CH0     0\n#define ADC_CH1     1\n#define ADC_CH2     2\n#define ADC_CH3     3\n#define ADC_CH4     4\n#define ADC_CH5     5\n\n\n    // Ajuste de bits (Left Adjust Result)\n#define ADC_LAR    BITVAL(ADLAR)\n\n// --------------------------------------\n    // Habilita conversor AD\n#define ADC_EN      BITVAL(ADEN)\n    // Inicia a conversao AD\n#define ADC_START   BITVAL(ADSC)\n    // Habilita Trigger Automatico\n#define ADC_ATE     BITVAL(ADATE)\n    // Habilita Interrupcao\n#define ADC_IE      BITVAL(ADIE)\n    // Fator de divisao - ADC Prescaler\n#define ADC_FREQ_DIV_2      0x1\n#define ADC_FREQ_DIV_4      0x2\n#define ADC_FREQ_DIV_8      0x3\n#define ADC_FREQ_DIV_16     0x4\n#define ADC_FREQ_DIV_32     0x5\n#define ADC_FREQ_DIV_64     0x6\n#define ADC_FREQ_DIV_128    0x7\n\n\n\n// -------------------------------------- adc_init\nvoid adc_init( void )\n{\n    cli();\n    ADMUX = (ADC_AVCC | ADC_CH1 );\n    ADCSRA = (ADC_EN | ADC_IE | ADC_FREQ_DIV_128);\n    sei();\n    adc_start();\n}\n\n\n\n// -------------------------------------- adc_start\nvoid adc_start( void )\n{\n    SETBIT(ADMUX, MUX0);        // CH1\n    SETBIT(ADCSRA, ADSC);       // START\n    adc_available_flag = 0;\n}\n\n\n\n// -------------------------------------- adc_interrupt\nISR( ADC_vect )\n{\n    adc_value = ADC;\n    if( TSTBIT(ADMUX, MUX0) )   // CH1\n    {\n        adc1_value = adc_value;\n        CLRBIT(ADMUX, MUX0);        // CH0\n        SETBIT(ADCSRA, ADSC);       // START\n    }\n    else                        // CH0\n    {\n        adc0_value = adc_value;\n        adc_available_flag = 1;\n    }\n}\n\n\n\n// -------------------------------------- adc available\nchar adc_available( void )\n{\n    return( adc_available_flag );\n}\n\n\n// -------------------------------------- adc result\nint adc_ch0( void )\n{\n    return( adc0_value );\n}\nint adc_ch1( void )\n{\n    return( adc1_value );\n}\n</code></pre>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab14-usart/","title":"USART: Universal Asynchronous Receiver/Transmitter","text":"<p>O receptor e transmissor serial s\u00edncrono e ass\u00edncrono universal (USART) \u00e9 um dispositivo de comunica\u00e7\u00e3o serial altamente flex\u00edvel.</p> <p>Possui as seguintes caracter\u00edsticas:</p> <ul> <li>Opera\u00e7\u00e3o full duplex (registradores de recep\u00e7\u00e3o e transmiss\u00e3o seriais independentes);</li> <li>Opera\u00e7\u00e3o ass\u00edncrona ou s\u00edncrona;</li> <li>Opera\u00e7\u00e3o s\u00edncrona com clock mestre ou escravo;</li> <li>Gerador de taxa de transmiss\u00e3o de alta resolu\u00e7\u00e3o;</li> <li>Suporta pacotes seriais com 5, 6, 7, 8 ou 9 bits de dados e 1 ou 2 bits de parada;</li> <li>Gera\u00e7\u00e3o de paridade par ou \u00edmpar e verifica\u00e7\u00e3o de paridade suportadas por hardware;</li> <li>Detec\u00e7\u00e3o de estouro de dados;</li> <li>Detec\u00e7\u00e3o de erro de enquadramento;</li> <li>Filtragem de ru\u00eddo inclui detec\u00e7\u00e3o de bit de in\u00edcio falso e filtro passa-baixo digital;</li> <li>Tr\u00eas interrup\u00e7\u00f5es separadas para TX completo, registro de dados TX vazio e RX completo;</li> <li>Modo de comunica\u00e7\u00e3o multiprocessador;</li> <li>Modo de comunica\u00e7\u00e3o ass\u00edncrona de dupla velocidade.</li> </ul> <p>Um diagrama de blocos simplificado do transmissor USART \u00e9 mostrado na Figura 1.</p> <p>Os registradores de E/S acess\u00edveis pela CPU s\u00e3o mostrados em negrito.</p> <p>As caixas tracejadas no diagrama de blocos separam as tr\u00eas partes principais do USART (listadas de cima para baixo): gerador de clock, transmissor e receptor.</p> <p>Os registradores de controle s\u00e3o compartilhados por todas as unidades.</p> <p>A l\u00f3gica de gera\u00e7\u00e3o de clock consiste na l\u00f3gica de sincroniza\u00e7\u00e3o para a entrada de clock externo usada pela opera\u00e7\u00e3o escrava s\u00edncrona e no gerador de taxa de transmiss\u00e3o. O pino XCKn (clock de transfer\u00eancia) \u00e9 usado apenas no modo de transfer\u00eancia s\u00edncrona.</p> <p>O transmissor consiste em um \u00fanico buffer de grava\u00e7\u00e3o, um registrador de deslocamento serial, um gerador de paridade e l\u00f3gica de controle para lidar com diferentes formatos de pacotes seriais. O buffer de grava\u00e7\u00e3o permite uma transfer\u00eancia cont\u00ednua de dados sem qualquer atraso entre os pacotes.</p> <p>O receptor \u00e9 a parte mais complexa do m\u00f3dulo USART devido \u00e0s suas unidades de clock e recupera\u00e7\u00e3o de dados. As unidades de recupera\u00e7\u00e3o s\u00e3o usadas para recep\u00e7\u00e3o ass\u00edncrona de dados. Al\u00e9m das unidades de recupera\u00e7\u00e3o, o receptor inclui um verificador de paridade, l\u00f3gica de controle, um registrador de deslocamento e um buffer de recep\u00e7\u00e3o de dois n\u00edveis (UDRn). O receptor suporta os mesmos formatos de pacote que o transmissor e pode detectar erros de pacote, estouro de dados e erros de paridade.</p> Figura 1: Diagrama de Blocos - USART Fonte: Datasheet p. 144 <p>A Gera\u00e7\u00e3o de Clock</p> <p>A l\u00f3gica de gera\u00e7\u00e3o de clock, Figura 2, ilustra a gera\u00e7\u00e3o do clock base para o transmissor e o receptor.</p> <p>O USART suporta quatro modos de opera\u00e7\u00e3o de clock: modo ass\u00edncrono normal, modo ass\u00edncrono de velocidade dupla, modo s\u00edncrono mestre e modo s\u00edncrono escravo.</p> <p>O bit UMSELn no registrador de controle e status C do USART (UCSRnC) seleciona entre opera\u00e7\u00e3o ass\u00edncrona e s\u00edncrona.</p> <p>A velocidade dupla (somente modo ass\u00edncrono) \u00e9 controlada pelo U2Xn encontrado no registrador UCSRnA.</p> <p>Ao usar o modo s\u00edncrono (UMSELn = 1), o registrador de dire\u00e7\u00e3o de dados para o pino XCKn (DDR_XCKn) controla se a fonte de clock \u00e9 interna (modo mestre) ou externa (modo escravo).</p> <p>O pino XCKn s\u00f3 fica ativo ao usar o modo s\u00edncrono.</p> Figura 2: Diagrama de Blocos - L\u00f3gica de gera\u00e7\u00e3o de clock Fonte: Datasheet p. 145 <p>O registrador de taxa de transmiss\u00e3o USART (UBRRn) e o contador regressivo conectado a ele funcionam como um pr\u00e9-escalador program\u00e1vel ou gerador de taxa de transmiss\u00e3o. O contador regressivo, operando no clock do sistema (\\(f_{osc}\\)), \u00e9 carregado com o valor <code>UBRRn</code> cada vez que o contador chega a zero ou quando o registrador <code>UBRRnL</code> \u00e9 gravado. Um clock \u00e9 gerado cada vez que o contador chega a zero. Este clock \u00e9 a sa\u00edda de clock do gerador de taxa de transmiss\u00e3o: \\(\\frac{f_{osc}}{UBRRn + 1}\\). O transmissor divide a sa\u00edda de clock do gerador de taxa de transmiss\u00e3o por 2, 8 ou 16, dependendo do modo. A sa\u00edda do gerador de taxa de transmiss\u00e3o \u00e9 utilizada diretamente pelas unidades de rel\u00f3gio e recupera\u00e7\u00e3o de dados do receptor. No entanto, as unidades de recupera\u00e7\u00e3o utilizam uma m\u00e1quina de estados que utiliza 2, 8 ou 16 estados, dependendo do modo definido pelo estado dos bits <code>UMSELn</code>, <code>U2Xn</code> e <code>DDR_XCKn</code>.</p> Figura 3: C\u00e1lculo da taxa de transmiss\u00e3o (Baud Rate [bps]) Fonte: Datasheet p. 146 <p>Quadro ou Pacote de dados (data frame)</p> <p>Um frame serial \u00e9 definido como um dcaractere de bits de dados com bits de sincroniza\u00e7\u00e3o (bits de in\u00edcio e parada) e, opcionalmente, um bit de paridade para verifica\u00e7\u00e3o de erros. O USART aceita todas as 30 combina\u00e7\u00f5es dos seguintes formatos de quadro v\u00e1lidos:</p> <ul> <li>1 bit de in\u00edcio</li> <li>5, 6, 7, 8 ou 9 bits de dados</li> <li>bit de paridade sem paridade, par ou \u00edmpar</li> <li>1 ou 2 bits de parada</li> </ul> <p>Um frame come\u00e7a com o bit de in\u00edcio seguido pelo bit de dados menos significativo. Em seguida, os pr\u00f3ximos bits de dados, at\u00e9 um total de nove, s\u00e3o sucessivos, terminando com o bit mais significativo. Se habilitado, o bit de paridade \u00e9 inserido ap\u00f3s os bits de dados, antes dos bits de parada.</p> <p>Quando um frame completo \u00e9 transmitido, ele pode ser seguido diretamente por um novo quadro, ou a linha de comunica\u00e7\u00e3o pode ser definida para um estado ocioso (alto). A Figura 4 ilustra as combina\u00e7\u00f5es poss\u00edveis dos formatos de frame. Os bits entre colchetes s\u00e3o opcionais.</p> Figura 4: Formatos de frame Fonte: Datasheet p. 147 <p>Registradores do USART</p> Figura 5: Registradores do USART Fonte: Datasheet p. 159-162 <p>C\u00f3digo fonte de exemplo</p> main.c<pre><code>#include &lt;avr/io.h&gt;\n#include \"delay.h\"\n#include \"usart.h\"\n\nint main(void)\n{\n    uart_init(9600, 8, 'n', 1);\n    while( 1 )\n    {\n        uart_tx(\"IFSP Salto\", 10);\n        DELAY(1000);\n    }\n    return( 0 );\n}\n</code></pre> usart.c<pre><code>#include &lt;xc.h&gt;\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include \"usart.h\"\n#include \"delay.h\"\n\nvolatile unsigned char rx_var = 0;\nunsigned char   tx_count = 0;\nunsigned char * tx_ptr;\n\nvoid uart_tx( unsigned char * ptr, unsigned char n )\n{\n    tx_ptr = ptr;\n    tx_count = n;\n    if( n )\n    {\n        UDR0 = *tx_ptr;\n        --tx_count;\n    }\n}\n\nISR(USART_TX_vect)\n{\n    if( tx_count )\n    {\n        UDR0 = *++tx_ptr;\n        --tx_count;\n    }\n}\n\nISR(USART_RX_vect)\n{\n    rx_var = UDR0;\n}\n\nunsigned char uart_rx( void )\n{\n    return( rx_var );\n}\n\n\n\n\n//\n// USART: Universal Synchronous Asynchronous Receiver/Transmitter\n// Configuration\n//\ntypedef struct\n{\n    unsigned char MPCMn:1;  // (R/W) Multi-processor Communication Mode\n    unsigned char U2Xn:1;   // (R/W) Double the USART Transmission Speed\n    unsigned char UPEn:1;   // (R  ) USART Parity Error\n    unsigned char DORn:1;   // (R  ) Data OverRun\n    unsigned char FEn:1;    // (R  ) Frame Error\n    unsigned char UDREn:1;  // (R  ) USART Data Register Empty\n    unsigned char TXCn:1;   // (R/W) USART Transmit Complete\n    unsigned char RXCn:1;   // (R  ) USART Receive Complete\n} UCSRnA_T;                 // 0x20  Initial Value\n\ntypedef struct\n{\n    unsigned char TXB8n:1;  // (R/W) Transmit Data Bit 8 n\n    unsigned char RXB8n:1;  // (R  ) Receive Data Bit 8 n\n    unsigned char UCSZn2:1; // (R/W) Character Size n\n    unsigned char TXENn:1;  // (R/W) Transmitter Enable n\n    unsigned char RXENn:1;  // (R/W) Receiver Enable n\n    unsigned char UDRIEn:1; // (R/W) USART Data Register Empty Interrupt Enable n\n    unsigned char TXCIEn:1; // (R/W) TX Complete Interrupt Enable n\n    unsigned char RXCIEn:1; // (R/W) RX Complete Interrupt Enable n\n} UCSRnB_T;                 // 0x00  Initial Value\n\ntypedef union\n{\n    struct\n    {\n        unsigned char UCPOLn:1; // (R/W) Clock Polarity\n        unsigned char UCSZn:2;  // (R/W) Character Size\n        unsigned char USBSn:1;  // (R/W) Stop Bit Select\n        unsigned char UPMn: 2;  // (R/W) Parity Mode\n        unsigned char UMSEL:2;  // (R/W) USART Mode Select\n    } bits;                 // 0x06  Initial Value\n    unsigned char byte;\n} UCSRnC_U;\n\n#define UART_INIT_ERROR_BAUDRATE        0x01\n#define UART_INIT_ERROR_NBITS           0x02\n#define UART_INIT_ERROR_PARITY          0x04\n#define UART_INIT_ERROR_STOPBITS        0x08\n\nunsigned char uart_init( unsigned long baudrate, char nbits, char parity, char stopbits )\n{\n    UCSRnC_U UCSRnC;\n    unsigned char erro = 0;\n\n    UCSRnC.bits.UMSEL = 0;  // 0: async;  1: sync;  2: Reserved;  3: Master SPI\n    UCSRnC.bits.UCPOLn = 0; // Write this bit to zero when asynchronous mode is used. (p\u00e1g. 162 datasheet)\n\n    switch( nbits )\n    {\n        case 5:     UCSRnC.bits.UCSZn = 0;               break;\n        case 6:     UCSRnC.bits.UCSZn = 1;               break;\n        case 7:     UCSRnC.bits.UCSZn = 2;               break;\n        case 8:     UCSRnC.bits.UCSZn = 3;               break;\n        case 9:     UCSRnC.bits.UCSZn = 3;               break;\n        default:    erro |= UART_INIT_ERROR_NBITS;       break;\n    }\n    switch( parity )\n    {\n        case 'N':\n        case 'n':\n                    UCSRnC.bits.UPMn = 0;                break;\n        case 'E':\n        case 'e':\n                    UCSRnC.bits.UPMn = 2;                break;\n        case 'O':\n        case 'o':\n                    UCSRnC.bits.UPMn = 3;                break;\n        default:    erro |= UART_INIT_ERROR_PARITY;      break;\n    }\n    switch( stopbits )\n    {\n        case 1:     UCSRnC.bits.USBSn = 0;               break;\n        case 2:     UCSRnC.bits.USBSn = 1;               break;\n        default:    erro |= UART_INIT_ERROR_STOPBITS;    break;\n    }\n\n    cli();\n    UBRR0 = ((F_CPU&gt;&gt;4)/(baudrate))-1;\n    UCSR0B = (1&lt;&lt;RXCIE0)|(1&lt;&lt;TXCIE0)|(1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);\n    UCSR0C = UCSRnC.byte;\n    sei();\n}\n</code></pre> usart.h<pre><code>#ifndef USART_H\n#define USART_H\n\nunsigned char uart_init( unsigned long baudrate, char nbits, char parity, char stopbits );\nunsigned char uart_rx( void );\nvoid uart_tx( unsigned char * ptr, unsigned char n );\n\n#endif\n</code></pre> delay.h<pre><code>#ifndef DELAY_H\n#define DELAY_H\n\n#define F_CPU   16000000\n#include &lt;util/delay.h&gt;\n\n#define DELAY( t )        _delay_ms( t )\n\n#endif\n</code></pre> <p></p> <p>Refer\u00eancias</p> <ol> <li>Datasheet</li> </ol>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab_atividades/","title":"Lab Atividades","text":"","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"digitais/mcu/avr_atmega328p/lab_atividades/#situacao-de-aprendizagem-somativa","title":"Situa\u00e7\u00e3o de Aprendizagem Somativa","text":"<p>Avalia\u00e7\u00e3o MMR (Microcontroladores - AVR) - Forms</p>","tags":["Sistemas Eletr\u00f4nicos","MMR","MCU","AVR","ATMega328P"]},{"location":"gestao/ferramentas_qualidade/","title":"Ferramentas da Qualidade","text":"An\u00e1lise SWOT (FOFA) Fonte: AbriMinhaEmpresa <p>Complemento</p> <ol> <li> <p>Matriz SWOT: conceito e aplica\u00e7\u00e3o em planejamentos estrat\u00e9gicos - Runrun.it Blog</p> </li> <li> <p>The SWOT analysis, explained - BiteSize Learning</p> </li> </ol> Ciclo PDCA Fonte: RHEIS Consulting Diagrama de Ishikawa Fonte: Keeps Utiliza\u00e7\u00e3o do diagrama de Ishikawa Fonte: Keeps 5W2H Fonte: Keeps 5W2H Fonte: StrategyPunk","tags":["Ferramentas da qualidade","SWOT","PDCA","Ishikawa","5W2H"]},{"location":"gestao/gestao_projetos/","title":"Gest\u00e3o de Projetos","text":"<p>Diret\u00f3rio com template para TCCs est\u00e1 em desenvolvimento no GitHub.</p> <p>Fluxo de processos do PMBOK\u00ae GUIDE 6\u00aa Edi\u00e7\u00e3o com Ricardo Vargas </p> <ul> <li>Vers\u00e3o Simplificada;</li> <li>Vers\u00e3o Completa</li> </ul> PMBOK\u00ae Guide 6a Edi\u00e7\u00e3o Explicado com Ricardo Vargas!","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"gestao/gestao_projetos/#material-complementar","title":"Material complementar","text":"<ul> <li>Project Management Principles</li> <li>PMBOK ou PRINCE2: concorrentes ou complementares?</li> <li>Como fazer uma EAP? | Estrutura Anal\u00edtica do Projeto - Siteware</li> <li>COMO ELABORAR UMA EAP - ESTRUTURA ANAL\u00cdTICA DO PROJETO - CINCO REGRAS B\u00c1SICAS</li> <li>COMO FAZER UMA EAP - ESTRUTURA ANAL\u00cdTICA DE PROJETO EM POWER POINT</li> </ul>","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"gestao/gestao_projetos/#scrum","title":"Scrum","text":"","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"gestao/gestao_projetos/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Scrum Essentials in Under 10 Minutes - Scrum Alliance</li> <li>Scrum.org</li> <li>Scrum // Dicion\u00e1rio do Programador - C\u00f3digo Fonte TV</li> <li>Scrum - Aprenda Scrum em 9 minutos - MindMaster</li> <li>SCRUM O QUE E\u0301 (de um Jeito BEM Pr\u00e1tico) - Blog Abri Minha Empresa</li> <li>Metodologia \u00c1gil para Engenheiros: Como Aplicar o Scrum na Pr\u00e1tica - IBEE</li> <li>ENTENDA SCRUM EM 5 MINUTOS - Agile School</li> </ol>","tags":["Gest\u00e3o de Projetos","PMBOK"]},{"location":"gestao/git/","title":"Git/Github","text":"","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#ferramenta-de-versionamento","title":"Ferramenta de Versionamento","text":"<p>Uma ferramenta de versionamento (ou sistema de controle de vers\u00e3o - VCS) \u00e9 um software utilit\u00e1rio essencial no desenvolvimento de sistemas computacionais que tem como fun\u00e7\u00e3o principal gerenciar os arquivos de c\u00f3digo-fonte e rastrear cada altera\u00e7\u00e3o feita no projeto.</p> <p>Os principais aspectos dessas ferramentas s\u00e3o:</p>","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#1-funcionalidades-principais","title":"1. Funcionalidades Principais","text":"<ul> <li>Rastreamento de Mudan\u00e7as: O sistema registra quem fez a altera\u00e7\u00e3o, o que foi alterado e quando isso ocorreu. </li> <li>Trabalho Colaborativo: Permite que v\u00e1rias pessoas trabalhem no mesmo c\u00f3digo simultaneamente, facilitando a mesclagem (merge) das altera\u00e7\u00f5es em uma base de c\u00f3digo mestra (master code base).</li> <li>Hist\u00f3rico do Projeto: Possibilita acompanhar o crescimento do projeto ao longo do tempo e, se necess\u00e1rio, reverter para vers\u00f5es anteriores caso surjam problemas.</li> </ul>","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#2-conceitos-fundamentais","title":"2. Conceitos Fundamentais","text":"<ul> <li>Commit: \u00c9 a unidade b\u00e1sica de mudan\u00e7a, consistindo em uma \"fotografia\" dos arquivos modificados e as altera\u00e7\u00f5es internas de c\u00f3digo.</li> <li>Reposit\u00f3rio: O local onde o c\u00f3digo e todo o seu hist\u00f3rico de revis\u00f5es ficam armazenados.</li> <li>Clone e Fork: Um clone \u00e9 uma c\u00f3pia local do reposit\u00f3rio no computador do desenvolvedor; um fork \u00e9 uma c\u00f3pia oficial online do reposit\u00f3rio vinculada \u00e0 conta do pr\u00f3prio usu\u00e1rio.</li> </ul>","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#3-ferramentas-populares","title":"3. Ferramentas Populares","text":"<ul> <li>Git: Atualmente \u00e9 o sistema de controle de vers\u00e3o mais poderoso e utilizado, sendo um sistema completamente distribu\u00eddo. \u00c9 a ferramenta preferida por aproximadamente 76% dos profissionais brasileiros de sistemas embarcados, de acordo com pesquisa de 2025 do portal Embarcados.</li> <li>GitHub: \u00c9 uma comunidade online de compartilhamento de c\u00f3digo que utiliza o Git como base para gerenciamento social de software.</li> <li>Outras ferramentas: Sistemas mais antigos ou alternativos s\u00e3o CVS e Subversion (SVN).</li> </ul>","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#4-fluxo-de-trabalho-com-git-e-github","title":"4. Fluxo de trabalho com git e GitHub","text":"Fluxo simples de trabalho com git e GitHub Fonte: Autor","tags":["Versionamento","Git","Github"]},{"location":"gestao/git/#referencias","title":"Refer\u00eancias","text":"<ol> <li> <p>MARWEDEL, Peter. Embedded System Design: Embedded Systems Foundations of Cyber-Physical Systems, and the Internet of Things. 4. ed. Dortmund: Springer Nature, 2021.</p> </li> <li> <p>ANDERSON, Rick; CERVO, Dan. Pro Arduino: Arduino Expert Topics and Techniques. New York: Apress, 2013.</p> </li> <li> <p>EMBARCADOS. Pesquisa sobre o Mercado Brasileiro de Sistemas Embarcados e IoT 2025. [S. l.]: Embarcados, 2025. Dispon\u00edvel em: https://embarcados.com.br/relatorio-da-pesquisa-sobre-o-mercado-brasileiro-de-sistemas-embarcados-e-iot-2025/</p> </li> </ol>","tags":["Versionamento","Git","Github"]},{"location":"gestao/pitch/","title":"Elevator Pitch - \"Discurso de elevador\"","text":"<p>\u00c9 uma forma de explicar o seu projeto/neg\u00f3cio de forma r\u00e1pida e precisa, mostrando-se seguro e confiante no que apresenta.</p> <p>Objetivo: Deixar o interlocutor curioso, interessado;</p> <p>Ess\u00eancia: Apresentar a proposta de valor do projeto/neg\u00f3cio;</p> <ol> <li>O problema que seu projeto/neg\u00f3cio resolve;</li> <li>O produto/servi\u00e7o oferecido para solucionar o problema;</li> <li>O seu modelo de neg\u00f3cio;</li> <li>O p\u00fablico-alvo;</li> <li>Diferenciais em rela\u00e7\u00e3o aos concorrentes;</li> <li>Seja objetivo;</li> <li>Adapte o discurso de acordo com o audi\u00eancia;</li> <li>Treine;</li> <li>Avalie respostas negativas;</li> <li>Divulgue.</li> </ol> <p>\"O pitch \u00e9 uma arte em constru\u00e7\u00e3o!\"</p> <p>Refer\u00eancias</p> <ol> <li>O que \u00e9 pitch? Como fazer um elevator pitch de sucesso - Portal Administradores</li> <li>Elevator Pitch: exemplos pr\u00e1ticos - Portal Administradores</li> <li>Confira 5 exemplos de Elevator Pitch para colocar em pr\u00e1tica - SOAP</li> <li>Eu analisei o Pitch dos empreendedores Shark Thank \ud83e\udd88 - Andr\u00e9 Arcas</li> <li>Como escrever o \"Elevator Pitch\" perfeito: dicas e exemplos -   Intuit Mailchimp</li> </ol>","tags":["Gest\u00e3o de Projetos","Elevator pitch"]},{"location":"ifsp-slt/rpie8/","title":"RPIE8 - Ementa","text":"Componente Curricular Redes Industriais e Sistemas Supervis\u00f3rios Curso Engenharia de Controle e Automa\u00e7\u00e3o C\u00f3digo SDPE8 Semestre 8\u00ba N\u00famero de aulas semanais 4 Quantidade total de aulas 76 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 63,3/0,0 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio Eletr\u00f4nica e Microcontroladores Pr\u00e9-requisitos (sugeridos) Hor\u00e1rio Segunda-feira: 7:50 - 11:30 (B107/C104) Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - Pp: Projeto pr\u00e1tico  - M\u00e9dia final = 0.5 Al + 0.5 Pp <p>Ementa</p> <p>A disciplina aborda os conte\u00fados b\u00e1sicos de redes e comunica\u00e7\u00e3o para o monitoramento, supervis\u00e3o e controle de dispositivos industriais.</p> <p>Objetivos</p> <ul> <li>Entender os principais conceitos de comunica\u00e7\u00e3o de dados entre dispositivos industriais;</li> <li>Conhecer os protocolos de comunica\u00e7\u00e3o e sistemas supervis\u00f3rios mais utilizados em ambiente industrial;</li> <li>Ser capaz de montar e configurar uma rede de comunica\u00e7\u00e3o industrial simples.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>Modelo ISO/OSI;</li> <li>Topologias de Rede e interfaceamento;</li> <li>Meios f\u00edsicos de transmiss\u00e3o de dados;</li> <li>Padr\u00f5es de comunica\u00e7\u00e3o Serial;</li> <li>Protocolos de Barramento de Campo;</li> <li>Redes CAN e protocolos;</li> <li>Padr\u00f5es Ethernet;</li> <li>Ethernet Industrial e protocolos;</li> <li>Dispositivos Sem Fio e Internet das Coisas;</li> <li>Sistemas Supervis\u00f3rios Industriais;</li> <li>Pr\u00e1ticas Laboratoriais: Integra\u00e7\u00e3o de sistemas atrav\u00e9s dos diversos tipos de redes e elabora\u00e7\u00e3o de sistemas supervis\u00f3rios.</li> </ul> <p>Bibliografia</p> <ul> <li>ALBUQUERQUE, Pedro Urbano Braga de; ALEXANDRIA, Alzuir Ripardo de. Redes industriais: aplica\u00e7\u00f5es em sistemas digitais de controle distribu\u00eddo. 2. ed. rev. e ampl. S\u00e3o Paulo: Ensino Profissional, 2009.</li> <li>LUGLI, Alexandre Baratella; SANTOS, Max Mauro Dias. Sistemas Fieldbus para automa\u00e7\u00e3o industrial: DeviceNet, CANopen, SDS e Ethernet. 1. ed. S\u00e3o Paulo: \u00c9rica, 2009.</li> <li>S\u00c1TYRO, Walter Cardoso; SACOMANO, Jos\u00e9 Benedito; RODRIGO FRANCO GON\u00c7ALVES, Rodrigo Franco; BONILLA, S\u00edlvia Helena; SILVA, M\u00e1rcia Terra (null). Ind\u00fastria 4.0: conceitos e fundamentos. 1. ed. S\u00e3o Paulo: Blucher, 2018.</li> <li> <p>EAI ENDORSED TRANSACTIONS ON INDUSTRIAL NETWORKS AND INTELLIGENT SYSTEMS. Ghent: European Alliance for Innovation, 2014 - ISSN: 2410-0218. Dispon\u00edvel em https://eudl.eu/journal/inis. Acesso em: 21 mai. 2022.</p> </li> <li> <p>KUROSE, James. F.; ROSS, Keith.W. Redes de Computadores e a Internet: uma nova abordagem. S\u00e3o Paulo: Pearson, 2006.</p> </li> <li>RAPPAPORT, Theodore S. Comunica\u00e7\u00f5es sem fio: princ\u00edpios e pr\u00e1ticas - 2\u00aa edi\u00e7\u00e3o. Editora Pearson 2008.</li> <li>FOROUZAN, Behrouz A. Comunica\u00e7\u00e3o de dados e redes de computadores. 3. ed. Porto Alegre: Bookman, 2006.</li> <li>ROS\u00c1RIO, Jo\u00e3o Maur\u00edcio. Princ\u00edpios de mecatr\u00f4nica. S\u00e3o Paulo: Pearson Education do Brasil, 2005.</li> <li>TANENBAUM, Andrew S.; WETHERAL, David J. Redes de Computadores. 5. ed. S\u00e3o Paulo: Pearson, 2011</li> <li>INTERNATIONAL JOURNAL OF COMPUTER NETWORKS AND APPLICATIONS (IJCNA). EverScience Publications, 2014 - . ISSN: 2410-0218. Dispon\u00edvel em https://www.ijcna.org/. Acesso em: 21 mai. 2022.</li> </ul> <p>Plano de aulas</p> Semana Data Conte\u00fado Metodologia de Ensino e Recursos 1 04/08/2025 - Apresenta\u00e7\u00e3o da disciplina;  - Defini\u00e7\u00e3o de redes industriais;  Sinais de comunica\u00e7\u00e3o; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  Pr\u00e1tica Orientada: Laborat\u00f3rio com computadores, software Termite, oscilosc\u00f3pio, adaptador CP2102; 2 11/08/2025 - Classifica\u00e7\u00e3o de Redes;  - Comunica\u00e7\u00e3o Ponto a ponto; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  Pr\u00e1tica Orientada: Laborat\u00f3rio com computadores, software Termite, oscilosc\u00f3pio, adaptador CP2102; 3 18/08/2025 - Dimensionamento de redes;  - Interpretar comandos com arduino; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino; 4 25/08/2025 - Modelo OSI;  - Comunica\u00e7\u00e3o Serial - RS485 - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017 5 01/09/2025 - Meio f\u00edsico e transmiss\u00e3o de dados;  - Rede em barramento RS485 - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017 6 15/09/2025 - Padr\u00f5es de comunica\u00e7\u00e3o Serial;  - Rede em barramento RS485 - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017 7 22/09/2025 - Protocolos de Comunica\u00e7\u00e3o Modbus  - Modbus com CLP Altus - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP; 8 29/09/2025 - Protocolos de Comunica\u00e7\u00e3o (Semin\u00e1rio);  - Projeto: Montagem de Dispositivo de Rede; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP; 9 06/10/2025 - Protocolos de Comunica\u00e7\u00e3o (Semin\u00e1rio);  - Projeto: Montagem de Dispositivo de Rede; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP; 10 20/10/2025 - Protocolos de Comunica\u00e7\u00e3o (Semin\u00e1rio);  - Projeto: Programa\u00e7\u00e3o e Configura\u00e7\u00e3o de Dispositivo de Rede; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP; 11 25/10/2025 IFCi\u00eancia 12 27/10/2025 - Sistemas Supervis\u00f3rio;  - Integra\u00e7\u00e3o CLP/Arduino/Supervis\u00f3rio via Modbus - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP, ScadaBR; 13 03/11/2025 - Sistemas Supervis\u00f3rios Industriais;  - Integra\u00e7\u00e3o CLP/Arduino/Supervis\u00f3rio via Modbus; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP, ScadaBR; 14 10/11/2025 - Sistemas Supervis\u00f3rios Industriais;  - Integra\u00e7\u00e3o CLP/Arduino/Supervis\u00f3rio via Modbus; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP, ScadaBR; 15 17/11/2025 - Sistemas Supervis\u00f3rios Industriais;  - Integra\u00e7\u00e3o CLP/Arduino/Supervis\u00f3rio via Modbus; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, software termite, oscilosc\u00f3pio, adaptador CP2102, Arduino, Conversor MAX485 e XY017, CLP, ScadaBR; 16 24/11/2025 - Dispositivos Sem Fio; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, ESP32 e software espec\u00edfico; 17 01/12/2025 - Internet das Coisas e MQTT; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, ESP32 e software espec\u00edfico; 18 08/12/2025 - ESP32 e Sockets; - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;  - Pr\u00e1tica orientada: Laborat\u00f3rio com computadores, ESP32 e software espec\u00edfico; 19 15/12/2025 - Industrial Internet das Coisas;  - Seguran\u00e7a : Artigo: Lima, P.M., Alves, M.V.S., Carvalho, L.K. et al. Security Against Communication Network Attacks of Cyber-Physical Systems. J Control Autom Electr Syst 30, 125\u2013135 (2019). https://doi.org/10.1007/s40313-018-0420-9 - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia;","tags":["Redes Industriais","Sistemas Supervis\u00f3rios"]},{"location":"ifsp-slt/sdpe8/","title":"SDPE8 - Ementa","text":"Componente Curricular Sistemas Digitais Program\u00e1veis Curso Engenharia de Controle e Automa\u00e7\u00e3o C\u00f3digo SDPE8 Semestre 8\u00ba N\u00famero de aulas semanais 4 Quantidade total de aulas 76 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 63,3/0,0 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio Eletr\u00f4nica e Microcontroladores Pr\u00e9-requisitos Eletr\u00f4nica Digital - ELDE3 Hor\u00e1rio Ter\u00e7a-feira: 8:40 - 12:20 (D111) Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - Pp: Projeto pr\u00e1tico  - M\u00e9dia final = 0.5 Al + 0.5 Pp <p>Ementa</p> <p>A componente curricular aborda as arquiteturas e a teoria de dispositivos l\u00f3gicos reprogram\u00e1veis, programa\u00e7\u00e3o de dispositivos FPGA e dispositivos l\u00f3gicos complexos program\u00e1veis (CPLD), bem como linguagem VHDL e projetos de laborat\u00f3rio com dispositivos reconfigur\u00e1veis.</p> <p>Objetivos</p> <ul> <li>Adquirir conhecimento te\u00f3rico acerca de dispositivos l\u00f3gicos program\u00e1veis e sobre a linguagem VHDL;</li> <li>Conhecer componentes como FPGAs, sua estrutura l\u00f3gica e programa\u00e7\u00e3o;</li> <li>Realizar aplica\u00e7\u00f5es, simula\u00e7\u00e3o e experimentos de laborat\u00f3rio com tais dispositivos.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>Fundamentos de l\u00f3gica reconfigur\u00e1vel: introdu\u00e7\u00e3o aos sistemas digitais program\u00e1veis;</li> <li>Arquiteturas de FPGAs: blocos l\u00f3gicos, blocos de entrada/sa\u00eddas, mem\u00f3rias, interconex\u00f5es;</li> <li>Programa\u00e7\u00e3o de dispositivos reconfigur\u00e1veis por diagrama de blocos de fun\u00e7\u00f5es;</li> <li>Linguagem VHDL;</li> <li>Fluxo de projeto com dispositivos reprogram\u00e1veis: HDL, s\u00edntese, implementa\u00e7\u00e3o, download, arquivos netlist, bitstream etc.;</li> <li>Ferramentas de desenvolvimento e simula\u00e7\u00e3o para dispositivos reconfigur\u00e1veis;</li> <li>Projetos de laborat\u00f3rio com aplica\u00e7\u00e3o de dispositivos reconfigur\u00e1veis;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Programa\u00e7\u00e3o de dispositivos reconfigur\u00e1veis em laborat\u00f3rio com VHDL;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Experimentos com sistemas de automa\u00e7\u00e3o controlados por FPGAs.</li> </ul> <p>Bibliografia</p> <ul> <li>D'AMORE, Roberto. VHDL: descri\u00e7\u00e3o e s\u00edntese de circuitos digitais. 2. ed. Rio de Janeiro: LTC, 2012.</li> <li>PEDRONI, Volnei A. Eletr\u00f4nica digital moderna e VHDL. Rio de Janeiro: Elsevier, 2010.</li> <li>COSTA, Cesar da. Projetos de Circuitos Digitais com FPGA, 3a ed., Ed. \u00c9rica,2013.</li> <li>TOCCI, Ronald J.; WIDMER, Neal S.; MOSS, Gregory L. Sistemas digitais: princ\u00edpios e aplica\u00e7\u00f5es. 11. ed. S\u00e3o Paulo: Pearson Education do Brasil, 2011.</li> <li> <p>IEEE JOURNAL OF SOLID-STATE CIRCUITS. Institute of Electrical and Electronic Engineers, c1966- ISSN: 0018-9200. Dispon\u00edvel em https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=4. Acesso em: 20 mai. 2022.</p> </li> <li> <p>ORDONEZ, Edward David Moreno; PENTEADO, Cesar Giacomini; SILVA, Alexandre C\u00e9sar Rodrigues da. Microcontroladores e FPGAs: aplica\u00e7\u00f5es em automa\u00e7\u00e3o. S\u00e3o Paulo: Novatec, 2006.</p> </li> <li>LOUREN\u00c7O, Antonio Carlos et al. Circuitos digitais. 9. ed. S\u00e3o Paulo: \u00c9rica, 2007. 336 p. (Estude e use. S\u00e9rie Eletr\u00f4nica digital). ISBN 9788571943209.</li> <li>HAUPT, Alexandre; DACHI, \u00c9dison (null). Eletr\u00f4nica digital. 1. ed. S\u00e3o Paulo: Blucher, 2016. 1 recurso online. ISBN 9788521210092.</li> <li>GARCIA, Paulo Alves; MARTINI, Jos\u00e9 Sidnei Colombo. Eletr\u00f4nica digital: teoria e laborat\u00f3rio. 2. ed. S\u00e3o Paulo: \u00c9rica, 2008. 182 p. ISBN 9788536501093.</li> <li>IDOETA, Ivan Valeije; CAPUANO, Francisco Gabriel. Elementos de eletr\u00f4nica digital. 41. ed., rev. e atual. S\u00e3o Paulo: \u00c9rica, 2012. 544 p. ISBN 9788571940192.</li> <li>DUBEY, Rahul. Introduction to Embedded System Design Using Field Programmable Gate Arrays. Springer, 2009.</li> <li>GON\u00c7ALVES J\u00daNIOR, Nelson Ant\u00f4nio. Princ\u00edpios de VHDL. Maring\u00e1, PR: EdUEM, 2009.</li> <li>ACTIVE AND PASSIVE ELECTRONIC COMPONENTS. London: Hindawi Publishing Corporation, 1985-. ISSN 0882-7516. Dispon\u00edvel em &lt; https://www.hindawi.com/journals/apec/&gt;. Acesso em: 20 mai. 2022.</li> <li>KILTS, Steve. Advanced FPGA design: architecture, implementation, and optimization. Hoboken, N.J.: Wiley-interscience; IEEE, 2007.</li> </ul> <p>Plano de aulas</p> Semana Data Conte\u00fado Metodologia de Ensino e Recursos 1 29/07/2025 - Apresenta\u00e7\u00e3o do Componente Curricular;  - Revis\u00e3o de Eletr\u00f4nica Digital; - Exposi\u00e7\u00e3o dialogada;  - Quadro branco ou lousa, Datashow e Computador 2 05/08/2025 - Introdu\u00e7\u00e3o aos dispositivos Reconfigur\u00e1veis  - Placa DE1-SoC  - Software Intel Quartus; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 3 12/08/2025 - Introdu\u00e7\u00e3o \u00e0 Linguagem VHDL; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 4 19/08/2025 - Comandos concorrentes b\u00e1sicos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 5 26/08/2025 - Comandos sequencias b\u00e1sicos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 6 02/09/2025 - Atraso, vari\u00e1vel e atributos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 7 09/09/2025 - Estrat\u00e9gias de descri\u00e7\u00e3o de circuitos s\u00edncronos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 8 16/09/2025 - Componentes e esquemas de itera\u00e7\u00e3o; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 9 23/09/2025 - Prova P1; Prova Te\u00f3rico-Pr\u00e1tica 10 30/09/2025 - Subprogramas; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 11 07/10/2025 - Bibliotecas e pacotes; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 12 21/10/2025 - Padr\u00e3o IEEE 1164; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 13 28/10/2025 - Padr\u00e3o IEEE 1076.3; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 14 04/11/2025 - Declara\u00e7\u00e3o de tipos e pseud\u00f4nimos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 15 11/11/2025 - Arquivos; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 16 18/11/2025 - T\u00f3picos avan\u00e7ados; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 17 25/11/2025 - Teste; - Exposi\u00e7\u00e3o dialogada e  Pr\u00e1tica orientada  - Lab. Inform\u00e1tica, kit did\u00e1tico e software espec\u00edfico 18 02/12/2025 - Prova P2; Prova Te\u00f3rico-Pr\u00e1tica 19 09/12/2025 - Leitura do artigo ADIL YAZDEEN, A. .; ZEEBAREE , S. R. M. .; MOHAMMED SADEEQ, M.; KAK, S. F. .; AHMED, O. M. .; ZEBARI, R. R. FPGA Implementations for Data Encryption and Decryption via Concurrent and Parallel Computation: A Review. Qubahan Academic Journal, [S. l.], v. 1, n. 2, p. 8\u201316, 2021. DOI: 10.48161/qaj.v1n2a38. Dispon\u00edvel em: https://journal.qubahan.com/index.php/qaj/article/view/38. Acesso em: 24 jul. 2025.","tags":["Sistemas Eletr\u00f4nicos","FPGA","DE1-SoC"]},{"location":"ifsp-slt/sltclpr/","title":"SLTCLPR","text":"Componente Curricular Controladores L\u00f3gicos Program\u00e1veis Curso T\u00e9cnico em Automa\u00e7\u00e3o Industrial C\u00f3digo SLTCLPR Semestre 2\u00ba N\u00famero de aulas semanais 2 Quantidade total de aulas 40 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 33,3/0,0 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio Automa\u00e7\u00e3o Industrial Hor\u00e1rio Quarta-feira:   Turma 2: 19:00 - 20:40 (B109)  Turma 1: 20:55 - 22:35 (B109) Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - Pp: Projeto pr\u00e1tico  - M\u00e9dia final = 0.5 Al + 0.5 Pp <p>Ementa</p> <p>O Componente Curricular desenvolve habilidades de programa\u00e7\u00e3o de CLPs em linguagem LADDER, para as principais aplica\u00e7\u00f5es da ind\u00fastria. Desenvolve a interpreta\u00e7\u00e3o de circuitos de comandos de el\u00e9tricos para linguagem LADDER e a utiliza\u00e7\u00e3o de ferramentas de programa\u00e7\u00e3o e simula\u00e7\u00e3o em LADDER. Apresenta conceitos relacionados a tecnologias digitais para automa\u00e7\u00e3o e otimiza\u00e7\u00e3o de processos como Internet das Coisas e Ind\u00fastria 4.0.</p> <p>Objetivos</p> <ul> <li>Dominar os conceitos dos controladores l\u00f3gicos program\u00e1veis, realizar sua programa\u00e7\u00e3o e empreg\u00e1-los em solu\u00e7\u00f5es de automa\u00e7\u00e3o e controle de processos;</li> <li>Integrar o CLP com entradas e sa\u00eddas digitais e anal\u00f3gicas;</li> <li>Conhecer softwares supervis\u00f3rios;</li> <li>Implementar os conceitos te\u00f3ricos da disciplina em experimentos de laborat\u00f3rio.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>Introdu\u00e7\u00e3o aos sistemas de controle;</li> <li>Hist\u00f3rico: dos pain\u00e9is de rel\u00e9s ao CLP;</li> <li>Arquiteturas e princ\u00edpios de funcionamentos do CLPs;</li> <li>Requisitos dos controladores l\u00f3gicos program\u00e1veis, norma IEC 61131;</li> <li>Ciclo de varredura. Conceitos de monotarefa e multitarefa;</li> <li>Linguagens de programa\u00e7\u00e3o dos CLPs: diagrama ladder, texto estruturado, gr\u00e1fico de fun\u00e7\u00f5es;</li> <li>L\u00f3gica combinacional em CLP: rela\u00e7\u00e3o entre circuitos digitais, equa\u00e7\u00f5es booleanas, descri\u00e7\u00e3o textual e implementa\u00e7\u00e3o em CLP;</li> <li>L\u00f3gica sequencial em CLP: temporiza\u00e7\u00e3o, vari\u00e1veis, contadores;</li> <li>Emprego de entradas e sa\u00eddas digitais. Sensores e atuadores digitais;</li> <li>Emprego de entradas anal\u00f3gicas para uso de sensores anal\u00f3gicos;</li> <li>Emprego de sa\u00eddas anal\u00f3gicas para acionamento de atuadores anal\u00f3gicos;</li> <li>Protocolos de entrada e sa\u00edda dos CLPs: sinais digitais, sinais de corrente, sinais de tens\u00e3o;</li> <li>Softwares supervis\u00f3rios;</li> <li>Sistemas supervisionados;</li> <li>Integra\u00e7\u00e3o de sistemas controlados por CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Ensaios de laborat\u00f3rio com aplica\u00e7\u00e3o dos t\u00f3picos da disciplina;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de l\u00f3gica combinacional com CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Experimentos de l\u00f3gica sequencial com CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP.</li> </ul> <p>Bibliografia</p> <ul> <li>FRANCHI, Claiton Moro; CAMARGO, Valter Lu\u00eds Arlindo de. Controladores l\u00f3gicos program\u00e1veis: sistemas discretos. 2. ed. S\u00e3o Paulo: \u00c9rica, 2009. 352 p. ISBN 9788536501994.</li> <li>GEORGINI, Jo\u00e3o Marcelo. Automa\u00e7\u00e3o aplicada: descri\u00e7\u00e3o e implementa\u00e7\u00e3o de sistemas seq\u00fcenciais com PLCs. 9. ed. S\u00e3o Paulo: \u00c9rica, 2007. 240 p. ISBN-13: 978-8571947245</li> <li> <p>SILVA, Edilson A. da. Introdu\u00e7\u00e3o \u00e0s linguagens de programa\u00e7\u00e3o para CLP, 1.ed. Editora Blucher, 2016. 355p. ISBN: 9788521210528</p> </li> <li> <p>PETRUZELLA, Frank. Controladores L\u00f3gicos Program\u00e1veis. Editora AMGH, 2013. 4\u00aa ed. 416 p. ISBN-13: 978-8580552829.</p> </li> <li>PRUDENTE, Francesco. Automa\u00e7\u00e3o Industrial - PLC: Programa\u00e7\u00e3o e Instala\u00e7\u00e3o. 2. ed. Rio de Janeiro: LTC, 2020. 256p. ISBN 978-8521637080.</li> <li>SILVEIRA, Paulo Rog\u00e9rio da; SANTOS, Winderson E. dos. Automa\u00e7\u00e3o e controle discreto. 7. ed. S\u00e3o Paulo: \u00c9rica, 2006. 235 p. (Cole\u00e7\u00e3o Estude e use. S\u00e9rie Automa\u00e7\u00e3o industrial). ISBN 8571945918.</li> </ul> <p>Plano de aulas</p> Semana Data Conte\u00fado Metodologia de Ensino e Recursos 1 28/07/2025 - Apresenta\u00e7\u00e3o da disciplina;  - Contexto hist\u00f3rico. - Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.  - Pr\u00e1tica orientada: Laborat\u00f3rio com CLPs e computadores com softwares de desenvolvimento (Master Tool IEC). 2 06/08/2025 - Descri\u00e7\u00e3o estrutural: Fonte, CPU, Mem\u00f3rias, Entradas, Sa\u00eddas, Comunica\u00e7\u00e3o, Expans\u00e3o;  - Ambienta\u00e7\u00e3o com software de desenvolvimento. - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 3 13/08/2025 - Descri\u00e7\u00e3o Funcional;  - Crian\u00e7\u00e3o e execu\u00e7\u00e3o de projeto no kit de desenvolvimento; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 4 20/08/2025 - Temporiza\u00e7\u00e3o; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 5 27/08/2025 - Temporiza\u00e7\u00e3o; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 6 03/09/2025 - Bloco Funcional; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 7 10/09/2025 - Situa\u00e7\u00e3o de Aprendizagem 1 (SA1): Partida Estrela-Triangulo; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 8 17/09/2025 - SA2: Acionamento Bi-manual; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 9 24/09/2025 - Revis\u00e3o das situa\u00e7\u00f5es de aprendizagem - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 10 01/10/2025 - Situa\u00e7\u00e3o de aprendizagem avaliativa : P1; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 11 08/10/2025 - Contadores;  - Comparadores; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 12 22/10/2025 - Contadores; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 13 25/10/2025 IFCi\u00eancia 14 29/10/2025 - Acionamento sequencial: Diagrama Trajeto-Passo; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 15 05/11/2025 - M\u00e9todo de programa\u00e7\u00e3o: Maximiza\u00e7\u00e3o de contatos; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 16 12/11/2025 - M\u00e9todo de programa\u00e7\u00e3o: Maximiza\u00e7\u00e3o de contatos; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 17 19/11/2025 - M\u00e9todo de programa\u00e7\u00e3o: Minimiza\u00e7\u00e3o de contatos; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 18 26/11/2025 - Vari\u00e1veis anal\u00f3gicas; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 19 03/12/2025 - Revis\u00e3o das atividades pr\u00e1ticas presenciais; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada. 20 10/12/2025 - Revis\u00e3o das atividades pr\u00e1ticas presenciais; - Exposi\u00e7\u00e3o dialogada.  - Pr\u00e1tica orientada.","tags":["Controladores Program\u00e1veis","SLTCLPR","PLC","CLP"]},{"location":"ifsp-slt/automacao/sltclpe_ementa/","title":"Ementa","text":"","tags":["Controladores L\u00f3gicos Program\u00e1veis","CLP"]},{"location":"ifsp-slt/automacao/sltclpe_ementa/#ementa","title":"Ementa","text":"Componente Curricular Controladores L\u00f3gicos Program\u00e1veis Curso Engenharia de Controle e Automa\u00e7\u00e3o C\u00f3digo SLTCLPE Semestre 7\u00ba N\u00famero de aulas semanais 4 Quantidade total de aulas 76 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 63,3/0,0 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio D110 / B107 Pr\u00e9-requisitos (sugeridos) Hor\u00e1rio Segunda-feira (B107): T1 08:50 - 10:30, T2 10:40 - 12:20  Sexta-feira (D110): 10:40 - 12:20 Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - APL: Avalia\u00e7\u00e3o Pr\u00e1tica de Laborat\u00f3rio  - M\u00e9dia final = 0,5.AL + 0,5.APL <p>Ementa</p> <p>A disciplina aborda o conhecimento de controladores l\u00f3gicos program\u00e1veis (CLP), arquiteturas de CLPs, linguagens de programa\u00e7\u00e3o de CLPs. Trabalha aplica\u00e7\u00f5es e programa\u00e7\u00e3o de CLPs para automa\u00e7\u00e3o e controle de processos. Apresenta a norma IEC 61131 e os conceitos fundamentais de softwares supervis\u00f3rios e IHM.</p> <p>Objetivos</p> <ul> <li>Dominar os conceitos dos controladores l\u00f3gicos program\u00e1veis, realizar sua programa\u00e7\u00e3o e empreg\u00e1-los em solu\u00e7\u00f5es de automa\u00e7\u00e3o e controle de processos;</li> <li>Integrar o CLP com entradas e sa\u00eddas digitais e anal\u00f3gicas;</li> <li>Conhecer softwares supervis\u00f3rios;</li> <li>Implementar os conceitos te\u00f3ricos da disciplina em experimentos de laborat\u00f3rio.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>A Introdu\u00e7\u00e3o aos sistemas de controle;</li> <li>Hist\u00f3rico: dos pain\u00e9is de rel\u00e9s ao CLP;</li> <li>Arquiteturas e princ\u00edpios de funcionamentos do CLPs;</li> <li>Requisitos dos controladores l\u00f3gicos program\u00e1veis, norma IEC 61131;</li> <li>Ciclo de varredura. Conceitos de monotarefa e multitarefa;</li> <li>Linguagens de programa\u00e7\u00e3o dos CLPs: diagrama ladder, texto estruturado, gr\u00e1fico de fun\u00e7\u00f5es;</li> <li>L\u00f3gica combinacional em CLP: rela\u00e7\u00e3o entre circuitos digitais, equa\u00e7\u00f5es booleanas, descri\u00e7\u00e3o textual e implementa\u00e7\u00e3o em CLP;</li> <li>L\u00f3gica sequencial em CLP: temporiza\u00e7\u00e3o, vari\u00e1veis, contadores;</li> <li>Emprego de entradas e sa\u00eddas digitais. Sensores e atuadores digitais;</li> <li>Emprego de entradas anal\u00f3gicas para uso de sensores anal\u00f3gicos;</li> <li>Emprego de sa\u00eddas anal\u00f3gicas para acionamento de atuadores anal\u00f3gicos;</li> <li>Protocolos de entrada e sa\u00edda dos CLPs: sinais digitais, sinais de corrente, sinais de tens\u00e3o e protocolos;</li> <li>Softwares supervis\u00f3rios;</li> <li>Interface Homem-M\u00e1quina;</li> <li>Sistemas supervisionados;</li> <li>Integra\u00e7\u00e3o de sistemas controlados por CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Ensaios de laborat\u00f3rio com aplica\u00e7\u00e3o dos t\u00f3picos da disciplina;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de l\u00f3gica combinacional com CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Experimentos de l\u00f3gica sequencial com CLP;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP.</li> </ul> <p>Bibliografia</p> <ul> <li>FRANCHI, Claiton Moro; CAMARGO, Valter Lu\u00eds Arlindo de. Controladores l\u00f3gicos program\u00e1veis: sistemas discretos. 2. ed. S\u00e3o Paulo: \u00c9rica, 2009. 352 p. ISBN 9788536501994.</li> <li>GEORGINI, Jo\u00e3o Marcelo. Automa\u00e7\u00e3o aplicada: descri\u00e7\u00e3o e implementa\u00e7\u00e3o de sistemas sequenciais com PLCs. 9. ed. S\u00e3o Paulo: \u00c9rica, 2007. 240 p. ISBN-13: 978-8571947245</li> <li>SILVA, Edilson A. da. Introdu\u00e7\u00e3o \u00e0s linguagens de programa\u00e7\u00e3o para CLP, 1.ed. Editora Blucher, 2016. 355p. ISBN: 9788521210528</li> <li>Journal of Control, Automation and Electrical Systems, ISSN 2195-3880</li> <li>SANJAY, Katariya B. Industrial Automation Solutions for Plc, Scada, Drive and Field Instruments: Easy to Learn Industrial Automation. Notion Press, 2020. 348 p. ISBN 978-1648926082</li> <li>ANTONSEN, Tom M. PLC Controls with Ladder Diagram (LD): IEC 61131-3 and introduction to Ladder programming. Books on Demand, 2021. 226p. ISBN 978-8743033349</li> <li>PETRUZELLA, Frank. Controladores L\u00f3gicos Program\u00e1veis. Editora AMGH, 2013. 4a ed. 416 p. ISBN-13: 978-8580552829.</li> <li>PRUDENTE, Francesco. Automa\u00e7\u00e3o Industrial - PLC: Programa\u00e7\u00e3o e Instala\u00e7\u00e3o. 2. ed. Rio de Janeiro: LTC, 2020. 256p. ISBN 978-8521637080.</li> <li>SILVEIRA, Paulo Rog\u00e9rio da; SANTOS, Winderson E. dos. Automa\u00e7\u00e3o e controle discreto. 7. ed. S\u00e3o Paulo: \u00c9rica, 2006. 235 p. (Cole\u00e7\u00e3o Estude e use. S\u00e9rie Automa\u00e7\u00e3o industrial). ISBN 8571945918.</li> <li>IEEE Transactions on Automation Science and Engineering 2004-. ISSN 1545-5955</li> </ul>","tags":["Controladores L\u00f3gicos Program\u00e1veis","CLP"]},{"location":"ifsp-slt/automacao/sltclpe_plano_aula/","title":"Plano de Aula","text":"","tags":["Controladores L\u00f3gicos Program\u00e1veis","CLP"]},{"location":"ifsp-slt/automacao/sltclpe_plano_aula/#plano-de-aulas","title":"Plano de aulas","text":"Semana Data Conte\u00fado Planejado Metodologia de Ensino e Recursos Material de Apoio 1 06/02 Atividade Complementar - Palestra Cient\u00edfica de in\u00edcio de semestre - Al\u00e9m do Prompt: Comoa Intelig\u00eancia Artificial est\u00e1 redefinindo o aprender a aprender - Prof. Damione - IFSP Salto Palestra 1 09/02 Apresenta\u00e7\u00e3o da disciplina Fundamentos Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.   Slide 2 13/02 Interfaces de Entrada e Sa\u00edda Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. Slide 2 20/02 Interfaces de Entrada e Sa\u00edda Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. Slide 3 23/02 Interfaces de Entrada e Sa\u00edda Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Slide 3 27/02 Criando um projeto no Master Tool Contatos e Bobinas SA: Opera\u00e7\u00f5es l\u00f3gicas Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131) 4 02/03 Sistemas de Numera\u00e7\u00e3o e L\u00f3gicas Digitais Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. Slide 4 06/03 - Contatos e Bobinas- Set/Reset- Bordas 5 09/03 - Programa\u00e7\u00e3o b\u00e1sica em CLP  Programa\u00e7\u00e3o b\u00e1sica em CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. Slide 5 13/03 - Temporizadores (TON) 6 16/03 - Temporizadores (TOF) Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 6 20/03 - Temporizadores (TP) 7 23/03 - Programa\u00e7\u00e3o b\u00e1sica em CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 7 27/03 - Contadores (Up/Down) 8 30/03 - Blocos Funcionais Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 8 06/04 - Entradas e Sa\u00eddas Anal\u00f3gicas Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 9 10/04 - Entradas e Sa\u00eddas Anal\u00f3gicas Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 9 13/04 - Bloco Funcional Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 10 17/04 - Fun\u00e7\u00e3o Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 10 24/04 - M\u00e9todo: Maximiza\u00e7\u00e3o de contatos 11 25/04 IFSol 11 27/04 - M\u00e9todo: Maximiza\u00e7\u00e3o de contatos Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 12 04/05 - M\u00e9todo: Minimiza\u00e7\u00e3o de contatos Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 12 08/05 - M\u00e9todo: Minimiza\u00e7\u00e3o de contatos 13 11/05 - M\u00e9todo: Minimiza\u00e7\u00e3o de contatos Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 13 15/05 - M\u00e9todo: Minimiza\u00e7\u00e3o de contatos 14 18/05 - Sistemas supervisionados; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria. 14 22/05 - Interface Homem-M\u00e1quina; 15 25/05 - Interface Homem-M\u00e1quina; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria, Cabos de comunica\u00e7\u00e3o em rede (Modbus) 15 29/05 - Interface Homem-M\u00e1quina; 16 01/06 - Softwares supervis\u00f3rios; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC, ScadaBR ou equivalente), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria, Cabos de comunica\u00e7\u00e3o em rede (Modbus), adaptador USB-Serial e Serial-Modbus 16 08/06 - Integra\u00e7\u00e3o de sistemas controlados por CLP; 17 12/06 - Integra\u00e7\u00e3o de sistemas controlados por CLP; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 17 15/06 - Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC, ScadaBR ou equivalente), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria, Cabos de comunica\u00e7\u00e3o em rede (Modbus), adaptador USB-Serial e Serial-Modbus 18 19/06 - Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 18 22/06 - Avalia\u00e7\u00e3o Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico (Master Tool IEC, ScadaBR ou equivalente), Equipamento ou Kit de CLP (Altus DUO TB131), Sensores industriais e elementos de acionamento(Contatores ou eletrov\u00e1lvulas) ou kit de acionamento (esteira ou atuadores eletropneum\u00e1ticos), cabos banana para conex\u00e3o el\u00e9trica tempor\u00e1ria, Cabos de comunica\u00e7\u00e3o em rede (Modbus), adaptador USB-Serial e Serial-Modbus 19 26/06 - Avalia\u00e7\u00e3o Pr\u00e1ticas de laborat\u00f3rio: Implementa\u00e7\u00e3o de sistemas de controle com CLP Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 19 29/06 Discuss\u00e3o de Artigo:  Be\u0148o, L., Ku\u010dera, E., Draho\u0161, P. et al. Transforming industrial automation: voice recognition control via containerized PLC device. Sci Rep 14, 29387 (2024). https://doi.org/10.1038/s41598-024-81172-w","tags":["Controladores L\u00f3gicos Program\u00e1veis","CLP"]},{"location":"ifsp-slt/digitais/sltmcmp_ementa/","title":"Ementa","text":"","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/digitais/sltmcmp_ementa/#ementa","title":"Ementa","text":"Componente Curricular Microcontroladores e Microprocessadores Curso TAI - T\u00e9cnico em Automa\u00e7\u00e3o Industrial C\u00f3digo SLTMCMP Semestre 3\u00ba N\u00famero de aulas semanais 3 Quantidade total de aulas 60 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 33,3/16,7 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio B100 Pr\u00e9-requisitos (sugeridos) Hor\u00e1rio T1: Sexta-feira: 19:00 - 20:40 (B100)  T2: Sexta-feira: 20:55 - 22:35 (B100) Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - Pp: Projeto pr\u00e1tico  - M\u00e9dia final = 0,6AL + 0,4Pp <p>Ementa</p> <p>O Componente Curricular desenvolver\u00e1 habilidades de programa\u00e7\u00e3o de microprocessadores para aplica\u00e7\u00f5es industriais. Aborda conhecimentos sobre as principais arquiteturas de microcontroladores e capacidades de programa\u00e7\u00e3o e utiliza\u00e7\u00e3o em aplica\u00e7\u00f5es industriais. E desenvolve habilidades de utiliza\u00e7\u00e3o de ferramentas de programa\u00e7\u00e3o e simula\u00e7\u00e3o de microprocessadores.</p> <p>Objetivos</p> <ul> <li>Interpretar circuitos eletr\u00f4nicos que envolvam microprocessadores e microcontroladores;  </li> <li>Conhecer o processo sob interven\u00e7\u00e3o, bem como, correlacionar as t\u00e9cnicas de manuten\u00e7\u00e3o de equipamentos eletr\u00f4nicos digitais;</li> <li>Conhecer as t\u00e9cnicas de elabora\u00e7\u00e3o de programas em sistemas microcontrolados.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>No\u00e7\u00f5es de programa\u00e7\u00e3o C para microcontroladores;</li> <li>Vis\u00e3o geral de microprocessadores;</li> <li>Mem\u00f3rias: associa\u00e7\u00f5es e aplica\u00e7\u00f5es;</li> <li>Arquitetura geral de um sistema microcontrolado e microprocessado;</li> <li>Caracter\u00edsticas b\u00e1sicas dos circuitos microcontroladores;</li> <li>Utiliza\u00e7\u00e3o de interrup\u00e7\u00f5es, temporizadores, dispositivos de entrada e sa\u00edda e conversores AD e DA;</li> <li>Implementa\u00e7\u00e3o de um sistema microcontrolado.</li> </ul> <p>Bibliografia</p> <ul> <li>MONK, Simon. Programa\u00e7\u00e3o com Arduino II: passos avan\u00e7ados com Sketches. Porto Alegre: Bookman, 2015. 260 p. ISBN-13: 978-8582602966.  </li> <li>NICOLOSI, Denys Em\u00edlio Campion. Laborat\u00f3rio de microcontroladores: fam\u00edlia 8051 : treino de instru\u00e7\u00f5es hardware e software. 5. ed. S\u00e3o Paulo: \u00c9rica, 2012. 206 p. ISBN 9788571948716.  </li> <li>PEREIRA, F\u00e1bio. Microcontroladores PIC: t\u00e9cnicas avan\u00e7adas. 6. ed. S\u00e3o Paulo: \u00c9rica, 2013. 366 p. ISBN 8571947279. </li> <li>IEEE JOURNAL OF SOLID-STATE CIRCUITS. Institute of Electrical and Electronic Engineers, c1966- ISSN: 0018-9200.</li> <li>FEOFILOFF, Paulo. Algoritmos em linguagem C. Rio de Janeiro: Elsevier, 2009. 208 p. ISBN 9788535232493.  </li> <li>IDOETA, Ivan Valeije; CAPUANO, Francisco Gabriel. Elementos de Eletr\u00f4nica Digital. 41. ed. S\u00e3o Paulo, SP: \u00c9rica, 2012, 544 p. ISBN 978-85-7194-019-2. </li> <li>ORDONEZ, Edward David Moreno; PENTEADO, Cesar Giacomini; SILVA, Alexandre C\u00e9sar Rodrigues da. Microcontroladores e FPGAs: aplica\u00e7\u00f5es em automa\u00e7\u00e3o. S\u00e3o Paulo: Novatec, 2006. 378 p. ISBN 8575220799.  </li> <li>TOCCI, Ronald J.; WIDMER, Neal S.; MOSS, Gregory L. Sistemas digitais: princ\u00edpios e aplica\u00e7\u00f5es. 11. ed. S\u00e3o Paulo: Pearson Education do Brasil, 2011.  817 p. ISBN 9788576059226.  </li> <li>ZANCO, Wagner da Silva. Microcontroladores PIC18 com linguagem C: uma abordagem pr\u00e1tica e objetiva com base no PIC184520. S\u00e3o Paulo: \u00c9rica, 2010. 446 p. ISBN 9788536502854.  </li> <li>INTERNATIONAL JOURNAL OF ROBOTICS AND AUTOMATION (IJRA). Institute of Advanced Engineering and Science(IAES). ISSN 2089-4856.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/digitais/sltmcmp_plano_aula/","title":"Plano de Aula","text":"","tags":["Microcontroladores e Microprocessadores","MCMP"]},{"location":"ifsp-slt/digitais/sltmcmp_plano_aula/#plano-de-aulas","title":"Plano de aulas","text":"Semana Data Conte\u00fado Planejado Metodologia de Ensino e Recursos Material de Apoio 1 06/02 Atividade Complementar - Palestra Cient\u00edfica de in\u00edcio de semestre - Al\u00e9m do Prompt: Comoa Intelig\u00eancia Artificial est\u00e1 redefinindo o aprender a aprender - Prof. Damione - IFSP Salto Palestra 2 13/02 Apresenta\u00e7\u00e3o da Disciplina  Sistemas Embarcados; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. Slide 3 20/02 Revis\u00e3o de Eletr\u00f4nica Digital  Microcontroladores;  Simuladores Tinkercad e SimulIDE  Sa\u00eddas Digitais Entradas Digitais Situa\u00e7\u00e3o de Aprendizagem - Sinalizador de Garagem Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. Slide LEDs Chaves/Bot\u00f5es 4 27/02 Revis\u00e3o de Eletr\u00f4nica Digital  Situa\u00e7\u00e3o de Aprendizagem (SA)- Sinalizador de Garagem SA - Partida Estr\u00eala-Tri\u00e2ngulo Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. LEDs Chaves/Bot\u00f5es 5 06/03 Arquitetura geral de um sistema microcontrolado e microprocessado; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. 6 13/03 Vis\u00e3o geral de microprocessadores; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. 7 20/03 Caracter\u00edsticas b\u00e1sicas dos circuitos microcontroladores; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 8 27/03 Mem\u00f3rias: associa\u00e7\u00f5es e aplica\u00e7\u00f5es; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 9 03/04 No\u00e7\u00f5es de programa\u00e7\u00e3o C para microcontroladores: Compila\u00e7\u00e3o, Grava\u00e7\u00e3o e Debug; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 10 10/04 No\u00e7\u00f5es de programa\u00e7\u00e3o C para microcontroladores: Versionamento Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 11 17/04 Dispositivos de entrada e sa\u00edda digital; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 12 24/04 Temporizadores e interrup\u00e7\u00f5es; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 13 25/04 - IFSol 14 08/05 Conversores AD e DA e interrup\u00e7\u00f5es; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 15 15/05 Implementa\u00e7\u00e3o de um sistema microcontrolado; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 16 22/05 Implementa\u00e7\u00e3o de um sistema microcontrolado: display LCD e Teclado Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 17 29/05 Implementa\u00e7\u00e3o de um sistema microcontrolado: Sensores de temperatura e umidade; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 18 12/06 Implementa\u00e7\u00e3o de um sistema microcontrolado: Servomotores; Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 19 19/06 Avalia\u00e7\u00e3o de sistemas Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 20 26/06 Avalia\u00e7\u00e3o de sistemas Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada  Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos.","tags":["Microcontroladores e Microprocessadores","MCMP"]},{"location":"ifsp-slt/digitais/sltsdig_ementa/","title":"Ementa","text":"","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/digitais/sltsdig_ementa/#ementa","title":"Ementa","text":"Componente Curricular Sistemas Digitais Curso Engenharia de Controle e Automa\u00e7\u00e3o C\u00f3digo SLTSDIG Semestre 5\u00ba N\u00famero de aulas semanais 4 Quantidade total de aulas 76 Carga hor\u00e1ria presencial/\u00e0 dist\u00e2ncia 63,3/0,0 Abordagem metodol\u00f3gica Te\u00f3rico/Pr\u00e1tica Laborat\u00f3rio D105-C102/B100 Pr\u00e9-requisitos (sugeridos) Hor\u00e1rio Quarta-feira (B100): T2: 07:00 - 08:40 T1: 08:50 - 10:30  Sexta-feira (D105): 08:50 - 10:30 Avalia\u00e7\u00e3o do ensino/aprendizagem - AL: Atividades em laborat\u00f3rio  - P: Prova  - M\u00e9dia final = 0,5.AL + 0,5.P <p>Ementa</p> <p>A disciplina trabalha os sistemas de numera\u00e7\u00e3o, conceitos de eletr\u00f4nica digital, \u00e1lgebra booleana, l\u00f3gica combinacional, l\u00f3gica sequencial e M\u00e1quinas de Estados.</p> <p>Objetivos</p> <ul> <li>Desenvolver o conhecimento de conceitos relativos \u00e0 eletr\u00f4nica digital;</li> <li>Compreender, a partir do estudo da \u00e1lgebra booleana, l\u00f3gica sequencial e combinacional, o desenvolvimento de in\u00fameros circuitos digitais;</li> <li>Realizar experimenta\u00e7\u00f5es pr\u00e1ticas desses conhecimentos.</li> </ul> <p>Conte\u00fado Program\u00e1tico</p> <ul> <li>Fun\u00e7\u00f5es e portas l\u00f3gicas;</li> <li>Circuitos l\u00f3gicos;</li> <li>Fam\u00edlias l\u00f3gicas TTL e CMOS;</li> <li>\u00c1lgebra booleana e tabela verdade;</li> <li>Minitermos e Maxitermos;</li> <li>Simplifica\u00e7\u00e3o de circuitos l\u00f3gicos via teoremas e Mapa de Karnough;</li> <li>Circuitos Combinacionais:<ul> <li>Codificadores e decodificadores,</li> <li>Multiplex e demultiplex;</li> <li>Circuitos e Opera\u00e7\u00f5es Aritm\u00e9ticas.</li> </ul> </li> <li>Circuitos sequenciais:<ul> <li>Flip-Flops,</li> <li>Contadores Ass\u00edncronos e S\u00edncronos,</li> <li>Registradores de Deslocamento.</li> </ul> </li> <li>Pr\u00e1ticas de laborat\u00f3rio: Desenvolvimento de experimentos de eletr\u00f4nica digital;</li> <li>Pr\u00e1ticas de laborat\u00f3rio: Montagem de circuitos digitais com portas l\u00f3gicas, Flip-Flops, efetuar simplifica\u00e7\u00e3o de circuitos de l\u00f3gica booleana, montar circuitos com mem\u00f3ria e contadores.</li> </ul> <p>Bibliografia</p> <ul> <li>GARCIA, Paulo Alves; MARTINI, Jos\u00e9 Sidnei Colombo. Eletr\u00f4nica digital: teoria e laborat\u00f3rio. 2.ed. S\u00e3o Paulo: \u00c9rica, 2008. 182 p. ISBN 9788536501093.</li> <li>LOUREN\u00c7O, Antonio Carlos; CRUZ, Eduardo C\u00e9sar Alves; FERREIRA, Sabrina Rodero; CHOUERI J\u00daNIOR, Salom\u00e3o. Circuitos digitais. 9. ed. S\u00e3o Paulo: \u00c9rica, 2007. 336 p. ISBN 9788571943209.</li> <li>PEDRONI, Volnei A. Eletr\u00f4nica digital moderna e VHDL. Rio de Janeiro: Elsevier, 2010. 619 p.ISBN 9788535234657. </li> <li> <p>ACTIVE AND PASSIVE ELECTRONIC COMPONENTS. London: Hindawi Publishing Corporation, 1985-. ISSN 0882-7516.</p> </li> <li> <p>HAUPT, Alexandre; DACHI, \u00c9dison. Eletr\u00f4nica Digital. 1a Edi\u00e7\u00e3o. S\u00e3o Paulo: Blucher, 2016. 231pp. ISBN: 9788521210092</p> </li> <li>IDOETA, Ivan Valeije; CAPUANO, Francisco Gabriel. Elementos de Eletr\u00f4nica Digital. 41. ed. S\u00e3o Paulo, SP: \u00c9rica, 2012, 544 p. ISBN 978-85-7194-019-2.</li> <li>MALVINO, Albert Paul; BATES, David J. Eletr\u00f4nica: volume 1. 8. ed. Porto Alegre: AMGH, 2016. 567 p. ISBN 9788580555769</li> <li>SEDRA, Adel S.; SMITH, Kenneth C. Microeletr\u00f4nica. 5. ed. S\u00e3o Paulo: Pearson Education do Brasil, 2012. 848 p. ISBN 978-85-7605-022-3.</li> </ul>","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/digitais/sltsdig_plano_aula/","title":"Plano de Aula","text":"","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/digitais/sltsdig_plano_aula/#plano-de-aulas","title":"Plano de aulas","text":"Semana Data Conte\u00fado Planejado Metodologia de Ensino e Recursos Material de apoio 1 06/02 Atividade Complementar - Palestra Cient\u00edfica de in\u00edcio de semestre - Al\u00e9m do Prompt: Comoa Intelig\u00eancia Artificial est\u00e1 redefinindo o aprender a aprender - Prof. Damione - IFSP Salto Palestra 1 11/02 Apresenta\u00e7\u00e3o da Disciplina Fundamentos de Sistemas Digitais; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. Slide 2 13/02 Sistemas de Numera\u00e7\u00e3o Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia. Slide 2 20/02 L\u00f3gica Combinacional B\u00e1sica - Portas l\u00f3gicas:    - Fundamentais (AND, OR, NOT);   - Derivadas (NAND, NOR, XOR, XNOR); - Tabelas-verdade; Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia Slide 3 25/02 Express\u00f5es l\u00f3gicas e circuitos Exposi\u00e7\u00e3o Dialogada: Lousa/Quadro branco e projetor multim\u00eddia.   Lab. de Eletr\u00f4nica, kit did\u00e1tico e software espec\u00edfico Slide 3 27/02 Express\u00f5es l\u00f3gicas e circuitos Lab. Inform\u00e1tica e software espec\u00edfico Slide 4 04/03 - Otimiza\u00e7\u00e3o de circuitos atrav\u00e9s de simplifica\u00e7\u00e3o de express\u00f5es l\u00f3gicas- \u00c1lgebra de Boole Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico, matriz de contatos e componentes eletr\u00f4nicos. 4 06/03 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 5 11/03 - Teorema de De Morgan 5 13/03 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 6 18/03 - Mapa de Karnaugh 6 20/03 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 7 25/03 - Somadores e subtratores 7 27/03 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 8 01/04 - Comparadores 8 08/04 - Decodificadores Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 9 10/04 9 15/04 - Multiplexadores Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 10 17/04 10 22/04 - Latches e Flip-Flops Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 11 24/04 - Flip-flop tipo D 11 25/04 - IFSol 12 29/04 - Sinal de clock 12 06/05 - Registradores de deslocamento Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 13 08/05 13 13/05 - Contadores Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 14 15/05 - Contadores Ass\u00edncronos 14 20/05 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 15 22/05 - Contadores S\u00edncronos 15 27/05 Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 16 29/05 - Contadores S\u00edncronos 16 03/06 17 10/06 - Conversores A/D Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 17 12/06 18 17/06 - Conversores D/A Exposi\u00e7\u00e3o dialogada e Pr\u00e1tica orientada Lab. Inform\u00e1tica, software espec\u00edfico 18 19/06 Fundamentos de l\u00f3gica reconfigur\u00e1vel e VHDL. Estudo do artigo: Z. Xin-Li and W. Hong-Ying, \"The Application of Digital Electronics in Networking Communication,\" 2016 Eighth International Conference on Measuring Technology and Mechatronics Automation (ICMTMA), Macau, China, 2016, pp. 684-687, doi: 10.1109/ICMTMA.2016.168. 19 24/06 Avalia\u00e7\u00e3o 19 26/06","tags":["Sistemas Digitais","Eletr\u00f4nica Digital"]},{"location":"ifsp-slt/redes/lab04/","title":"Lab. 04 - Rede ponto a ponto","text":"","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"ifsp-slt/redes/lab04/#objetivo","title":"Objetivo","text":"<p>Executar a comunica\u00e7\u00e3o de acordo com a arquitetura da ilustra\u00e7\u00e3o, entre duas esta\u00e7\u00f5es, de modo que uma esta\u00e7\u00e3o monitore e comande, respectivamente, a chave e o led, da outra esta\u00e7\u00e3o.</p> <p>Desafios:</p> <ol> <li> <p>Definir em conjunto (equipes das duas esta\u00e7\u00f5es):</p> <ul> <li>Um comando para a leitura da chave/contato, representando o sinal digital de entrada;</li> <li>Um comando para o acionamento do led, representando o sinal digital de sa\u00edda (um comando para ligar e outro para desligar o led);</li> <li>Os par\u00e2metros de comunica\u00e7\u00e3o, tais como velocidade de comunica\u00e7\u00e3o (baud rate), paridade, stop bits;</li> <li>A pinagem para o cabo de comunica\u00e7\u00e3o entre as esta\u00e7\u00f5es.</li> </ul> </li> <li> <p>Elabore um relat\u00f3rio, por equipe, contendo:</p> <ul> <li>Identifica\u00e7\u00e3o dos integrantes;</li> <li>Estrutura do trabalho (introdu\u00e7\u00e3o, materiais, desenvolvimento, conclus\u00e3o);</li> <li>Diagrama simplificado de conex\u00f5es;</li> <li>Configura\u00e7\u00e3o de comunica\u00e7\u00e3o;</li> <li>Configura\u00e7\u00e3o do cabo de comunica\u00e7\u00e3o;</li> <li>Programa executado no Arduino;</li> <li>Tabela de comandos;</li> <li>Captura, via oscilosc\u00f3pio, dos sinais de comando para a leitura da chave e escrita no LED. </li> <li>Compet\u00eancias desenvolvidas;</li> <li>Habilidades trabalhadas;</li> <li>Dificuldades encontradas;</li> <li>Salvar em formato .pdf;</li> <li>Enviar no e-mail: jose.pereira@ifsp.edu.br</li> <li>Data limite para nota completa: 29/09/2025<ul> <li>Ap\u00f3s esta data: nota = avalia\u00e7\u00e3o - 0,1 * dias_em_atraso;</li> </ul> </li> </ul> </li> </ol>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"ifsp-slt/redes/lab05/","title":"Lab. 05 - Rede multiponto - RS485","text":"","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"ifsp-slt/redes/lab05/#objetivo","title":"Objetivo","text":"<p>Executar a comunica\u00e7\u00e3o de acordo com a arquitetura da ilustra\u00e7\u00e3o, de modo que uma esta\u00e7\u00e3o cliente monitore e comande, respectivamente, a chave e o led, dos servidores 1 e 2.</p> <p>Desafios:</p> <ol> <li> <p>Definir em conjunto (duas equipes):</p> <ul> <li>Um comando para a leitura da chave/contato, representando o sinal digital de entrada;</li> <li>Um comando para o acionamento do led, representando o sinal digital de sa\u00edda (um comando para ligar e outro para desligar o led);</li> <li>Os par\u00e2metros de comunica\u00e7\u00e3o, tais como velocidade de comunica\u00e7\u00e3o (baud rate), paridade, stop bits.</li> </ul> </li> <li> <p>Elabore um relat\u00f3rio, por equipe, contendo:</p> <ul> <li>Identifica\u00e7\u00e3o dos integrantes;</li> <li>Estrutura do trabalho (introdu\u00e7\u00e3o, materiais, desenvolvimento, conclus\u00e3o);</li> <li>Diagrama simplificado de conex\u00f5es;</li> <li>Configura\u00e7\u00e3o de comunica\u00e7\u00e3o;</li> <li>Configura\u00e7\u00e3o do cabo de comunica\u00e7\u00e3o;</li> <li>Programa executado no Arduino;</li> <li>Tabela de comandos;</li> <li>Captura, via oscilosc\u00f3pio, dos sinais de comando para a leitura da chave e escrita no LED. </li> <li>Compet\u00eancias desenvolvidas;</li> <li>Habilidades trabalhadas;</li> <li>Dificuldades encontradas;</li> <li>Salvar em formato .pdf;</li> <li>Enviar no e-mail: jose.pereira@ifsp.edu.br</li> <li>Data limite para nota completa: 06/10/2025<ul> <li>Ap\u00f3s esta data: nota = avalia\u00e7\u00e3o - 0,1 * dias_em_atraso;</li> </ul> </li> </ul> </li> </ol> <ul> <li>HW-519 - UsinaInfo</li> <li>HW-519 - SmartKits</li> </ul>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"ifsp-slt/redes/lab06/","title":"Lab. 06 - Modbus RTU (Remote Terminal Unit)","text":"ModbusRTUserver<pre><code>    // Bibliotecas\n#include &lt;ArduinoRS485.h&gt;   // ArduinoModbus depende da lib ArduinoRS485 (instalar via gerenciador)\n#include &lt;ArduinoModbus.h&gt;  // Lib Arduino Modbus (instalar via gerenciador)\n\n    // Parametros de comunicao\n#define SLAVE_ID            1               // endereco do escravo Modbus RTU\n#define BAUDRATE            9600            // 9600 bps\n#define UART_CONFIG         SERIAL_8N1      // 8 data bits, sem paridade, 1 stop bit\n\n    // Mapeamento dos pinos de entradas e saidas\nconst int inputDigitalMap[]   = { 8, 9 };     // pinos usados como entradas digitais - digital inputs\nconst int inputAnalogMap[]    = { A0, A1 };   // pinos usados como entradas analogicas - input registers\nconst int outputCoilMap[]     = { 11, 12 };   // pinos usados como saidas digitais - coils\nconst int outputPwmMap[]      = { 5, 6 };     // pinos usados como saidas analogicas (pwm) - holding register 16 bits\n    // o pino 13, do led interno (LED_BUILTIN) utilizado para teste dos holding registers\n\n    // Numero de entradas e saidas\n#define DIGITAL_INPUTS_SIZE       (sizeof(inputDigitalMap)&gt;&gt;1)  // discrete inputs - bit\n#define ANALOG_INPUTS_SIZE        (sizeof(inputAnalogMap)&gt;&gt;1)   // input registers - 16 bits\n#define COILS_SIZE                (sizeof(outputCoilMap)&gt;&gt;1)    // coils - bit\n#define PWM_OUTPUTS_SIZE          (sizeof(outputPwmMap)&gt;&gt;1)     // holding registers - 16 bits\n#define HOLDING_REGISTERS_SIZE    8                             // 8 variaveis internas (holding registers - 16 bits)\n\n    // Enderecos iniciais dos registradores - 16 enderecos para cada tipo\n#define DIGITAL_INPUT_ADDRESS   0x0000\n#define ANALOG_INPUT_ADDRESS    0x0010\n#define COIL_ADDRESS            0x0020\n#define PWM_OUTPUTS_ADDRESS     0x0030\n#define HOLDING_REGS_ADDRESS    PWM_OUTPUTS_ADDRESS + PWM_OUTPUTS_SIZE  // endereco das variaveis internas comeca depois dos pwm\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////// Configuracoes\n\nvoid setup() \n{\n\n///////////////////////////////////////////////////// Arduino\n\n  for(int i = 0; i &lt; DIGITAL_INPUTS_SIZE; i++) \n  {\n    pinMode(inputDigitalMap[i], INPUT_PULLUP);      // Entradas com Pull-up habilitado\n  }\n\n  for (int i = 0; i &lt; COILS_SIZE; i++) \n  {\n    pinMode(outputCoilMap[i], OUTPUT);              // Sa\u00eddas\n    digitalWrite(outputCoilMap[i], LOW);            // Inicializadas com 0\n  }\n\n  for (int i = 0; i &lt; PWM_OUTPUTS_SIZE; i++) \n  {\n    analogWrite(outputPwmMap[i], 0);                // Sa\u00eddas Anal\u00f3gicas com PWM=0\n  }\n\n  pinMode(LED_BUILTIN, OUTPUT);                     // LED da placa\n\n////////////////////////////////////////////////////// Servidor Modbus RTU\n\n  if (!ModbusRTUServer.begin(SLAVE_ID, BAUDRATE, UART_CONFIG)) \n  {\n    Serial.println(\"Falhou ao iniciar o Servidor Modbus RTU!\");\n    while (1)\n      ;\n  }\n\n    // Associa os enderecos de registradores do servidor modbus para as entradas e sa\u00eddas definidas \n  ModbusRTUServer.configureDiscreteInputs(DIGITAL_INPUT_ADDRESS, DIGITAL_INPUTS_SIZE);\n  ModbusRTUServer.configureInputRegisters(ANALOG_INPUT_ADDRESS, ANALOG_INPUTS_SIZE);\n  ModbusRTUServer.configureCoils(COIL_ADDRESS, COILS_SIZE);\n  ModbusRTUServer.configureHoldingRegisters(PWM_OUTPUTS_ADDRESS, PWM_OUTPUTS_SIZE + HOLDING_REGISTERS_SIZE);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n///////////////////////// Sincroniza entradas e saidas com o Modbus RTU Server\n\nvoid loop() \n{\n    // Verifica requisicoes Modbus RTU recebidas e atualiza dados no servidor\n  ModbusRTUServer.poll();               \n\n\n    // Rotina de atualizacao das ENTRADAS\n    // atualiza o estado das entradas mapeadas na memoria do servidor\n\n  for (int i = 0; i &lt; DIGITAL_INPUTS_SIZE; i++) \n  {\n    ModbusRTUServer.writeDiscreteInputs(DIGITAL_INPUT_ADDRESS + i, digitalRead(inputDigitalMap[i]), 1);\n  }\n\n  for (int i = 0; i &lt; ANALOG_INPUTS_SIZE; i++) \n  {\n    uint16_t tempRead = analogRead(inputAnalogMap[i]);\n    ModbusRTUServer.writeInputRegisters(ANALOG_INPUT_ADDRESS + i, &amp;tempRead, 1);\n  }\n\n    // Rotina de atualizacao das SAIDAS\n    // escreve estado das saidas mapeadas conforme a memoria atual do servidor\n\n  for (int i = 0; i &lt; COILS_SIZE; i++) \n  {\n    digitalWrite(outputCoilMap[i], ModbusRTUServer.coilRead(COIL_ADDRESS + i));\n  }\n\n  for (int i = 0; i &lt; PWM_OUTPUTS_SIZE; i++) \n  {\n    analogWrite(outputPwmMap[i], ModbusRTUServer.holdingRegisterRead(PWM_OUTPUTS_ADDRESS + i));\n  }\n\n    // Rotina de atualizacao das vars anal\u00f3gicas p\u00f3s pwm\n\n    // Teste de leitura dos holding registers (word, 16 bits)\n  uint16_t testValue = ModbusRTUServer.holdingRegisterRead(PWM_OUTPUTS_ADDRESS + PWM_OUTPUTS_SIZE + 0);\n  if (testValue &gt; 1000) \n    digitalWrite(LED_BUILTIN, HIGH);\n  else \n    digitalWrite(LED_BUILTIN, LOW);\n\n    // Teste de escrita dos holding registers\n    // o holding register com offset 1 guarda o tempo decorrido em segundos desde a inicializacao do Arduino\n  uint16_t seconds = millis() / 1000;\n  ModbusRTUServer.holdingRegisterWrite(PWM_OUTPUTS_ADDRESS + PWM_OUTPUTS_SIZE + 1, seconds);\n}\n</code></pre>","tags":["Redes Industriais","Protocolos de Comunica\u00e7\u00e3o","RPI"]},{"location":"ifsp-slt/saut/lista1/","title":"Redes Industriais","text":"<p>Os slides de aula fornecem uma vis\u00e3o abrangente das Redes Industriais, come\u00e7ando com um resumo das quatro Revolu\u00e7\u00f5es Industriais e a transi\u00e7\u00e3o do carv\u00e3o na Ind\u00fastria 1.0 para a depend\u00eancia de dados na Ind\u00fastria 4.0. Um foco principal \u00e9 a converg\u00eancia das Tecnologias de Informa\u00e7\u00e3o (TI) e Tecnologias de Automa\u00e7\u00e3o (TA), destacando a fus\u00e3o dessas \u00e1reas para aprimorar o processo produtivo e otimizar a tomada de decis\u00f5es. O material tamb\u00e9m detalha os objetivos das redes industriais, como a redu\u00e7\u00e3o de custos e o aumento da agilidade empresarial, e explora os tipos e classifica\u00e7\u00f5es de redes, incluindo modos de opera\u00e7\u00e3o como Half Duplex e Full Duplex. Al\u00e9m disso, discute a finalidade dos protocolos de comunica\u00e7\u00e3o no ambiente industrial e as necessidades emergentes relacionadas \u00e0 ciberseguran\u00e7a e \u00e0 ado\u00e7\u00e3o da Internet Industrial das Coisas (IIoT).</p> <ul> <li>Formul\u00e1rio - Data final: 03/11/2025</li> </ul>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"ifsp-slt/vhdl/lista1/","title":"Lista 1 - Decodificadores - Form","text":"<p>1) Elabore, em VHDL, a descri\u00e7\u00e3o do circuito digital equivalente ao comportamento apresentado na tabela verdade.</p> B A Y 0 0 1 0 1 0 1 0 1 1 1 1 <p>2) Elabore, em VHDL, a descri\u00e7\u00e3o do circuito digital equivalente ao comportamento apresentado na tabela verdade.</p> C B A Y 0 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 1 1 1 1 0 0 1 1 1 0 <p>3) Os display de 7 segmentos s\u00e3o dispositivos eletr\u00f4nicos formados por LEDs organizados de modo a exibir os d\u00edgitos de 0 a 9 e em alguns casos tamb\u00e9m pode exibir caracteres alfanum\u00e9ricos.  S\u00e3o costumeiramente usados em mostradores de rel\u00f3gios, eletrodom\u00e9sticos, elevadores, calculadoras, instrumentos de medi\u00e7\u00e3o, etc.  Existem diversos dispositivos que fazem a convers\u00e3o de valores num\u00e9ricos bin\u00e1rios para os respectivos segmentos do display, podendo ser chip dedicado como o 7447 ou microcontroladores programados, convertendo assim o padr\u00e3o Binary-Coded-Decimal (BCD-8421) para a sequencia dos segmentos do display. </p> <p>Elabore, em VHDL, a descri\u00e7\u00e3o do circuito digital equivalente ao conversor BCD-8421 para Display7Segmentos, conforme tabela. </p> <p>Complete a tabela de sa\u00edda para valores entre 10 e 15, respectivamente 0xA e 0xF em hexadecimal. </p> <p></p> <p>4) O c\u00f3digo Johnson \u00e9 um tipo de sequ\u00eancia de contagem que apresenta mudan\u00e7a de apenas um bit por vez na sua sequ\u00eancia de incremento, realizando a m\u00ednima transi\u00e7\u00e3o de bits, prevenindo erros na transi\u00e7\u00e3o dos valores da contagem, altamente recomendado para aplica\u00e7\u00f5es de alta velocidade. </p> <p>A tabela que segue apresenta a convers\u00e3o entre a codifica\u00e7\u00e3o BCD-8421 e seus respectivos valores no contador Johnson.</p> <p>Elabore, em VHDL, a descri\u00e7\u00e3o do circuito digital equivalente ao comportamento apresentado na tabela verdade utilizando a estrutura when else.</p> <p></p> <p>5) A codifica\u00e7\u00e3o Gray, da mesa forma que a contagem Johnson apresenta a m\u00ednima transi\u00e7\u00e3o de bits, e \u00e9 amplamente utilizada em encoders rotativos, mapa de Karnaugh e at\u00e9 em algoritmos gen\u00e9ticos, representando genes de indiv\u00edduos que sofrem muta\u00e7\u00f5es gradativas, evitando mudan\u00e7as bruscas na representa\u00e7\u00e3o das muta\u00e7\u00f5es. </p> <p>Na ind\u00fastria, dispositivos rotativos que necessitam de velocidade e aus\u00eancia de erros na representa\u00e7\u00e3o tais como elevadores, portas autom\u00e1ticas, esteiras transportadoras e turbinas e\u00f3licas. </p> <p>Uma forma de converter o padr\u00e3o BCD-8421 para Gray \u00e9:</p> <ul> <li>Realizar a opera\u00e7\u00e3o XOR de cada posi\u00e7\u00e3o atual com o bit adjacente mais significativo e o resultado fica na posi\u00e7\u00e3o atual. </li> <li>A \u00fanica exce\u00e7\u00e3o \u00e9 o MSB (Most Significant Bit) que permanece o mesmo, inclusive por n\u00e3o haver bit \u00e0 sua esquerda. </li> </ul> <p>Elabore, em VHDL, a descri\u00e7\u00e3o do circuito digital equivalente ao comportamento apresentado na tabela verdade. </p> <p></p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"ifsp-slt/vhdl/lista2/","title":"Lista 2 - Flip-flop D - Form","text":"<p>Algumas vers\u00f5es de flip-flop apresentam entradas ass\u00edncronas para ligar (preset) e desligar (reset) a sa\u00edda, independente da entrada e do sinal de sincronismo (clk). Utilizando os arquivos de descri\u00e7\u00e3o <code>latch_sr.vhdl</code>, <code>latch_d.vhdl</code> e <code>d_ff.vhdl</code>, apresentados em aula, fa\u00e7a:</p> <p>1) Modifique o arquivo <code>d_ff.vhdl</code> de modo que a descri\u00e7\u00e3o seja equivalente ao flip-flop tipo D apresentado na Figura 1. </p> Figura 1: Flip-flop tipo D com Clear Fonte: Autor <p>Note que para for\u00e7ar a sa\u00edda para zero, o sinal <code>CLR</code> deve estar zerado, pois h\u00e1 uma inversora na entrada do sinal. </p> <p>2) Modifique o arquivo <code>d_ff.vhdl</code> de modo que a descri\u00e7\u00e3o seja equivalente ao flip-flop tipo D apresentado na Figura 2. </p> Figura 2: Flip-flop tipo D com Preset e Clear Fonte: Autor <p>Note que neste exerc\u00edcio, h\u00e1 inversoras nas entradas de Preset, Clear e Clock. </p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"ifsp-slt/vhdl/lista3/","title":"Lista 3 - Conversor Serial-Paralelo","text":"","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]},{"location":"ifsp-slt/vhdl/lista4/","title":"Lista 4 - Contador crescente e decrescente e mostrador de 7 segmentos","text":"<p>Elaborar um programa em VHDL para realizar a contagem crescente e decrescente de um n\u00famero de pelo menos um d\u00edgito e mostrar no display de 7 segmentos. Usar o kit de desenvolvimento DE1-SoC, com um bot\u00e3o para incremento, um bot\u00e3o para decremento do n\u00famero exibido no display. </p> <p>Enviar o arquivo do projeto e apresentar o funcionamento ao professor. </p>","tags":["Sistemas Eletr\u00f4nicos","FPGA","VHDL"]}]}